<!DOCTYPE html>
<html lang="de">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Linux CLI Quiz – Cyber Security Kurs</title>
    <style>
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        background: #0f172a;
        color: #e5e7eb;
        line-height: 1.5;
      }
      header {
        padding: 1rem 1.5rem 0.75rem;
        background: #020617;
        border-bottom: 1px solid #1f2937;
        position: sticky;
        top: 0;
        z-index: 10;
      }
      .header-inner {
        max-width: 960px;
        margin: 0 auto;
      }
      h1 {
        margin: 0 0 0.2rem;
        font-size: 1.4rem;
        font-weight: 600;
      }
      .subtitle {
        font-size: 0.9rem;
        color: #9ca3af;
        margin: 0;
      }
      .search-container {
        margin-top: 1rem;
        margin-bottom: 0.5rem;
      }
      .search-input {
        width: 100%;
        padding: 0.6rem 0.9rem;
        background: #111827;
        border: 1px solid #1f2937;
        border-radius: 0.6rem;
        color: #e5e7eb;
        font-size: 0.9rem;
        font-family: inherit;
        transition: border-color 0.2s, box-shadow 0.2s;
      }
      .search-input:focus {
        outline: none;
        border-color: #3b82f6;
        box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
      }
      .search-input::placeholder {
        color: #6b7280;
      }
      .command-card.hidden {
        display: none;
      }

      /* Achievements / Badges */
      .achievements-container {
        margin-top: 1rem;
        display: flex;
        flex-wrap: wrap;
        gap: 0.6rem;
        align-items: center;
      }
      .achievement-badge {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        padding: 0.4rem 0.7rem;
        border-radius: 999px;
        font-size: 0.75rem;
        font-weight: 600;
        border: 2px solid;
        background: linear-gradient(
          135deg,
          rgba(255, 255, 255, 0.1),
          rgba(255, 255, 255, 0.05)
        );
        backdrop-filter: blur(8px);
        transition: all 0.3s ease;
        position: relative;
        overflow: hidden;
      }
      .achievement-badge::before {
        content: "";
        position: absolute;
        inset: 0;
        background: linear-gradient(
          135deg,
          rgba(255, 255, 255, 0.2),
          transparent
        );
        opacity: 0;
        transition: opacity 0.3s ease;
      }
      .achievement-badge:hover::before {
        opacity: 1;
      }
      .achievement-badge.unlocked {
        animation: badgeUnlock 0.6s ease-out;
        box-shadow: 0 0 20px rgba(255, 215, 0, 0.5),
          0 4px 12px rgba(0, 0, 0, 0.3);
      }
      .achievement-badge.locked {
        opacity: 0.4;
        filter: grayscale(0.8);
      }
      .achievement-badge.golden {
        border-color: #fbbf24;
        background: linear-gradient(
          135deg,
          rgba(251, 191, 36, 0.4),
          rgba(245, 158, 11, 0.3)
        );
        box-shadow: 0 0 30px rgba(251, 191, 36, 0.7),
          0 4px 16px rgba(245, 158, 11, 0.4),
          inset 0 1px 0 rgba(255, 255, 255, 0.2);
        animation: goldenGlow 2s ease-in-out infinite;
        position: relative;
        overflow: visible;
      }
      .achievement-badge.golden::before {
        content: "";
        position: absolute;
        inset: -2px;
        background: linear-gradient(
          135deg,
          rgba(251, 191, 36, 0.3),
          transparent 50%,
          rgba(245, 158, 11, 0.3)
        );
        border-radius: 999px;
        z-index: -1;
        animation: goldenShine 3s ease-in-out infinite;
      }
      @keyframes goldenGlow {
        0%,
        100% {
          box-shadow: 0 0 30px rgba(251, 191, 36, 0.7),
            0 4px 16px rgba(245, 158, 11, 0.4);
        }
        50% {
          box-shadow: 0 0 40px rgba(251, 191, 36, 0.9),
            0 6px 20px rgba(245, 158, 11, 0.6);
        }
      }
      @keyframes goldenShine {
        0%,
        100% {
          opacity: 0.5;
        }
        50% {
          opacity: 0.8;
        }
      }
      .achievement-icon {
        font-size: 1rem;
      }
      .achievement-badge.badge-10 {
        border-color: #a78bfa;
        color: #c4b5fd;
        background: linear-gradient(
          135deg,
          rgba(167, 139, 250, 0.2),
          rgba(124, 58, 237, 0.1)
        );
      }
      .achievement-badge.badge-20 {
        border-color: #60a5fa;
        color: #93c5fd;
        background: linear-gradient(
          135deg,
          rgba(96, 165, 250, 0.2),
          rgba(59, 130, 246, 0.1)
        );
      }
      .achievement-badge.badge-30 {
        border-color: #34d399;
        color: #6ee7b7;
        background: linear-gradient(
          135deg,
          rgba(52, 211, 153, 0.2),
          rgba(16, 185, 129, 0.1)
        );
      }
      .achievement-badge.badge-40 {
        border-color: #f59e0b;
        color: #fcd34d;
        background: linear-gradient(
          135deg,
          rgba(245, 158, 11, 0.2),
          rgba(217, 119, 6, 0.1)
        );
      }
      .achievement-badge.badge-50 {
        border-color: #ec4899;
        color: #f9a8d4;
        background: linear-gradient(
          135deg,
          rgba(236, 72, 153, 0.2),
          rgba(219, 39, 119, 0.1)
        );
      }
      .achievement-badge.badge-60 {
        border-color: #fbbf24;
        color: #fde68a;
        background: linear-gradient(
          135deg,
          rgba(251, 191, 36, 0.2),
          rgba(245, 158, 11, 0.1)
        );
        box-shadow: 0 0 25px rgba(251, 191, 36, 0.4);
      }
      @keyframes badgeUnlock {
        0% {
          transform: scale(0.8) rotate(-5deg);
          opacity: 0;
        }
        50% {
          transform: scale(1.15) rotate(5deg);
        }
        100% {
          transform: scale(1) rotate(0deg);
          opacity: 1;
        }
      }
      @keyframes slideIn {
        from {
          transform: translateX(100%);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }
      @keyframes slideOut {
        from {
          transform: translateX(0);
          opacity: 1;
        }
        to {
          transform: translateX(100%);
          opacity: 0;
        }
      }
      .achievement-progress {
        font-size: 0.7rem;
        color: #9ca3af;
        margin-top: 0.3rem;
      }

      /* Badge-Leiste für Haupt-Badges - Professionelles Layout */
      .badges-header {
        margin-top: 1.2rem;
        margin-bottom: 1.2rem;
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100%;
        padding: 0 1rem;
      }

      /* Haupt-Badge Reihe - Professionelle Ausrichtung */
      .main-badges-row {
        display: flex;
        gap: 1.2rem;
        justify-content: center;
        align-items: stretch;
        width: 100%;
        max-width: 1200px;
        margin: 0 auto;
        flex-wrap: nowrap;
      }

      /* Haupt-Badge Stil - Professionell ausgerichtet */
      .main-badge {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: space-between;
        gap: 0.5rem;
        padding: 0.9rem 1rem;
        border-radius: 0.75rem;
        font-size: 0.85rem;
        font-weight: 600;
        border: 2px solid;
        background: linear-gradient(
          135deg,
          rgba(255, 255, 255, 0.1),
          rgba(255, 255, 255, 0.05)
        );
        backdrop-filter: blur(8px);
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        cursor: pointer;
        position: relative;
        overflow: hidden;
        flex: 1 1 0;
        min-width: 170px;
        max-width: 220px;
        height: 120px;
        box-sizing: border-box;
      }

      .main-badge:hover {
        transform: translateY(-3px);
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.45);
        border-width: 2.5px;
      }

      .main-badge.active {
        box-shadow: 0 0 28px rgba(59, 130, 246, 0.65),
          0 6px 16px rgba(0, 0, 0, 0.35);
        transform: scale(1.02);
        border-width: 2.5px;
      }

      .main-badge-header {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.5rem;
        width: 100%;
        flex-shrink: 0;
      }

      .main-badge-icon {
        font-size: 1.3rem;
        line-height: 1;
        flex-shrink: 0;
      }

      .main-badge-name {
        font-size: 0.875rem;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        text-align: center;
        line-height: 1.2;
        font-weight: 600;
      }

      /* Ladebalken für Fortschritt */
      .main-badge-progress-bar {
        width: 100%;
        height: 7px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 4px;
        overflow: hidden;
        position: relative;
        flex-shrink: 0;
        margin: 0.2rem 0;
      }

      .main-badge-progress-fill {
        height: 100%;
        background: linear-gradient(
          90deg,
          currentColor,
          rgba(255, 255, 255, 0.8)
        );
        border-radius: 4px;
        transition: width 0.5s ease;
        position: relative;
        overflow: hidden;
      }

      .main-badge-progress-fill::after {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(
          90deg,
          transparent,
          rgba(255, 255, 255, 0.3),
          transparent
        );
        animation: shimmer 2s infinite;
      }

      @keyframes shimmer {
        0% {
          transform: translateX(-100%);
        }
        100% {
          transform: translateX(100%);
        }
      }

      .main-badge-progress-text {
        font-size: 0.7rem;
        opacity: 0.9;
        white-space: nowrap;
        text-align: center;
        width: 100%;
        font-weight: 500;
        letter-spacing: 0.02em;
        flex-shrink: 0;
        line-height: 1.3;
      }

      /* Progress Container für bessere Ausrichtung */
      .main-badge-progress-container {
        width: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.35rem;
        flex: 1;
        justify-content: center;
        min-height: 0;
      }

      /* Haupt-Badge Farben */
      .main-badge.badge-voyer {
        border-color: #ec4899;
        color: #f9a8d4;
        background: linear-gradient(
          135deg,
          rgba(236, 72, 153, 0.2),
          rgba(219, 39, 119, 0.1)
        );
      }

      .main-badge.badge-operator {
        border-color: #60a5fa;
        color: #93c5fd;
        background: linear-gradient(
          135deg,
          rgba(96, 165, 250, 0.2),
          rgba(59, 130, 246, 0.1)
        );
      }

      .main-badge.badge-connoisseur {
        border-color: #34d399;
        color: #6ee7b7;
        background: linear-gradient(
          135deg,
          rgba(52, 211, 153, 0.2),
          rgba(16, 185, 129, 0.1)
        );
      }

      .main-badge.badge-navigator {
        border-color: #a78bfa;
        color: #c4b5fd;
        background: linear-gradient(
          135deg,
          rgba(167, 139, 250, 0.2),
          rgba(124, 58, 237, 0.1)
        );
      }

      .main-badge.badge-morelinux {
        border-color: #fbbf24;
        color: #fde68a;
        background: linear-gradient(
          135deg,
          rgba(251, 191, 36, 0.2),
          rgba(245, 158, 11, 0.1)
        );
      }

      /* Unter-Badge Stil (nur visuell, nicht anklickbar) */
      .sub-badge {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        padding: 0.4rem 0.7rem;
        border-radius: 999px;
        font-size: 0.75rem;
        font-weight: 500;
        border: 1px solid;
        background: rgba(255, 255, 255, 0.05);
        opacity: 0.6;
        pointer-events: none;
        cursor: default;
      }

      /* Legacy Badge-Segmente (für Kompatibilität) */
      .badge-segment {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        padding: 0.5rem 0.8rem;
        border-radius: 999px;
        font-size: 0.8rem;
        font-weight: 600;
        border: 2px solid;
        background: linear-gradient(
          135deg,
          rgba(255, 255, 255, 0.1),
          rgba(255, 255, 255, 0.05)
        );
        backdrop-filter: blur(8px);
        transition: all 0.3s ease;
        cursor: pointer;
        position: relative;
        overflow: hidden;
      }
      .badge-segment {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        padding: 0.5rem 0.8rem;
        border-radius: 999px;
        font-size: 0.8rem;
        font-weight: 600;
        border: 2px solid;
        background: linear-gradient(
          135deg,
          rgba(255, 255, 255, 0.1),
          rgba(255, 255, 255, 0.05)
        );
        backdrop-filter: blur(8px);
        transition: all 0.3s ease;
        cursor: pointer;
        position: relative;
        overflow: hidden;
      }
      .badge-segment.locked {
        opacity: 0.4;
        filter: grayscale(0.8);
        cursor: not-allowed;
      }
      .badge-segment.ready {
        /* Pulsierende Animation entfernt */
        cursor: pointer;
        opacity: 0.7;
        filter: saturate(0.7);
        transition: all 0.3s ease;
      }

      .badge-segment.ready:hover {
        opacity: 1;
        filter: saturate(1);
        transform: translateY(-2px);
      }
      /* Sättigungsstufen für Fortschritt */
      .badge-segment.progress-0 {
        filter: grayscale(1) saturate(0);
        opacity: 0.4;
      }
      .badge-segment.progress-25 {
        filter: grayscale(0.75) saturate(0.25);
        opacity: 0.6;
      }
      .badge-segment.progress-50 {
        filter: grayscale(0.5) saturate(0.5);
        opacity: 0.8;
      }
      .badge-segment.progress-75 {
        filter: grayscale(0.25) saturate(0.75);
        opacity: 0.9;
      }
      .badge-segment.progress-100 {
        filter: grayscale(0) saturate(1);
        opacity: 1;
      }

      .badge-segment.unlocked {
        opacity: 1;
        filter: none;
        cursor: default;
      }
      .badge-segment.active {
        box-shadow: 0 0 25px rgba(59, 130, 246, 0.6),
          0 4px 12px rgba(0, 0, 0, 0.3);
        transform: scale(1.05);
        border-width: 3px;
      }
      .badge-segment.segment-1 {
        border-color: #a78bfa;
        color: #c4b5fd;
        background: linear-gradient(
          135deg,
          rgba(167, 139, 250, 0.2),
          rgba(124, 58, 237, 0.1)
        );
      }
      .badge-segment.segment-2 {
        border-color: #60a5fa;
        color: #93c5fd;
        background: linear-gradient(
          135deg,
          rgba(96, 165, 250, 0.2),
          rgba(59, 130, 246, 0.1)
        );
      }
      .badge-segment.segment-3 {
        border-color: #34d399;
        color: #6ee7b7;
        background: linear-gradient(
          135deg,
          rgba(52, 211, 153, 0.2),
          rgba(16, 185, 129, 0.1)
        );
      }
      .badge-segment.segment-4 {
        border-color: #f59e0b;
        color: #fcd34d;
        background: linear-gradient(
          135deg,
          rgba(245, 158, 11, 0.2),
          rgba(217, 119, 6, 0.1)
        );
      }
      .badge-segment.segment-5 {
        border-color: #ec4899;
        color: #f9a8d4;
        background: linear-gradient(
          135deg,
          rgba(236, 72, 153, 0.2),
          rgba(219, 39, 119, 0.1)
        );
      }
      .badge-segment.segment-6 {
        border-color: #fbbf24;
        color: #fde68a;
        background: linear-gradient(
          135deg,
          rgba(251, 191, 36, 0.2),
          rgba(245, 158, 11, 0.1)
        );
      }
      .badge-segment.ready {
        box-shadow: 0 0 20px rgba(59, 130, 246, 0.5),
          0 4px 12px rgba(0, 0, 0, 0.3);
      }
      .badge-segment.unlocked {
        box-shadow: 0 0 25px rgba(34, 197, 94, 0.4),
          0 4px 12px rgba(0, 0, 0, 0.3);
      }
      @keyframes badgePulse {
        0%,
        100% {
          transform: scale(1);
          box-shadow: 0 0 20px rgba(59, 130, 246, 0.5),
            0 4px 12px rgba(0, 0, 0, 0.3);
        }
        50% {
          transform: scale(1.05);
          box-shadow: 0 0 30px rgba(59, 130, 246, 0.8),
            0 6px 16px rgba(0, 0, 0, 0.4);
        }
      }
      .badge-segment-icon {
        font-size: 1.1rem;
      }
      .badge-segment-progress {
        font-size: 0.7rem;
        opacity: 0.8;
      }

      /* Mini-Badges auf Karten */
      .badge-mini {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        font-size: 0.7rem;
        border: 2px solid;
        background: rgba(255, 255, 255, 0.1);
        flex-shrink: 0;
      }
      .badge-mini.segment-1 {
        border-color: #a78bfa;
        color: #c4b5fd;
      }
      .badge-mini.segment-2 {
        border-color: #60a5fa;
        color: #93c5fd;
      }
      .badge-mini.segment-3 {
        border-color: #34d399;
        color: #6ee7b7;
      }
      .badge-mini.segment-4 {
        border-color: #f59e0b;
        color: #fcd34d;
      }
      .badge-mini.segment-5 {
        border-color: #ec4899;
        color: #f9a8d4;
      }
      .badge-mini.segment-6 {
        border-color: #fbbf24;
        color: #fde68a;
      }

      /* Hotkeys-Kachel */
      .hotkeys-card {
        border: 2px solid #fbbf24;
        background: radial-gradient(
            circle at top left,
            rgba(251, 191, 36, 0.2),
            transparent 55%
          ),
          radial-gradient(
            circle at bottom right,
            rgba(245, 158, 11, 0.15),
            transparent 55%
          ),
          #020617;
        box-shadow: 0 0 20px rgba(251, 191, 36, 0.3);
      }
      .hotkeys-card:hover {
        border-color: #fcd34d;
        box-shadow: 0 0 30px rgba(251, 191, 36, 0.5);
        transform: translateY(-2px);
      }

      /* Kali-Tools-Kachel */
      .kali-tools-card {
        border: 2px solid #ef4444;
        background: radial-gradient(
            circle at top left,
            rgba(239, 68, 68, 0.2),
            transparent 55%
          ),
          radial-gradient(
            circle at bottom right,
            rgba(220, 38, 38, 0.15),
            transparent 55%
          ),
          #020617;
        box-shadow: 0 0 20px rgba(239, 68, 68, 0.3);
      }
      .kali-tools-card:hover {
        border-color: #f87171;
        box-shadow: 0 0 30px rgba(239, 68, 68, 0.5);
        transform: translateY(-2px);
      }

      /* Masterquiz-Modal */
      .master-quiz-modal {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 60;
      }
      .master-quiz-modal.hidden {
        display: none;
      }
      .master-quiz-modal-inner {
        position: relative;
        z-index: 61;
        width: min(600px, 100% - 2rem);
        background: #020617;
        border-radius: 1rem;
        border: 1px solid #1f2937;
        box-shadow: 0 22px 60px rgba(0, 0, 0, 0.7);
        padding: 1.2rem 1.5rem 1.3rem;
        max-height: 85vh;
        overflow-y: auto;
      }
      .master-quiz-scenario {
        padding: 0.8rem;
        border-radius: 0.7rem;
        border: 1px solid #374151;
        background: rgba(59, 130, 246, 0.1);
        margin-bottom: 1rem;
        font-size: 0.9rem;
        line-height: 1.6;
      }

      /* Celebration Animation für erfolgreiche Quiz-Abschlüsse */
      .quiz-modal.celebration,
      .master-quiz-modal.celebration {
        animation: celebrationBreakout 1.2s ease-out forwards;
      }

      @keyframes celebrationBreakout {
        0% {
          transform: scale(1);
          opacity: 1;
        }
        30% {
          transform: scale(1.05);
        }
        100% {
          transform: scale(0.8);
          opacity: 0;
        }
      }

      .celebration-particle {
        position: fixed;
        width: 8px;
        height: 8px;
        background: radial-gradient(circle, #fbbf24, #f59e0b);
        border-radius: 50%;
        pointer-events: none;
        z-index: 1000;
        animation: particleFloat 1.5s ease-out forwards;
      }

      @keyframes particleFloat {
        0% {
          opacity: 1;
          transform: translate(0, 0) scale(1);
        }
        100% {
          opacity: 0;
          transform: translate(var(--tx), var(--ty)) scale(0);
        }
      }

      /* Fehler-Feedback: Roter Flash + Shake */
      .quiz-modal.error-feedback,
      .master-quiz-modal.error-feedback {
        animation: errorShake 0.5s ease-in-out;
      }

      @keyframes errorShake {
        0%,
        100% {
          transform: translateX(0);
        }
        10%,
        30%,
        50%,
        70%,
        90% {
          transform: translateX(-5px);
        }
        20%,
        40%,
        60%,
        80% {
          transform: translateX(5px);
        }
      }

      .quiz-modal-inner.error-flash,
      .master-quiz-modal-inner.error-flash {
        animation: errorFlash 0.4s ease-out;
      }

      @keyframes errorFlash {
        0% {
          box-shadow: 0 22px 60px rgba(0, 0, 0, 0.7);
        }
        50% {
          box-shadow: 0 22px 60px rgba(239, 68, 68, 0.6),
            0 0 40px rgba(239, 68, 68, 0.4);
          border-color: #ef4444;
        }
        100% {
          box-shadow: 0 22px 60px rgba(0, 0, 0, 0.7);
        }
      }

      /* Hotkeys-Modal */
      .hotkeys-modal {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 60;
      }
      .hotkeys-modal.hidden {
        display: none;
      }
      .hotkeys-modal-inner {
        position: relative;
        z-index: 61;
        width: min(700px, 100% - 2rem);
        background: #020617;
        border-radius: 1rem;
        border: 1px solid #1f2937;
        box-shadow: 0 22px 60px rgba(0, 0, 0, 0.7);
        padding: 1.2rem 1.5rem 1.3rem;
        max-height: 85vh;
        overflow-y: auto;
      }
      .hotkeys-section {
        margin-bottom: 1.5rem;
      }
      .hotkeys-section-title {
        font-size: 1.1rem;
        font-weight: 600;
        color: #fbbf24;
        margin-bottom: 0.5rem;
        padding-bottom: 0.3rem;
        border-bottom: 2px solid rgba(251, 191, 36, 0.3);
      }
      .hotkeys-item {
        padding: 0.4rem 0.6rem;
        margin-bottom: 0.3rem;
        border-radius: 0.5rem;
        background: rgba(255, 255, 255, 0.03);
        border-left: 3px solid #fbbf24;
      }
      .hotkeys-shortcut {
        font-family: "JetBrains Mono", ui-monospace, monospace;
        color: #93c5fd;
        font-weight: 600;
      }
      .hotkeys-description {
        color: #d1d5db;
        margin-left: 0.5rem;
      }

      /* Kali-Tools-Modal */
      .kali-tools-modal {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 60;
      }
      .kali-tools-modal.hidden {
        display: none;
      }
      .kali-tools-modal-inner {
        position: relative;
        z-index: 61;
        width: min(700px, 100% - 2rem);
        background: #020617;
        border-radius: 1rem;
        border: 1px solid #1f2937;
        box-shadow: 0 22px 60px rgba(0, 0, 0, 0.7);
        padding: 1.2rem 1.5rem 1.3rem;
        max-height: 85vh;
        overflow-y: auto;
      }
      .kali-tools-section {
        margin-bottom: 1.5rem;
      }
      .kali-tools-section-title {
        font-size: 1.1rem;
        font-weight: 600;
        color: #ef4444;
        margin-bottom: 0.5rem;
        padding-bottom: 0.3rem;
        border-bottom: 2px solid rgba(239, 68, 68, 0.3);
      }
      .kali-tools-item {
        padding: 0.6rem 0.8rem;
        margin-bottom: 0.5rem;
        border-radius: 0.5rem;
        background: rgba(255, 255, 255, 0.03);
        border-left: 3px solid #ef4444;
      }
      .kali-tools-name {
        font-family: "JetBrains Mono", ui-monospace, monospace;
        color: #93c5fd;
        font-weight: 600;
        display: block;
        margin-bottom: 0.3rem;
      }
      .kali-tools-description {
        color: #d1d5db;
        font-size: 0.95rem;
        line-height: 1.5;
        margin-bottom: 0.3rem;
      }
      .kali-tools-benefit {
        color: #a78bfa;
        font-size: 0.9rem;
        font-style: italic;
        margin-top: 0.3rem;
      }
      .kali-tools-command {
        font-family: "JetBrains Mono", ui-monospace, monospace;
        color: #34d399;
        font-size: 0.85rem;
        background: rgba(52, 211, 153, 0.1);
        padding: 0.2rem 0.4rem;
        border-radius: 0.3rem;
        display: inline-block;
        margin-top: 0.3rem;
      }
      .kali-tools-example {
        margin-top: 0.5rem;
        padding: 0.6rem;
        border-radius: 0.5rem;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(239, 68, 68, 0.2);
        position: relative;
      }
      .kali-tools-example-title {
        font-size: 0.85rem;
        font-weight: 600;
        color: #ef4444;
        margin-bottom: 0.4rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }
      .kali-tools-example-content {
        color: #d1d5db;
        font-size: 0.9rem;
        line-height: 1.6;
      }
      .kali-tools-example-blurred {
        filter: blur(5px);
        user-select: none;
        pointer-events: none;
        position: relative;
        overflow: hidden;
      }
      .kali-tools-example-blurred::after {
        content: "";
        position: absolute;
        inset: 0;
        background: rgba(15, 23, 42, 0.7);
        backdrop-filter: blur(2px);
      }
      .kali-tools-chicken-btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 0.3rem 0.6rem;
        margin-left: 0.5rem;
        background: rgba(239, 68, 68, 0.2);
        border: 1px solid rgba(239, 68, 68, 0.4);
        border-radius: 0.4rem;
        color: #fca5a5;
        font-size: 1.1rem;
        cursor: pointer;
        transition: all 0.2s ease;
        font-family: inherit;
      }
      .kali-tools-chicken-btn:hover {
        background: rgba(239, 68, 68, 0.3);
        border-color: rgba(239, 68, 68, 0.6);
        transform: scale(1.05);
      }
      .kali-tools-chicken-btn:active {
        transform: scale(0.95);
      }
      .kali-tools-overlay {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 70;
      }
      .kali-tools-overlay.hidden {
        display: none;
      }
      .kali-tools-overlay-inner {
        position: relative;
        z-index: 71;
        width: min(600px, 100% - 2rem);
        max-height: 80vh;
        background: #020617;
        border-radius: 1rem;
        border: 1px solid #1f2937;
        box-shadow: 0 22px 60px rgba(0, 0, 0, 0.7);
        padding: 1.5rem;
        overflow-y: auto;
      }
      .kali-tools-overlay-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1rem;
        padding-bottom: 0.8rem;
        border-bottom: 2px solid rgba(239, 68, 68, 0.3);
      }
      .kali-tools-overlay-title {
        font-size: 1.2rem;
        font-weight: 600;
        color: #ef4444;
      }
      .kali-tools-overlay-close {
        background: transparent;
        border: 1px solid rgba(239, 68, 68, 0.3);
        color: #fca5a5;
        padding: 0.3rem 0.6rem;
        border-radius: 0.4rem;
        cursor: pointer;
        font-size: 0.9rem;
        transition: all 0.2s ease;
      }
      .kali-tools-overlay-close:hover {
        background: rgba(239, 68, 68, 0.2);
        border-color: rgba(239, 68, 68, 0.5);
      }
      .kali-tools-overlay-content {
        color: #d1d5db;
        font-size: 0.95rem;
        line-height: 1.7;
      }
      .kali-tools-overlay-content .kali-tools-name {
        margin-bottom: 0.5rem;
      }
      .kali-tools-overlay-content .kali-tools-command {
        margin-top: 0.5rem;
        display: block;
      }

      /* Kali-Tools Badge Container */
      .kali-tools-badges-container {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        margin-top: 0.8rem;
        padding-top: 0.8rem;
        border-top: 1px solid rgba(239, 68, 68, 0.2);
      }
      .kali-tools-badge {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        padding: 0.4rem 0.7rem;
        border-radius: 0.5rem;
        font-size: 0.85rem;
        border: 1px solid;
        transition: all 0.2s ease;
        cursor: pointer;
      }
      .kali-tools-badge.locked {
        background: rgba(239, 68, 68, 0.1);
        border-color: rgba(239, 68, 68, 0.3);
        color: #fca5a5;
        opacity: 0.6;
      }
      .kali-tools-badge.unlocked {
        background: rgba(34, 197, 94, 0.15);
        border-color: rgba(34, 197, 94, 0.4);
        color: #86efac;
        opacity: 1;
      }
      .kali-tools-badge:hover {
        transform: scale(1.05);
        opacity: 1;
      }
      .kali-tools-badge-icon {
        font-size: 1rem;
      }
      .kali-tools-badge-name {
        font-weight: 500;
      }
      .kali-tools-badge-progress {
        font-size: 0.75rem;
        opacity: 0.8;
        margin-left: 0.2rem;
      }

      /* Desktop Layout - 16:9 Optimiert */
      main {
        max-width: 100%;
        margin: 0 auto;
        padding: 1rem 2rem 2rem;
        width: 100%;
      }

      .commands-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
        gap: 0.8rem;
        width: 100%;
      }

      /* Header für Desktop optimiert */
      header {
        padding: 1rem 2rem 0.75rem;
      }

      .header-inner {
        max-width: 100%;
      }
      .command-card {
        border-radius: 0.9rem;
        border: 1px solid #1f2937;
        background: radial-gradient(
            circle at top left,
            rgba(56, 189, 248, 0.12),
            transparent 55%
          ),
          radial-gradient(
            circle at bottom right,
            rgba(129, 140, 248, 0.12),
            transparent 55%
          ),
          #020617;
        padding: 0.9rem 1rem;
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        cursor: pointer;
        transition: transform 0.08s ease-out, box-shadow 0.08s ease-out,
          border-color 0.08s ease-out;
      }
      .command-card:hover {
        transform: translateY(-1px);
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.6);
        border-color: #3b82f6;
      }
      .command-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 0.5rem;
        margin-bottom: 0.15rem;
      }
      .command-name {
        margin: 0;
        font-size: 0.95rem;
        font-weight: 600;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .command-name code {
        background: #020617;
        padding: 0.1rem 0.35rem;
        border-radius: 999px;
        border: 1px solid #1f2937;
        font-size: 0.85rem;
      }
      .command-tag {
        font-size: 0.7rem;
        color: #9ca3af;
      }
      .command-body {
        font-size: 0.85rem;
        color: #d1d5db;
      }
      .command-body p {
        margin: 0.1rem 0;
      }
      code {
        font-family: "JetBrains Mono", "Fira Code", "Source Code Pro",
          "Cascadia Code", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
        font-size: 0.85em;
        font-feature-settings: "zero", "onum";
        font-variant-numeric: tabular-nums;
        letter-spacing: 0.01em;
      }

      /* Quiz modal */
      .quiz-backdrop {
        position: fixed;
        inset: 0;
        background: rgba(15, 23, 42, 0.7);
        backdrop-filter: blur(6px);
        z-index: 40;
      }
      .quiz-modal {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 50;
      }
      .quiz-modal.hidden {
        display: none;
      }
      .quiz-modal-inner {
        position: relative;
        z-index: 51;
        width: min(520px, 100% - 2rem);
        background: #020617;
        border-radius: 1rem;
        border: 1px solid #1f2937;
        box-shadow: 0 22px 60px rgba(0, 0, 0, 0.7);
        padding: 1rem 1.2rem 1.1rem;
        transform: translateZ(0);
        isolation: isolate;
      }
      .quiz-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 0.5rem;
        margin-bottom: 0.5rem;
      }
      .quiz-title {
        font-size: 1rem;
        font-weight: 600;
      }
      .quiz-level-pill {
        font-size: 0.7rem;
        padding: 0.12rem 0.6rem;
        border-radius: 999px;
        border: 1px solid #374151;
        color: #9ca3af;
      }
      .quiz-close-btn {
        border: none;
        background: #111827;
        border-radius: 999px;
        padding: 0.2rem 0.6rem;
        font-size: 0.8rem;
        color: #9ca3af;
        cursor: pointer;
      }
      .quiz-body {
        font-size: 0.85rem;
        color: #d1d5db;
        display: flex;
        flex-direction: column;
        gap: 0.7rem;
        margin-bottom: 0.7rem;
        max-height: 60vh;
        overflow-y: auto;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
      }

      /* Verbesserte Schriftart für Erklärungen mit besserer Unterscheidung */
      .quiz-body code,
      .quiz-body .cmd-example,
      .quiz-command-info code,
      .complex-explanation code,
      .quiz-question-title code {
        font-family: "JetBrains Mono", "Fira Code", "Source Code Pro",
          "Cascadia Code", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace !important;
        font-feature-settings: "zero", "onum", "calt" !important;
        font-variant-numeric: tabular-nums !important;
        letter-spacing: 0.02em !important;
        font-weight: 500 !important;
      }
      .quiz-question {
        padding: 0.6rem 0.7rem;
        border-radius: 0.7rem;
        border: 1px solid #1f2937;
        background: #020617;
      }
      .quiz-question-title {
        font-weight: 600;
        margin-bottom: 0.3rem;
      }
      .quiz-question-meta {
        font-size: 0.75rem;
        color: #9ca3af;
        margin-bottom: 0.35rem;
      }
      .quiz-options {
        display: flex;
        flex-direction: column;
        gap: 0.2rem;
      }
      .quiz-option {
        display: flex;
        gap: 0.4rem;
        align-items: flex-start;
        cursor: pointer;
      }
      .quiz-option input {
        margin-top: 0.12rem;
      }
      .quiz-option.highlight-correct {
        background: rgba(34, 197, 94, 0.15);
        border-left: 3px solid #22c55e;
        padding-left: 0.5rem;
        border-radius: 0.25rem;
      }
      .quiz-chicken-btn {
        margin-top: 0.5rem;
        padding: 0.35rem 0.75rem;
        font-size: 0.75rem;
        background: rgba(245, 158, 11, 0.15);
        border: 1px solid rgba(245, 158, 11, 0.3);
        border-radius: 0.4rem;
        color: #fbbf24;
        cursor: pointer;
        transition: all 0.2s ease;
        font-weight: 500;
      }
      .quiz-chicken-btn:hover {
        background: rgba(245, 158, 11, 0.25);
        border-color: rgba(245, 158, 11, 0.5);
        transform: translateY(-1px);
      }
      .quiz-chicken-btn:active {
        transform: translateY(0);
      }
      .quiz-footer {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.8rem;
      }
      .quiz-submit-btn {
        border: none;
        border-radius: 999px;
        padding: 0.45rem 0.9rem;
        background: linear-gradient(135deg, #22c55e, #4ade80);
        color: #022c22;
        font-weight: 600;
        cursor: pointer;
      }
      .quiz-submit-btn:disabled {
        opacity: 0.5;
        cursor: default;
      }
      .quiz-feedback {
        font-size: 0.8rem;
      }
      .command-card.quiz-done {
        border-color: #22c55e;
        box-shadow: 0 0 0 1px rgba(34, 197, 94, 0.6),
          0 14px 30px rgba(22, 163, 74, 0.35);
        position: relative;
      }
      .command-card.quiz-done::after {
        content: "✓ Quiz bestanden";
        position: absolute;
        top: 0.5rem;
        right: 0.7rem;
        font-size: 0.65rem;
        padding: 0.12rem 0.45rem;
        border-radius: 999px;
        background: rgba(22, 163, 74, 0.12);
        border: 1px solid rgba(22, 163, 74, 0.7);
        color: #bbf7d0;
      }
      .command-card.quiz-done.flash-once {
        animation: cardPulse 0.9s ease-out;
      }
      @keyframes cardPulse {
        0% {
          box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.8);
        }
        100% {
          box-shadow: 0 0 0 16px rgba(34, 197, 94, 0);
        }
      }
      /* Category color accents (subtle contour lines) */
      .command-card {
        position: relative;
      }
      .command-card::before {
        content: "";
        position: absolute;
        left: 0;
        top: 0;
        bottom: 0;
        width: 6px;
        border-radius: 0.9rem 0 0 0.9rem;
        pointer-events: none;
        opacity: 0;
        transition: opacity 180ms ease;
      }
      .command-card.category-navigation::before {
        background: linear-gradient(#60a5fa, #3b82f6);
        opacity: 0.95;
      }
      .command-card.category-listing::before {
        background: linear-gradient(#f59e0b, #f97316);
        opacity: 0.95;
      }
      .command-card.category-search::before {
        background: linear-gradient(#a78bfa, #7c3aed);
        opacity: 0.95;
      }
      .command-card.category-pipes::before {
        background: linear-gradient(#34d399, #10b981);
        opacity: 0.95;
      }
      .command-card.category-redirect::before {
        background: linear-gradient(#fb7185, #ef4444);
        opacity: 0.95;
      }
      .command-card.category-workflow::before {
        background: linear-gradient(#60a5fa, #f59e0b);
        opacity: 0.95;
      }
      .command-card.category-files::before {
        background: linear-gradient(#ec4899, #db2777);
        opacity: 0.95;
      }
      .command-card.category-system::before {
        background: linear-gradient(#8b5cf6, #7c3aed);
        opacity: 0.95;
      }
      .command-card.category-permissions::before {
        background: linear-gradient(#f59e0b, #d97706);
        opacity: 0.95;
      }

      /* Slightly lift the border color to match accent (keeps original look but clearer grouping) */
      .command-card.category-navigation {
        border-color: rgba(96, 165, 250, 0.22);
      }
      .command-card.category-listing {
        border-color: rgba(245, 158, 11, 0.18);
      }
      .command-card.category-search {
        border-color: rgba(167, 139, 250, 0.18);
      }
      .command-card.category-pipes {
        border-color: rgba(52, 211, 153, 0.18);
      }
      .command-card.category-redirect {
        border-color: rgba(251, 113, 133, 0.18);
      }
      .command-card.category-workflow {
        border-color: rgba(96, 165, 250, 0.12);
      }
      .command-card.category-files {
        border-color: rgba(236, 72, 153, 0.18);
      }
      .command-card.category-system {
        border-color: rgba(139, 92, 246, 0.18);
      }
      .command-card.category-permissions {
        border-color: rgba(245, 158, 11, 0.18);
      }

      /* Modal: command info and collapsible details */
      .quiz-command-info {
        margin-bottom: 0.6rem;
        padding: 0.6rem;
        border-radius: 0.6rem;
        border: 1px solid #111827;
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.01),
          rgba(255, 255, 255, 0)
        );
        font-size: 0.9rem;
        color: #d1d5db;
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
      }
      .quiz-command-info .cmd-title code {
        font-size: 0.95rem;
        padding: 0.08rem 0.35rem;
        border-radius: 999px;
        border: 1px solid #1f2937;
        background: #020617;
      }
      .quiz-command-info .cmd-example {
        color: #c7d2fe;
        font-family: "JetBrains Mono", "Fira Code", "Source Code Pro",
          ui-monospace, SFMono-Regular, Menlo, Monaco, monospace;
        font-feature-settings: "zero", "onum";
        font-variant-numeric: tabular-nums;
        letter-spacing: 0.01em;
      }
      .quiz-details-toggle {
        background: transparent;
        border: none;
        color: #93c5fd;
        cursor: pointer;
        padding: 0;
        font-size: 0.85rem;
        align-self: flex-start;
      }
      .quiz-details {
        margin-top: 0.4rem;
        padding: 0.5rem;
        border-radius: 0.6rem;
        background: rgba(255, 255, 255, 0.015);
        border: 1px solid #0b1220;
        font-size: 0.85rem;
        color: #cbd5e1;
        display: none;
        white-space: pre-wrap;
      }
      .complex-explanation {
        margin-top: 0.5rem;
        padding: 0.8rem;
        border-radius: 0.6rem;
        background: rgba(59, 130, 246, 0.05);
        border: 1px solid rgba(59, 130, 246, 0.2);
      }
      .complex-explanation > div {
        margin-bottom: 0.8rem;
      }
      .complex-explanation > div:last-child {
        margin-bottom: 0;
      }

      /* Mobile Media Queries */
      @media (max-width: 768px) {
        /* Mobile Layout */
        main {
          padding: 1rem 1rem 2rem;
        }

        header {
          padding: 1rem 1rem 0.75rem;
        }

        .header-inner {
          max-width: 100%;
        }

        /* Badges auf Mobile - Wrap erlauben */
        .main-badges-row {
          flex-wrap: wrap;
          gap: 0.6rem;
        }

        .main-badge {
          flex: 1 1 calc(50% - 0.3rem);
          min-width: 140px;
          max-width: none;
          padding: 0.7rem 0.8rem;
          height: auto;
          min-height: 100px;
        }

        .main-badge-icon {
          font-size: 1rem;
        }

        .main-badge-name {
          font-size: 0.75rem;
        }

        .main-badge-progress-text {
          font-size: 0.65rem;
        }

        /* Kacheln auf Mobile - 1 Spalte */
        .commands-grid {
          grid-template-columns: 1fr;
          gap: 0.7rem;
        }

        .command-card {
          padding: 0.8rem 0.9rem;
        }
      }

      /* Sehr kleine Bildschirme */
      @media (max-width: 480px) {
        .main-badge {
          flex: 1 1 100%;
          min-width: 100%;
        }

        .main-badge-name {
          font-size: 0.7rem;
        }

        .main-badge-progress-text {
          font-size: 0.6rem;
        }
      }

      /* Desktop 16:9 Optimierung */
      @media (min-width: 1400px) {
        main {
          padding: 1rem 3rem 2rem;
        }

        .commands-grid {
          grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
          gap: 0.7rem;
        }

        .command-card {
          padding: 0.8rem 0.9rem;
        }

        .command-name {
          font-size: 0.9rem;
        }

        .command-body {
          font-size: 0.8rem;
        }
      }

      /* Sehr große Bildschirme - Noch mehr Kacheln */
      @media (min-width: 1920px) {
        .commands-grid {
          grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
          gap: 0.6rem;
        }

        .command-card {
          padding: 0.7rem 0.8rem;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <div class="header-inner">
        <h1>Linux CLI Quiz</h1>
        <p class="subtitle">
          Kernbefehle aus dem Cyber-Security-Kurs – jeweils ein
          3‑Fragen‑Mini‑Quiz.
        </p>
        <div class="badges-header" id="badges-header">
          <!-- Badge-Segmente werden hier dynamisch eingefügt -->
        </div>
        <div class="achievements-container" id="achievements-container">
          <!-- Legacy Achievements - wird beibehalten für Kompatibilität -->
        </div>
        <div class="achievement-progress" id="achievement-progress">
          Fortschritt: 0/60 Fragen richtig beantwortet
        </div>
        <div class="search-container">
          <input
            type="text"
            id="search-input"
            class="search-input"
            placeholder="Befehle durchsuchen (z.B. 'ls', 'grep', 'find'...)"
            autocomplete="off"
          />
        </div>
      </div>
    </header>
    <main>
      <section class="commands-grid" id="commands-grid">
        <article class="command-card" data-command="pwd" data-quiz-id="pwd">
          <div class="command-header">
            <h2 class="command-name"><code>pwd</code></h2>
            <span class="command-tag">Navigation</span>
          </div>
          <div class="command-body">
            <p>Zeigt das aktuelle Arbeitsverzeichnis (Pfad) an.</p>
          </div>
        </article>

        <article class="command-card" data-command="cd" data-quiz-id="cd">
          <div class="command-header">
            <h2 class="command-name"><code>cd</code></h2>
            <span class="command-tag">Navigation</span>
          </div>
          <div class="command-body">
            <p>Wechselt in ein anderes Verzeichnis.</p>
          </div>
        </article>

        <article
          class="command-card"
          data-command="cd .."
          data-quiz-id="cd_parent"
        >
          <div class="command-header">
            <h2 class="command-name"><code>cd ..</code></h2>
            <span class="command-tag">Navigation</span>
          </div>
          <div class="command-body">
            <p>Springt eine Ebene in das übergeordnete Verzeichnis.</p>
          </div>
        </article>

        <article class="command-card" data-command="ls" data-quiz-id="ls">
          <div class="command-header">
            <h2 class="command-name"><code>ls</code></h2>
            <span class="command-tag">Auflisten</span>
          </div>
          <div class="command-body">
            <p>Listet Dateien und Ordner im aktuellen Verzeichnis.</p>
          </div>
        </article>

        <article class="command-card" data-command="grep" data-quiz-id="grep">
          <div class="command-header">
            <h2 class="command-name"><code>grep</code></h2>
            <span class="command-tag">Suche</span>
          </div>
          <div class="command-body">
            <p>Durchsucht Text nach Mustern.</p>
          </div>
        </article>

        <article class="command-card" data-command="pipe" data-quiz-id="pipe">
          <div class="command-header">
            <h2 class="command-name"><code>|</code> (Pipe)</h2>
            <span class="command-tag">Pipes</span>
          </div>
          <div class="command-body">
            <p>Verkettet Befehle: Ausgabe → Eingabe.</p>
          </div>
        </article>

        <article
          class="command-card"
          data-command="redirect"
          data-quiz-id="redirect"
        >
          <div class="command-header">
            <h2 class="command-name">
              <code>&gt;</code>, <code>&gt;&gt;</code>, <code>2&gt;</code>
            </h2>
            <span class="command-tag">Umleitung</span>
          </div>
          <div class="command-body">
            <p>Leitet Ausgaben und Fehler in Dateien um.</p>
          </div>
        </article>

        <article
          class="command-card"
          data-command="nano_flow"
          data-quiz-id="nano_flow"
        >
          <div class="command-header">
            <h2 class="command-name">
              <code>nano</code> + <code>chmod +x</code> +
              <code>./script.sh</code>
            </h2>
            <span class="command-tag">Workflow</span>
          </div>
          <div class="command-body">
            <p>
              Ein kompletter Mini‑Workflow zum Schreiben und Ausführen eines
              Scripts.
            </p>
          </div>
        </article>

        <article class="command-card" data-command="ls -a" data-quiz-id="ls_a">
          <div class="command-header">
            <h2 class="command-name"><code>ls -a</code></h2>
            <span class="command-tag">Auflisten</span>
          </div>
          <div class="command-body">
            <p>Listet alle Dateien, inklusive versteckter (beginnen mit .).</p>
          </div>
        </article>

        <article
          class="command-card"
          data-command="ls -la"
          data-quiz-id="ls_la"
        >
          <div class="command-header">
            <h2 class="command-name"><code>ls -la</code></h2>
            <span class="command-tag">Auflisten</span>
          </div>
          <div class="command-body">
            <p>
              Detaillierte Liste aller Dateien mit Rechten, Besitzer, Größe usw.
            </p>
          </div>
        </article>

        <article class="command-card" data-command="mkdir" data-quiz-id="mkdir">
          <div class="command-header">
            <h2 class="command-name"><code>mkdir</code></h2>
            <span class="command-tag">Dateien</span>
          </div>
          <div class="command-body">
            <p>Erstellt einen neuen Ordner.</p>
          </div>
        </article>

        <article
          class="command-card"
          data-command="mkdir -p"
          data-quiz-id="mkdir_p"
        >
          <div class="command-header">
            <h2 class="command-name"><code>mkdir -p</code></h2>
            <span class="command-tag">Dateien</span>
          </div>
          <div class="command-body">
            <p>Erstellt einen Ordner inkl. aller fehlenden Zwischenordner.</p>
          </div>
        </article>

        <article class="command-card" data-command="mv" data-quiz-id="mv">
          <div class="command-header">
            <h2 class="command-name"><code>mv</code></h2>
            <span class="command-tag">Dateien</span>
          </div>
          <div class="command-body">
            <p>Verschiebt Dateien/Ordner oder benennt sie um.</p>
          </div>
        </article>

        <article class="command-card" data-command="cp" data-quiz-id="cp">
          <div class="command-header">
            <h2 class="command-name"><code>cp</code></h2>
            <span class="command-tag">Dateien</span>
          </div>
          <div class="command-body">
            <p>Kopiert Dateien.</p>
          </div>
        </article>

        <article class="command-card" data-command="cp -r" data-quiz-id="cp_r">
          <div class="command-header">
            <h2 class="command-name"><code>cp -r</code></h2>
            <span class="command-tag">Dateien</span>
          </div>
          <div class="command-body">
            <p>Kopiert einen Ordner rekursiv mit Inhalt.</p>
          </div>
        </article>

        <article class="command-card" data-command="rm" data-quiz-id="rm">
          <div class="command-header">
            <h2 class="command-name"><code>rm</code></h2>
            <span class="command-tag">Dateien</span>
          </div>
          <div class="command-body">
            <p>Löscht Dateien.</p>
          </div>
        </article>

        <article class="command-card" data-command="rm -r" data-quiz-id="rm_r">
          <div class="command-header">
            <h2 class="command-name"><code>rm -r</code></h2>
            <span class="command-tag">Dateien</span>
          </div>
          <div class="command-body">
            <p>Löscht Ordner rekursiv inkl. aller Inhalte.</p>
          </div>
        </article>

        <article class="command-card" data-command="cat" data-quiz-id="cat">
          <div class="command-header">
            <h2 class="command-name"><code>cat</code></h2>
            <span class="command-tag">Dateien</span>
          </div>
          <div class="command-body">
            <p>Gibt den Inhalt einer Datei auf stdout aus.</p>
          </div>
        </article>

        <article class="command-card" data-command="sort" data-quiz-id="sort">
          <div class="command-header">
            <h2 class="command-name"><code>sort</code></h2>
            <span class="command-tag">Pipes</span>
          </div>
          <div class="command-body">
            <p>Sortiert Zeilen alphabetisch.</p>
          </div>
        </article>

        <article
          class="command-card"
          data-command="sort -n"
          data-quiz-id="sort_n"
        >
          <div class="command-header">
            <h2 class="command-name"><code>sort -n</code></h2>
            <span class="command-tag">Pipes</span>
          </div>
          <div class="command-body">
            <p>Sortiert Zeilen numerisch (Zahlen korrekt, nicht als Text).</p>
          </div>
        </article>

        <article class="command-card" data-command="uniq" data-quiz-id="uniq">
          <div class="command-header">
            <h2 class="command-name"><code>uniq</code></h2>
            <span class="command-tag">Pipes</span>
          </div>
          <div class="command-body">
            <p>Entfernt doppelte aufeinanderfolgende Zeilen.</p>
          </div>
        </article>

        <article
          class="command-card"
          data-command="find . -name"
          data-quiz-id="find_name"
        >
          <div class="command-header">
            <h2 class="command-name"><code>find . -name "Muster"</code></h2>
            <span class="command-tag">Suche</span>
          </div>
          <div class="command-body">
            <p>
              Sucht rekursiv nach Dateien/Ordnern mit Namen, der zum Muster
              passt.
            </p>
          </div>
        </article>

        <article
          class="command-card"
          data-command="find . -maxdepth 1 -type d"
          data-quiz-id="find_maxdepth"
        >
          <div class="command-header">
            <h2 class="command-name">
              <code>find . -maxdepth 1 -type d</code>
            </h2>
            <span class="command-tag">Suche</span>
          </div>
          <div class="command-body">
            <p>
              Listet nur Ordner im aktuellen Verzeichnis (keine Unterordner).
            </p>
          </div>
        </article>

        <article class="command-card" data-command="ls -R" data-quiz-id="ls_R">
          <div class="command-header">
            <h2 class="command-name"><code>ls -R</code></h2>
            <span class="command-tag">Auflisten</span>
          </div>
          <div class="command-body">
            <p>
              Listet den gesamten Verzeichnisbaum rekursiv (alle Ordner und
              Dateien darunter).
            </p>
          </div>
        </article>

        <article
          class="command-card"
          data-command="ls -aR"
          data-quiz-id="ls_aR"
        >
          <div class="command-header">
            <h2 class="command-name"><code>ls -aR</code></h2>
            <span class="command-tag">Auflisten</span>
          </div>
          <div class="command-body">
            <p>
              Rekursives Auflisten aller Dateien UND versteckter Dateien/Ordner.
            </p>
          </div>
        </article>

        <article class="command-card" data-command="tree" data-quiz-id="tree">
          <div class="command-header">
            <h2 class="command-name"><code>tree</code></h2>
            <span class="command-tag">Auflisten</span>
          </div>
          <div class="command-body">
            <p>Zeigt Verzeichnisstruktur in Baumform.</p>
          </div>
        </article>

        <article
          class="command-card"
          data-command="tree -d"
          data-quiz-id="tree_d"
        >
          <div class="command-header">
            <h2 class="command-name"><code>tree -d</code></h2>
            <span class="command-tag">Auflisten</span>
          </div>
          <div class="command-body">
            <p>Zeigt nur Ordner (directory-only mode).</p>
          </div>
        </article>

        <article
          class="command-card"
          data-command="tree -L"
          data-quiz-id="tree_L"
        >
          <div class="command-header">
            <h2 class="command-name"><code>tree -L</code></h2>
            <span class="command-tag">Auflisten</span>
          </div>
          <div class="command-body">
            <p>Begrenzt die Tiefe der rekursiven Baumdarstellung.</p>
          </div>
        </article>

        <article class="command-card" data-command="echo" data-quiz-id="echo">
          <div class="command-header">
            <h2 class="command-name"><code>echo</code></h2>
            <span class="command-tag">Pipes</span>
          </div>
          <div class="command-body">
            <p>Gibt Text im Terminal aus.</p>
          </div>
        </article>

        <article
          class="command-card"
          data-command=">"
          data-quiz-id="redirect_overwrite"
        >
          <div class="command-header">
            <h2 class="command-name"><code>&gt;</code></h2>
            <span class="command-tag">Umleitung</span>
          </div>
          <div class="command-body">
            <p>Leitet die Ausgabe in eine Datei um (überschreibt).</p>
          </div>
        </article>

        <article
          class="command-card"
          data-command=">>"
          data-quiz-id="redirect_append"
        >
          <div class="command-header">
            <h2 class="command-name"><code>&gt;&gt;</code></h2>
            <span class="command-tag">Umleitung</span>
          </div>
          <div class="command-body">
            <p>Hängt die Ausgabe ans Ende einer Datei an.</p>
          </div>
        </article>

        <article
          class="command-card"
          data-command="2>"
          data-quiz-id="redirect_stderr"
        >
          <div class="command-header">
            <h2 class="command-name"><code>2&gt;</code></h2>
            <span class="command-tag">Umleitung</span>
          </div>
          <div class="command-body">
            <p>Leitet die Fehlerausgabe (stderr) in eine Datei.</p>
          </div>
        </article>

        <article
          class="command-card"
          data-command="whoami"
          data-quiz-id="whoami"
        >
          <div class="command-header">
            <h2 class="command-name"><code>whoami</code></h2>
            <span class="command-tag">System</span>
          </div>
          <div class="command-body">
            <p>Zeigt den aktuellen Benutzer.</p>
          </div>
        </article>

        <article class="command-card" data-command="chmod" data-quiz-id="chmod">
          <div class="command-header">
            <h2 class="command-name"><code>chmod</code></h2>
            <span class="command-tag">Rechte</span>
          </div>
          <div class="command-body">
            <p>Ändert Dateirechte (read/write/execute).</p>
          </div>
        </article>

        <article
          class="command-card"
          data-command="chmod -R"
          data-quiz-id="chmod_R"
        >
          <div class="command-header">
            <h2 class="command-name"><code>chmod -R</code></h2>
            <span class="command-tag">Rechte</span>
          </div>
          <div class="command-body">
            <p>Ändert Rechte rekursiv für Ordner + Unterordner.</p>
          </div>
        </article>

        <article class="command-card" data-command="chown" data-quiz-id="chown">
          <div class="command-header">
            <h2 class="command-name"><code>chown</code></h2>
            <span class="command-tag">Rechte</span>
          </div>
          <div class="command-body">
            <p>Ändert den Besitzer einer Datei.</p>
          </div>
        </article>

        <article class="command-card" data-command="chgrp" data-quiz-id="chgrp">
          <div class="command-header">
            <h2 class="command-name"><code>chgrp</code></h2>
            <span class="command-tag">Rechte</span>
          </div>
          <div class="command-body">
            <p>Ändert nur die Gruppenzugehörigkeit einer Datei.</p>
          </div>
        </article>

        <article class="command-card" data-command="touch" data-quiz-id="touch">
          <div class="command-header">
            <h2 class="command-name"><code>touch</code></h2>
            <span class="command-tag">Dateien</span>
          </div>
          <div class="command-body">
            <p>
              Erstellt eine leere Datei oder aktualisiert das Änderungsdatum.
            </p>
          </div>
        </article>

        <article class="command-card" data-command="head" data-quiz-id="head">
          <div class="command-header">
            <h2 class="command-name"><code>head</code></h2>
            <span class="command-tag">Dateien</span>
          </div>
          <div class="command-body">
            <p>Zeigt die ersten Zeilen einer Datei.</p>
          </div>
        </article>

        <article class="command-card" data-command="tail" data-quiz-id="tail">
          <div class="command-header">
            <h2 class="command-name"><code>tail</code></h2>
            <span class="command-tag">Dateien</span>
          </div>
          <div class="command-body">
            <p>Zeigt die letzten Zeilen einer Datei.</p>
          </div>
        </article>

        <article class="command-card" data-command="wc -l" data-quiz-id="wc_l">
          <div class="command-header">
            <h2 class="command-name"><code>wc -l</code></h2>
            <span class="command-tag">Pipes</span>
          </div>
          <div class="command-body">
            <p>Zählt Zeilen in einer Datei oder Eingabe.</p>
          </div>
        </article>

        <article class="command-card" data-command="wc -w" data-quiz-id="wc_w">
          <div class="command-header">
            <h2 class="command-name"><code>wc -w</code></h2>
            <span class="command-tag">Pipes</span>
          </div>
          <div class="command-body">
            <p>Zählt Wörter.</p>
          </div>
        </article>

        <!-- Hotkeys & Quality of Life Kachel -->
        <article class="command-card hotkeys-card" id="hotkeys-card">
          <div class="command-header">
            <h2 class="command-name">⚡ Hotkeys & Quality of Life</h2>
            <span class="command-tag">Wissen</span>
          </div>
          <div class="command-body">
            <p>
              Tastaturkürzel, Terminal-Tools und Workflow-Verbesserungen für
              effizientes Arbeiten in der Kommandozeile.
            </p>
          </div>
        </article>

        <!-- Kali Linux Tools Kachel -->
        <article class="command-card kali-tools-card" id="kali-tools-card">
          <div class="command-header">
            <h2 class="command-name">🔐 Kali Linux Tools</h2>
            <span class="command-tag">Wissen</span>
          </div>
          <div class="command-body">
            <p>
              Übersicht über essentielle Pentesting-Tools und Setup-Schritte für
              Kali Linux – perfekt für Einsteiger.
            </p>
          </div>
        </article>
      </section>
    </main>

    <div id="quiz-root" class="quiz-modal hidden" aria-hidden="true">
      <div class="quiz-backdrop"></div>
      <div class="quiz-modal-inner">
        <div class="quiz-header">
          <div>
            <div class="quiz-title" id="quiz-title">Quiz</div>
            <div class="quiz-level-pill" id="quiz-subtitle">
              3 Fragen: leicht · mittel · schwer
            </div>
          </div>
          <button class="quiz-close-btn" type="button" id="quiz-close-btn">
            ESC
          </button>
        </div>

        <div class="quiz-body" id="quiz-body"></div>

        <div class="quiz-footer">
          <div class="quiz-feedback" id="quiz-feedback"></div>
          <button class="quiz-submit-btn" type="button" id="quiz-submit-btn">
            Quiz auswerten
          </button>
        </div>
      </div>
    </div>

    <!-- Masterquiz-Modal -->
    <div
      id="master-quiz-root"
      class="master-quiz-modal hidden"
      aria-hidden="true"
    >
      <div class="quiz-backdrop"></div>
      <div class="master-quiz-modal-inner">
        <div class="quiz-header">
          <div>
            <div class="quiz-title" id="master-quiz-title">Masterquiz</div>
            <div class="quiz-level-pill" id="master-quiz-subtitle">
              Kombinative Masterfrage
            </div>
          </div>
          <button
            class="quiz-close-btn"
            type="button"
            id="master-quiz-close-btn"
          >
            ESC
          </button>
        </div>

        <div class="quiz-body" id="master-quiz-body"></div>

        <div class="quiz-footer">
          <div class="quiz-feedback" id="master-quiz-feedback"></div>
          <button
            class="quiz-submit-btn"
            type="button"
            id="master-quiz-submit-btn"
          >
            Antwort prüfen
          </button>
        </div>
      </div>
    </div>

    <!-- Hotkeys-Modal -->
    <div id="hotkeys-root" class="hotkeys-modal hidden" aria-hidden="true">
      <div class="quiz-backdrop"></div>
      <div class="hotkeys-modal-inner">
        <div class="quiz-header">
          <div>
            <div class="quiz-title">⚡ Hotkeys & Quality of Life</div>
            <div class="quiz-level-pill">Terminal-Workflow Verbesserungen</div>
          </div>
          <button class="quiz-close-btn" type="button" id="hotkeys-close-btn">
            ESC
          </button>
        </div>

        <div class="quiz-body" id="hotkeys-body"></div>
      </div>
    </div>

    <!-- Kali-Tools-Modal -->
    <div
      id="kali-tools-root"
      class="kali-tools-modal hidden"
      aria-hidden="true"
    >
      <div class="quiz-backdrop"></div>
      <div class="kali-tools-modal-inner">
        <div class="quiz-header">
          <div>
            <div class="quiz-title">🔐 Kali Linux Tools</div>
            <div class="quiz-level-pill">Pentesting-Tools & Setup-Guide</div>
            <div
              class="kali-tools-badges-container"
              id="kali-tools-badges-container"
            ></div>
          </div>
          <button
            class="quiz-close-btn"
            type="button"
            id="kali-tools-close-btn"
          >
            ESC
          </button>
        </div>

        <div class="quiz-body" id="kali-tools-body"></div>
      </div>
    </div>

    <!-- Kali-Tools Example Overlay -->
    <div
      id="kali-tools-example-overlay"
      class="kali-tools-overlay hidden"
      aria-hidden="true"
    >
      <div class="quiz-backdrop"></div>
      <div
        id="kali-tools-example-overlay-inner"
        class="kali-tools-overlay-inner"
      >
        <div class="kali-tools-overlay-header">
          <div
            id="kali-tools-example-overlay-title"
            class="kali-tools-overlay-title"
          ></div>
          <button
            type="button"
            class="kali-tools-overlay-close"
            id="kali-tools-example-overlay-close"
          >
            ✕ Schließen
          </button>
        </div>
        <div
          id="kali-tools-example-overlay-content"
          class="kali-tools-overlay-content"
        ></div>
      </div>
    </div>

    <script>
      // Suppress browser extension message channel errors (harmless but annoying)
      window.addEventListener(
        "error",
        (event) => {
          if (
            event.message &&
            event.message.includes("message channel closed")
          ) {
            event.preventDefault();
            return true;
          }
        },
        true
      );

      window.addEventListener("unhandledrejection", (event) => {
        if (
          event.reason &&
          typeof event.reason === "object" &&
          event.reason.message
        ) {
          if (event.reason.message.includes("message channel closed")) {
            event.preventDefault();
            return true;
          }
        } else if (
          typeof event.reason === "string" &&
          event.reason.includes("message channel closed")
        ) {
          event.preventDefault();
          return true;
        }
      });

      // Quiz-Daten – geprüfte & polierte Version
      const quizData = {
        pwd: {
          title: "pwd",
          description: "Arbeite bewusst mit dem aktuellen Arbeitsverzeichnis.",
          explanation: "Zeigt das aktuelle Arbeitsverzeichnis.",
          simpleExample: "pwd → /home/user",
          detail:
            "Sehr praktisch in Kombination mit cd .., um zu überprüfen, wo du gerade „gelandet“ bist.",
          complexExample: 'echo "Aktuelles Verzeichnis: $(pwd)" >> script.log',
          complexExampleExplanation: [
            {
              line: 'echo "Aktuelles Verzeichnis: $(pwd)" >> script.log',
              explanation:
                "$(pwd) wird durch den aktuellen Pfad ersetzt, echo gibt den Text aus, >> hängt ihn an script.log an (ohne Überschreibung)",
            },
          ],
          flags: [
            {
              flag: "-P",
              description: "zeigt den physischen Pfad ohne Symlinks",
              utility: "mittel",
              risk: "niedrig (nur Anzeige)",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Was macht der Befehl `pwd`?",
              options: [
                "Er zeigt das aktuelle Verzeichnis (den absoluten Pfad) an.",
                "Er listet alle Dateien im aktuellen Verzeichnis auf.",
                "Er wechselt ins Home-Verzeichnis.",
                "Er zeigt die Berechtigungen einer Datei an.",
              ],
              correctIndex: 0,
              explanation:
                "`pwd` = print working directory – zeigt den vollständigen Pfad deines aktuellen Verzeichnisses.",
            },
            {
              level: "mittel",
              prompt:
                "Du befindest dich in `/home/user/Documents` und führst `cd /tmp && pwd` aus. Was wird angezeigt?",
              options: ["/home/user/Documents", "/tmp", "/home/user", "/"],
              correctIndex: 1,
              explanation:
                "Nach `cd /tmp` ist dein Arbeitsverzeichnis `/tmp`, also zeigt `pwd` genau diesen Pfad.",
            },
            {
              level: "schwer",
              prompt:
                "Was ist der Unterschied zwischen der Builtin-Version von `pwd` (in der Shell) und dem externen `pwd`-Befehl (`/bin/pwd`)?",
              options: [
                "Das Builtin folgt Symbolic Links, `/bin/pwd` zeigt den physikalischen Pfad (mit `-P`).",
                "Das Builtin funktioniert nur mit Root-Rechten, `/bin/pwd` nicht.",
                "Das Builtin zeigt relative Pfade, `/bin/pwd` absolute Pfade.",
                "Es gibt keinen Unterschied, beide sind identisch.",
              ],
              correctIndex: 0,
              explanation:
                "Das Shell-Builtin `pwd` kann Symbolic Links folgen, während `/bin/pwd -P` den physikalischen Pfad (ohne Links) zeigt. Standardmäßig geben beide absolute Pfade aus.",
            },
          ],
        },

        cd: {
          title: "cd",
          description: "Verzeichnisse wechseln – Grundlage jeder Navigation.",
          explanation: "Wechselt in ein anderes Verzeichnis.",
          simpleExample: "cd /home/user/Documents",
          detail:
            "Mit cd ohne Argument kehrst du in dein Home zurück: cd → /home/user",
          complexExample:
            'OLDPWD=$(pwd)\n\ncd /home/user/Downloads\n\nls > download_list.txt\n\ncd "$OLDPWD"',
          complexExampleExplanation: [
            {
              line: "OLDPWD=$(pwd)",
              explanation:
                "Speichert den aktuellen Pfad in der Variable OLDPWD für späteren Rückweg",
            },
            {
              line: "cd /home/user/Downloads",
              explanation:
                "Wechselt ins Downloads-Verzeichnis (absoluter Pfad)",
            },
            {
              line: "ls > download_list.txt",
              explanation:
                "Listet alle Dateien auf und speichert die Ausgabe in download_list.txt (überschreibt die Datei)",
            },
            {
              line: 'cd "$OLDPWD"',
              explanation:
                "Wechselt zurück zum ursprünglichen Verzeichnis (die Variable wird in Anführungszeichen gesetzt, falls Leerzeichen enthalten sind)",
            },
          ],
          flags: [
            {
              flag: "(ohne Argument)",
              description: "wechselt ins Home-Verzeichnis",
              utility: "hoch",
              risk: "niedrig",
            },
            {
              flag: "-",
              description: "wechselt ins vorherige Verzeichnis (Toggle)",
              utility: "hoch",
              risk: "niedrig",
            },
            {
              flag: "..",
              description: "Parent-Verzeichnis",
              utility: "hoch",
              risk: "niedrig",
            },
            {
              flag: "~user",
              description: "ins Home von user",
              utility: "mittel",
              risk: "niedrig (nur Navigation)",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt:
                "Welcher Befehl wechselt in das Verzeichnis `/home/user/Documents`?",
              options: [
                "open /home/user/Documents",
                "ls /home/user/Documents",
                "cd /home/user/Documents",
                "pwd /home/user/Documents",
              ],
              correctIndex: 2,
              explanation:
                "`cd` steht für change directory und wechselt das Verzeichnis.",
            },
            {
              level: "mittel",
              prompt:
                "Du bist in `/home/user` und führst `cd Documents/Projects` aus. Wo landest du?",
              options: [
                "/Documents/Projects",
                "/home/Documents/Projects",
                "/home/user/Documents/Projects",
                "/home/user/Projects",
              ],
              correctIndex: 2,
              explanation:
                "Ohne `/` am Anfang ist es ein relativer Pfad, ausgehend vom aktuellen Verzeichnis.",
            },
            {
              level: "schwer",
              prompt:
                "Welche Variante wechselt in das vorherige Verzeichnis (Toggle zwischen zwei Verzeichnissen)?",
              options: ["`cd ..`", "`cd -`", "`cd ~`", "`cd /`"],
              correctIndex: 1,
              explanation:
                "`cd -` wechselt zum vorherigen Verzeichnis (OLDPWD) und ist praktisch wie ein Zurück-Button.",
            },
          ],
        },

        cd_parent: {
          title: "cd ..",
          description: "Eine Ebene nach oben springen.",
          explanation: "Wechselt ein Verzeichnis nach oben (Parent).",
          simpleExample: "cd ..\n\nvon /home/user/Documents → /home/user",
          detail:
            "Du kannst auch cd ../.. verwenden, um zwei Ebenen hochzugehen.",
          complexExample:
            'cd "$(dirname "$0")/.."   # ein Level hoch relativ zum Script\n\npwd >> where_am_i.log',
          complexExampleExplanation: [
            {
              line: 'cd "$(dirname "$0")/.."',
              explanation:
                'dirname "$0" gibt das Verzeichnis des aktuellen Scripts zurück, /.. geht eine Ebene hoch, cd wechselt dorthin',
            },
            {
              line: "pwd >> where_am_i.log",
              explanation:
                "Zeigt den aktuellen Pfad an und hängt ihn an where_am_i.log an (für Logging/Debugging)",
            },
          ],
          additionalExamples: `
✅ <strong>1. Eine Ebene hoch gehen und dann prüfen wo du bist</strong><br>
<code>cd ..</code><br>
<code>pwd</code><br>
→ Geht eine Ebene nach oben, pwd zeigt den neuen Pfad<br><br>

✅ <strong>2. Nach oben gehen und dann den Inhalt auflisten</strong><br>
<code>cd ..</code><br>
<code>ls</code><br>
→ Wechselt ins Parent-Verzeichnis, ls zeigt was dort ist<br><br>

✅ <strong>3. Zwei Ebenen hoch gehen</strong><br>
<code>cd ../..</code><br>
<code>pwd</code><br>
→ Geht zwei Ebenen nach oben, pwd zeigt den neuen Pfad<br><br>

✅ <strong>4. In einen Ordner wechseln, dann zurück nach oben</strong><br>
<code>cd Documents</code><br>
<code>cd ..</code><br>
<code>ls</code><br>
→ Wechselt ins Documents-Verzeichnis, geht zurück nach oben, ls zeigt den Inhalt<br><br>

✅ <strong>5. Nach oben gehen und dann Dateien kopieren</strong><br>
<code>cd ..</code><br>
<code>cp file.txt backup/</code><br>
→ Geht eine Ebene hoch, kopiert dann eine Datei ins backup-Verzeichnis
          `,
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `cd ..`?",
              options: [
                "Wechselt ins Home-Verzeichnis.",
                "Wechselt ins übergeordnete Verzeichnis.",
                "Wechselt ins Wurzelverzeichnis `/`.",
                "Wechselt in ein verstecktes Verzeichnis.",
              ],
              correctIndex: 1,
              explanation:
                "`..` ist immer das Parent-Verzeichnis (eine Ebene höher).",
            },
            {
              level: "mittel",
              prompt:
                "Du bist in `/home/user/Documents` und führst zweimal `cd ..` aus. Wo bist du?",
              options: ["/home/user/Documents/..", "/home/user", "/home", "/"],
              correctIndex: 2,
              explanation: "Einmal `cd ..` → `/home/user`, zweimal → `/home`.",
            },
            {
              level: "schwer",
              prompt:
                "Von welchem Startpfad aus bringt dich `cd ../..` direkt nach `/home`?",
              options: [
                "Aus `/home/user/Documents`",
                "Aus `/home/user`",
                "Aus `/home/user/Docs`",
                "Aus `/home`",
              ],
              correctIndex: 2,
              explanation:
                "Von `/home/user/Docs` aus geht `../..` zwei Ebenen hoch: `/home/user/Docs` → `/home/user` → `/home`.",
            },
          ],
        },

        ls: {
          title: "ls",
          description: "Dateien und Ordner auflisten.",
          explanation: "Listet Dateien und Ordner im aktuellen Verzeichnis.",
          simpleExample: "ls",
          detail:
            "ls sortiert standardmäßig alphabetisch; mit ls -t nach Änderungszeit.",
          complexExample: "ls *.log 2>/dev/null | wc -l",
          complexExampleExplanation: [
            {
              line: "ls *.log 2>/dev/null | wc -l",
              explanation:
                "ls *.log listet alle .log-Dateien, 2>/dev/null versteckt Fehler (z.B. wenn keine .log-Dateien existieren), | leitet an wc -l weiter, das die Anzahl der Zeilen (also Dateien) zählt",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt:
                "Welcher Befehl listet Dateien im aktuellen Verzeichnis auf?",
              options: ["show", "ls", "pwd", "open"],
              correctIndex: 1,
              explanation:
                "`ls` ist der Standardbefehl zum Auflisten des Inhalts eines Verzeichnisses.",
            },
            {
              level: "mittel",
              prompt:
                "Welche Option zeigt dir zusätzlich versteckte Dateien (Einträge, die mit `.` beginnen)?",
              options: ["`ls -l`", "`ls -R`", "`ls -a`", "`ls -h`"],
              correctIndex: 2,
              explanation:
                "`-a` steht für „all“ und zeigt auch versteckte Einträge.",
            },
            {
              level: "schwer",
              prompt:
                "Du möchtest eine detaillierte, rekursive Liste aller Dateien (inkl. versteckter) und dabei Dateitypen unterscheiden können. Welche Kombination erfüllt alle Anforderungen?",
              options: ["`ls -lRa`", "`ls -R`", "`ls -al`", "`ls -aR`"],
              correctIndex: 0,
              explanation:
                "`-l` = Details (zeigt Dateityp mit erstem Zeichen), `-a` = versteckte Dateien, `-R` = rekursiv. Die Reihenfolge der Optionen ist egal, aber alle drei müssen vorhanden sein.",
            },
          ],
        },

        grep: {
          title: "grep",
          description: "Texte nach Mustern durchsuchen.",
          explanation: "Sucht nach Textmustern in Dateien oder Eingaben.",
          simpleExample: 'grep "Error" logfile.txt',
          detail:
            "Mit -n Zeilennummern anzeigen, mit -i Groß-/Kleinschreibung ignorieren.",
          complexExample: 'grep -n "TODO" *.sh',
          additionalExamples: `
✅ <strong>1. In einer Datei suchen (die du mit cat anzeigen könntest)</strong><br>
<code>cat log.txt</code><br>
<code>grep "Error" log.txt</code><br>
→ cat zeigt den ganzen Inhalt, grep filtert nur Zeilen mit "Error"<br><br>

✅ <strong>2. Suche und dann sortiere die Ergebnisse</strong><br>
<code>grep "user" names.txt</code><br>
<code>grep "user" names.txt | sort</code><br>
→ Findet alle Zeilen mit "user", sort sortiert sie alphabetisch<br><br>

✅ <strong>3. Suche in mehreren Dateien (die du mit find finden könntest)</strong><br>
<code>find . -name "*.log"</code><br>
<code>grep "Error" *.log</code><br>
→ find zeigt alle .log-Dateien, grep sucht "Error" in allen .log-Dateien<br><br>

✅ <strong>4. Suche und zeige nur die ersten 5 Treffer</strong><br>
<code>grep "TODO" *.txt</code><br>
<code>grep "TODO" *.txt | head -n 5</code><br>
→ Findet alle "TODO" Einträge, head zeigt nur die ersten 5 Zeilen<br><br>

✅ <strong>5. Suche, sortiere und entferne Duplikate</strong><br>
<code>grep "admin" users.txt</code><br>
<code>grep "admin" users.txt | sort | uniq</code><br>
→ Findet "admin", sort sortiert, uniq entfernt doppelte Zeilen
          `,
          complexExampleExplanation: [
            {
              line: 'grep -n "TODO" *.sh',
              explanation:
                'grep sucht nach "TODO", -n zeigt Zeilennummern an, *.sh durchsucht alle .sh-Dateien im aktuellen Verzeichnis',
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: 'Was macht `grep "Error" logfile.txt`?',
              options: [
                'Es löscht alle Zeilen mit "Error".',
                'Es zeigt alle Zeilen mit "Error" in `logfile.txt`.',
                "Es sortiert `logfile.txt` alphabetisch.",
                "Es kopiert `logfile.txt` in eine andere Datei.",
              ],
              correctIndex: 1,
              explanation:
                "`grep` filtert und zeigt nur Zeilen, die zum Suchmuster passen.",
            },
            {
              level: "mittel",
              prompt:
                'Du musst rekursiv in allen `.log`-Dateien nach "failed" suchen, aber andere Dateitypen ignorieren. Welcher Befehl ist korrekt?',
              options: [
                '`grep -r "failed" *.log`',
                '`grep -r "failed" --include="*.log" .`',
                "`grep -R \"failed\" . -name '*.log'`",
                "`grep \"failed\" $(find . -name '*.log')`",
              ],
              correctIndex: 1,
              explanation:
                "`grep -r` sucht rekursiv, `--include='*.log'` beschränkt die Suche auf `.log`-Dateien, `.` gibt das Startverzeichnis an. Die Reihenfolge ist wichtig: Optionen vor Suchmuster.",
            },
            {
              level: "schwer",
              prompt:
                "Welche Variante hebt Treffer farbig hervor (falls unterstützt)?",
              options: [
                '`grep --color=auto "pattern" file`',
                '`grep -c "pattern" file`',
                '`grep -v "pattern" file`',
                '`grep -n "pattern" file`',
              ],
              correctIndex: 0,
              explanation:
                "`--color=auto` markiert gefundene Muster farbig – ideal zum schnellen Scannen.",
            },
          ],
        },

        pipe: {
          title: "Pipe |",
          description: "Befehle zu einer Verarbeitungskette verknüpfen.",
          explanation:
            "Leitet die Ausgabe eines Befehls als Eingabe an den nächsten weiter.",
          simpleExample: "ls | sort",
          detail:
            "Pipes verbinden stdout → stdin; viele kleine Werkzeuge zusammen verwenden.",
          complexExample: "cat errors.log | sort | uniq > unique_errors.txt",
          complexExampleExplanation: [
            {
              line: "cat errors.log | sort | uniq > unique_errors.txt",
              explanation:
                "cat liest errors.log, | leitet an sort weiter (sortiert alphabetisch), | leitet an uniq weiter (entfernt Duplikate), > speichert das Ergebnis in unique_errors.txt",
            },
          ],
          additionalExamples: `
✅ <strong>1. Dateien auflisten und sortieren</strong><br>
<code>ls</code><br>
<code>ls | sort</code><br>
→ ls zeigt Dateien, sort sortiert sie alphabetisch<br><br>

✅ <strong>2. Datei anzeigen, dann nach etwas suchen</strong><br>
<code>cat log.txt</code><br>
<code>cat log.txt | grep "Error"</code><br>
→ cat zeigt den Inhalt, grep filtert nur Zeilen mit "Error"<br><br>

✅ <strong>3. Suche, sortiere und entferne Duplikate</strong><br>
<code>grep "user" names.txt</code><br>
<code>grep "user" names.txt | sort | uniq</code><br>
→ Findet "user", sort sortiert, uniq entfernt doppelte Zeilen<br><br>

✅ <strong>4. Dateien auflisten und zählen</strong><br>
<code>ls</code><br>
<code>ls | wc -l</code><br>
→ ls zeigt Dateien, wc -l zählt wie viele es sind<br><br>

✅ <strong>5. Suche, zeige nur die ersten Treffer</strong><br>
<code>grep "TODO" *.txt</code><br>
<code>grep "TODO" *.txt | head -n 10</code><br>
→ Findet alle "TODO" Einträge, head zeigt nur die ersten 10
          `,
          questions: [
            {
              level: "leicht",
              prompt: "Was macht das Pipe-Symbol `|`?",
              options: [
                "Es kommentiert eine Zeile aus.",
                "Es startet einen neuen Terminal-Tab.",
                "Es leitet die Ausgabe eines Befehls als Eingabe an den nächsten weiter.",
                "Es löscht die Ausgabe eines Befehls.",
              ],
              correctIndex: 2,
              explanation:
                "Mit `Befehl1 | Befehl2` geht `stdout` von Befehl1 als `stdin` an Befehl2.",
            },
            {
              level: "mittel",
              prompt: "Was macht `ls | sort`?",
              options: [
                "Listet Dateien und sortiert sie alphabetisch.",
                "Sortiert Dateien nach Größe.",
                "Zeigt nur versteckte Dateien.",
                "Löscht doppelte Dateinamen.",
              ],
              correctIndex: 0,
              explanation:
                "`ls` liefert die Liste, `sort` sortiert diese Liste alphabetisch.",
            },
            {
              level: "schwer",
              prompt:
                "Wie würdest du alle eindeutigen Fehlertypen aus `errors.log` extrahieren (alphabetisch, ohne Duplikate)?",
              options: [
                "`cat errors.log | uniq | sort`",
                "`cat errors.log | sort | uniq`",
                "`uniq errors.log | sort`",
                "`sort -n errors.log | uniq`",
              ],
              correctIndex: 1,
              explanation:
                "Erst sortieren, dann `uniq`, damit doppelte Zeilen direkt hintereinander liegen und zusammengefasst werden.",
            },
          ],
        },

        redirect: {
          title: "Umleitung",
          description: "stdout/stderr in Dateien umleiten.",
          explanation: "Leitet Ausgaben und Fehler in Dateien um.",
          simpleExample: "echo Hallo > out.txt",
          detail:
            "`>` überschreibt, `>>` hängt an; `2>&1` kombiniert stderr mit stdout.",
          complexExample: "command > all.log 2>&1",
          complexExampleExplanation: [
            {
              line: "command > all.log 2>&1",
              explanation:
                "command führt einen Befehl aus, > all.log leitet stdout in all.log um, 2>&1 leitet stderr (2) auf stdout (1) um, sodass beide Streams in derselben Datei landen",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `echo Hallo > out.txt`?",
              options: [
                'Hängt "Hallo" an `out.txt` an.',
                'Überschreibt `out.txt` mit "Hallo" (oder erstellt die Datei).',
                'Zeigt "Hallo" nur im Terminal an.',
                "Löscht die Datei `out.txt`.",
              ],
              correctIndex: 1,
              explanation:
                "`>` überschreibt (oder erstellt) die Datei und schreibt die Standardausgabe hinein.",
            },
            {
              level: "mittel",
              prompt:
                "Du willst Log-Ausgaben an eine Datei anhängen statt sie zu überschreiben. Welche Variante ist korrekt?",
              options: [
                "`echo Neu > log.txt`",
                "`echo Neu >> log.txt`",
                "`echo Neu 2> log.txt`",
                "`echo Neu | log.txt`",
              ],
              correctIndex: 1,
              explanation:
                "`>>` fügt Text am Ende der Datei an, ohne den bestehenden Inhalt zu löschen.",
            },
            {
              level: "schwer",
              prompt:
                "Wie leitest du sowohl stdout als auch stderr in dieselbe Datei `all.log` um?",
              options: [
                "`command > all.log 2> all.log`",
                "`command 2> all.log`",
                "`command > all.log 2>&1`",
                "`command &> all.log && 2>`",
              ],
              correctIndex: 2,
              explanation:
                "`> all.log 2>&1` lenkt stderr (2) auf den gleichen Stream wie stdout (1), der in `all.log` landet.",
            },
          ],
        },

        nano_flow: {
          title: "Nano + Script-Workflow",
          description:
            "Script schreiben, speichern, ausführbar machen, starten.",
          explanation:
            "Script schreiben, ausführbar machen und starten (Editor + Rechte).",
          simpleExample:
            "STRG+O (speichern) → chmod +x script.sh → ./script.sh",
          detail: "STRG+O speichert in nano; chmod +x setzt das Execute-Bit.",
          complexExample: "nano script.sh\n\nchmod +x script.sh\n\n./script.sh",
          complexExampleExplanation: [
            {
              line: "nano script.sh",
              explanation:
                "Öffnet den Editor nano zum Bearbeiten von script.sh (STRG+O speichern, STRG+X beenden)",
            },
            {
              line: "chmod +x script.sh",
              explanation:
                "Setzt das Ausführungsbit (x) für script.sh, damit es direkt ausgeführt werden kann",
            },
            {
              line: "./script.sh",
              explanation:
                "Führt das Script im aktuellen Verzeichnis aus (./ bedeutet aktuelles Verzeichnis)",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt:
                "Welche Tastenkombination speichert eine Datei in `nano`?",
              options: ["STRG + X", "STRG + S", "STRG + O", "STRG + Q"],
              correctIndex: 2,
              explanation:
                "In `nano` steht STRG+O (write Out) für Speichern, STRG+X beendet den Editor.",
            },
            {
              level: "mittel",
              prompt:
                "Welche zwei Befehle brauchst du minimal, um `script.sh` ausführbar zu machen und direkt zu starten?",
              options: [
                "`chmod +x script.sh` und `./script.sh`",
                "`nano script.sh` und `bash script.sh`",
                "`chown script.sh` und `run script.sh`",
                "`exec script.sh` und `run script.sh`",
              ],
              correctIndex: 0,
              explanation:
                "Mit `chmod +x` setzt du das Ausführungsbit, `./script.sh` startet das Script im aktuellen Verzeichnis.",
            },
            {
              level: "schwer",
              prompt:
                "Warum schlägt `./script.sh` typischerweise fehl, obwohl die Datei existiert? Was ist die wahrscheinlichste Ursache?",
              options: [
                "Die Datei liegt nicht im PATH.",
                "Die Datei hat keine Ausführungsrechte.",
                "Das Terminal unterstützt keine Shell.",
                "Das Script heißt eigentlich `script.bash`.",
              ],
              correctIndex: 1,
              explanation:
                "Bei `./script.sh` wird der PATH nicht benötigt – häufig fehlt einfach das Execute-Bit (`chmod +x script.sh`).",
            },
          ],
        },

        ls_a: {
          title: "ls -a",
          description:
            "Listet alle Dateien, inklusive versteckter (beginnen mit .).",
          explanation: "Zeigt auch versteckte Dateien.",
          simpleExample: "ls -a",
          detail: "Zeigt auch . (aktuelles Verzeichnis) und .. (Parent).",
          complexExample: 'cd ~\nls -a | grep "^\\."',
          complexExampleExplanation: [
            {
              line: "cd ~",
              explanation:
                "Wechselt ins Home-Verzeichnis (~ ist eine Abkürzung für $HOME)",
            },
            {
              line: 'ls -a | grep "^\\."',
              explanation:
                'ls -a zeigt alle Dateien (inkl. versteckter), | leitet an grep weiter, "^\\." filtert nur Zeilen, die mit einem Punkt beginnen (versteckte Dateien)',
            },
          ],
          additionalExamples: `
✅ <strong>1. Normale Liste vs. alle Dateien</strong><br>
<code>ls</code><br>
<code>ls -a</code><br>
→ ls zeigt nur normale Dateien, ls -a zeigt auch versteckte (mit .)<br><br>

✅ <strong>2. In ein Verzeichnis wechseln und dann alles anzeigen</strong><br>
<code>cd Documents</code><br>
<code>ls -a</code><br>
→ Wechselt ins Documents-Verzeichnis, ls -a zeigt alle Dateien dort<br><br>

✅ <strong>3. Prüfen wo du bist, dann alles auflisten</strong><br>
<code>pwd</code><br>
<code>ls -a</code><br>
→ pwd zeigt deinen Pfad, ls -a zeigt alle Dateien im aktuellen Verzeichnis<br><br>

✅ <strong>4. Liste speichern und dann anzeigen</strong><br>
<code>ls -a > alle_dateien.txt</code><br>
<code>cat alle_dateien.txt</code><br>
→ Speichert die Liste in eine Datei, cat zeigt den Inhalt<br><br>

✅ <strong>5. Versteckte Dateien finden und dann auflisten</strong><br>
<code>ls -a</code><br>
<code>ls -a | grep "^\\.bash"</code><br>
→ Zeigt alle Dateien, grep filtert nur .bash-Dateien (versteckte Config-Dateien)
          `,
          questions: [
            {
              level: "leicht",
              prompt: "Was zeigt `ls -a` zusätzlich zu normalen Dateien?",
              options: [
                "Nur Dateien mit Schreibrechten",
                "Versteckte Dateien (beginnen mit .)",
                "Nur Ordner",
                "Nur ausführbare Dateien",
              ],
              correctIndex: 1,
              explanation:
                "`-a` steht für 'all' und zeigt auch versteckte Einträge, die mit einem Punkt beginnen.",
            },
            {
              level: "mittel",
              prompt: "Welche Einträge zeigt `ls -a` immer an?",
              options: [
                "Nur . und ..",
                ". (aktuelles Verzeichnis) und .. (Parent-Verzeichnis)",
                "Nur versteckte Dateien",
                "Alle Dateien außer ..",
              ],
              correctIndex: 1,
              explanation:
                "`ls -a` zeigt immer . (aktuelles Verzeichnis) und .. (übergeordnetes Verzeichnis) zusätzlich zu allen anderen Dateien.",
            },
            {
              level: "schwer",
              prompt:
                "Wie listest du nur die versteckten Dateien im Home-Verzeichnis auf?",
              options: [
                "ls -a ~",
                "cd ~ && ls -a | grep '^\\.'",
                "ls ~ -h",
                "find ~ -name '.*'",
              ],
              correctIndex: 1,
              explanation:
                "Mit `ls -a | grep '^\\.'` filterst du nur Einträge, die mit einem Punkt beginnen.",
            },
          ],
        },

        ls_la: {
          title: "ls -la",
          description:
            "Detaillierte Liste aller Dateien mit Rechten, Besitzer, Größe usw.",
          explanation: "Details + versteckte Dateien.",
          simpleExample: "ls -la",
          detail:
            "Das erste Zeichen der Zeile zeigt den Typ: - Datei, d Verzeichnis, l Link.",
          complexExample: "ls -la | awk '{print $1, $9}'",
          complexExampleExplanation: [
            {
              line: "ls -la | awk '{print $1, $9}'",
              explanation:
                "ls -la zeigt Details aller Dateien, | leitet an awk weiter, awk extrahiert Spalte 1 (Rechte) und Spalte 9 (Dateiname) und gibt sie aus",
            },
          ],
          additionalExamples: `
✅ <strong>1. Normale Liste vs. detaillierte Liste</strong><br>
<code>ls</code><br>
<code>ls -la</code><br>
→ ls zeigt nur Namen, ls -la zeigt Details (Rechte, Besitzer, Größe, Datum)<br><br>

✅ <strong>2. Prüfen wo du bist, dann Details anzeigen</strong><br>
<code>pwd</code><br>
<code>ls -la</code><br>
→ pwd zeigt deinen Pfad, ls -la zeigt alle Dateien mit Details<br><br>

✅ <strong>3. In einen Ordner wechseln und Details anzeigen</strong><br>
<code>cd Documents</code><br>
<code>ls -la</code><br>
→ Wechselt ins Documents-Verzeichnis, zeigt alle Dateien mit Details<br><br>

✅ <strong>4. Details speichern und dann anzeigen</strong><br>
<code>ls -la > dateien_details.txt</code><br>
<code>cat dateien_details.txt</code><br>
→ Speichert die detaillierte Liste in eine Datei, cat zeigt den Inhalt<br><br>

✅ <strong>5. Details anzeigen und dann nach etwas suchen</strong><br>
<code>ls -la</code><br>
<code>ls -la | grep ".txt"</code><br>
→ Zeigt alle Details, grep filtert nur .txt-Dateien
          `,
          questions: [
            {
              level: "leicht",
              prompt: "Was zeigt `ls -la` zusätzlich zu `ls`?",
              options: [
                "Nur versteckte Dateien",
                "Details (Rechte, Besitzer, Größe) und versteckte Dateien",
                "Nur Dateigrößen",
                "Nur Besitzer",
              ],
              correctIndex: 1,
              explanation:
                "`-l` zeigt Details, `-a` zeigt versteckte Dateien. Kombiniert: alles mit Details.",
            },
            {
              level: "mittel",
              prompt:
                "Was bedeutet das erste Zeichen 'd' in der Ausgabe von `ls -la`?",
              options: [
                "Datei",
                "Verzeichnis (Directory)",
                "Link",
                "Ausführbar",
              ],
              correctIndex: 1,
              explanation:
                "Das erste Zeichen zeigt den Dateityp: 'd' = Directory (Verzeichnis), '-' = Datei, 'l' = Link.",
            },
            {
              level: "schwer",
              prompt:
                "Wie zeigst du nur Rechte und Dateinamen aus `ls -la` an?",
              options: [
                "ls -la | cut -d' ' -f1,9",
                "ls -la | awk '{print $1, $9}'",
                "ls -la | grep -o '^[^ ]* [^ ]*$'",
                "Alle oben genannten funktionieren",
              ],
              correctIndex: 3,
              explanation:
                "Es gibt mehrere Wege, aber `awk '{print $1, $9}'` ist am einfachsten: Spalte 1 = Rechte, Spalte 9 = Dateiname.",
            },
          ],
        },

        mkdir: {
          title: "mkdir",
          description: "Erstellt einen neuen Ordner.",
          explanation: "Ordner erstellen.",
          simpleExample: "mkdir Test",
          detail:
            "Fehlschlag, wenn der Ordner schon existiert (außer du nutzt -p).",
          complexExample: "mkdir Music Images Documents Scripts",
          complexExampleExplanation: [
            {
              line: "mkdir Music Images Documents Scripts",
              explanation:
                "Erstellt vier Ordner gleichzeitig: Music, Images, Documents und Scripts (mehrere Argumente werden als separate Ordner interpretiert)",
            },
          ],
          additionalExamples: `
✅ <strong>1. Ordner erstellen und dann prüfen wo du bist</strong><br>
<code>mkdir my_folder</code><br>
<code>pwd</code><br>
→ Erstellt den Ordner, pwd zeigt deinen aktuellen Pfad<br><br>

✅ <strong>2. Ordner erstellen und dann den Inhalt anzeigen</strong><br>
<code>mkdir backup</code><br>
<code>ls</code><br>
→ Erstellt backup, ls zeigt dass der neue Ordner existiert<br><br>

✅ <strong>3. Ordner erstellen, hinein wechseln, prüfen</strong><br>
<code>mkdir projects</code><br>
<code>cd projects</code><br>
<code>pwd</code><br>
→ Erstellt projects, wechselt hinein, zeigt den neuen Pfad<br><br>

✅ <strong>4. Mehrere Ordner erstellen und dann auflisten</strong><br>
<code>mkdir folder1 folder2 folder3</code><br>
<code>ls</code><br>
→ Erstellt drei Ordner auf einmal, ls zeigt alle<br><br>

✅ <strong>5. Ordner erstellen, Dateien kopieren, dann Inhalt prüfen</strong><br>
<code>mkdir archive</code><br>
<code>cp *.txt archive/</code><br>
<code>ls archive/</code><br>
→ Erstellt archive, kopiert Dateien hinein, ls zeigt den Inhalt
          `,
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `mkdir Test`?",
              options: [
                "Löscht den Ordner Test",
                "Erstellt einen neuen Ordner namens Test",
                "Zeigt den Inhalt von Test",
                "Kopiert Test",
              ],
              correctIndex: 1,
              explanation:
                "`mkdir` steht für 'make directory' und erstellt einen neuen Ordner.",
            },
            {
              level: "mittel",
              prompt:
                "Was passiert, wenn du `mkdir Test` ausführst, aber Test bereits existiert?",
              options: [
                "Der Ordner wird überschrieben",
                "Es gibt einen Fehler",
                "Der Ordner wird umbenannt",
                "Nichts passiert",
              ],
              correctIndex: 1,
              explanation:
                "Ohne `-p` gibt `mkdir` einen Fehler aus, wenn der Ordner bereits existiert.",
            },
            {
              level: "schwer",
              prompt: "Wie erstellst du mehrere Ordner auf einmal?",
              options: [
                "mkdir Ordner1 Ordner2 Ordner3",
                "mkdir -m Ordner1,Ordner2,Ordner3",
                "mkdir --multiple Ordner1 Ordner2",
                "Das geht nicht mit mkdir",
              ],
              correctIndex: 0,
              explanation:
                "`mkdir` kann mehrere Ordner auf einmal erstellen, wenn du sie als separate Argumente angibst.",
            },
          ],
        },

        mkdir_p: {
          title: "mkdir -p",
          description:
            "Erstellt einen Ordner inkl. aller fehlenden Zwischenordner.",
          explanation: "inkl. Zwischenordner erstellen.",
          simpleExample: "mkdir -p Projekte/2025/Notizen",
          detail: "Wenn der Pfad schon existiert, gibt es keinen Fehler.",
          complexExample:
            'mkdir -p /var/log/myapp\necho "Starte App..." >> /var/log/myapp/run.log',
          complexExampleExplanation: [
            {
              line: "mkdir -p /var/log/myapp",
              explanation:
                "Erstellt /var/log/myapp inklusive aller fehlenden Zwischenordner (/var, /var/log), -p verhindert Fehler wenn Verzeichnisse bereits existieren",
            },
            {
              line: 'echo "Starte App..." >> /var/log/myapp/run.log',
              explanation:
                'Gibt "Starte App..." aus und hängt es an run.log an (>> fügt am Ende hinzu, ohne Überschreibung)',
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `mkdir -p Projekte/2025/Notizen`?",
              options: [
                "Erstellt nur Notizen",
                "Erstellt Projekte, 2025 und Notizen (alle fehlenden Ordner)",
                "Löscht die Ordner",
                "Zeigt den Pfad an",
              ],
              correctIndex: 1,
              explanation:
                "`-p` erstellt alle fehlenden Zwischenordner im Pfad automatisch.",
            },
            {
              level: "mittel",
              prompt:
                "Was passiert mit `mkdir -p`, wenn der Ordner bereits existiert?",
              options: [
                "Fehler",
                "Kein Fehler, es wird nichts gemacht",
                "Der Ordner wird gelöscht und neu erstellt",
                "Der Ordner wird umbenannt",
              ],
              correctIndex: 1,
              explanation:
                "Mit `-p` gibt es keinen Fehler, wenn der Ordner bereits existiert – ideal für Scripts.",
            },
            {
              level: "schwer",
              prompt: "Warum ist `mkdir -p` in Scripts besonders nützlich?",
              options: [
                "Es ist schneller",
                "Es verhindert Fehler, wenn Ordner bereits existieren",
                "Es löscht alte Ordner",
                "Es zeigt mehr Informationen",
              ],
              correctIndex: 1,
              explanation:
                "`mkdir -p` ist idempotent – es kann mehrfach ausgeführt werden ohne Fehler, perfekt für Scripts.",
            },
          ],
        },

        mv: {
          title: "mv",
          description: "Verschiebt Dateien/Ordner oder benennt sie um.",
          explanation: "verschieben oder umbenennen.",
          simpleExample: "mv song.mp3 Music/\nmv oldname.txt newname.txt",
          detail:
            "Überschreibt still; mit mv -i fragt es vor dem Überschreiben.",
          complexExample: "mkdir -p archive\nmv *.txt archive/",
          complexExampleExplanation: [
            {
              line: "mkdir -p archive",
              explanation:
                "Erstellt den Ordner archive (oder tut nichts, falls er bereits existiert)",
            },
            {
              line: "mv *.txt archive/",
              explanation:
                "Verschiebt alle .txt-Dateien (*.txt ist ein Wildcard-Muster) in den archive-Ordner",
            },
          ],
          additionalExamples: `
✅ <strong>1. Datei verschieben und dann prüfen wo du bist</strong><br>
<code>mv file.txt backup/</code><br>
<code>pwd</code><br>
→ Verschiebt die Datei, pwd zeigt deinen aktuellen Pfad<br><br>

✅ <strong>2. Datei umbenennen und dann den Ordner auflisten</strong><br>
<code>mv old.txt new.txt</code><br>
<code>ls</code><br>
→ Benennt die Datei um, ls zeigt dass nur new.txt existiert<br><br>

✅ <strong>3. In einen Ordner wechseln, verschieben, zurückkehren</strong><br>
<code>cd Documents</code><br>
<code>mv report.txt ../archive/</code><br>
<code>cd ..</code><br>
→ Wechselt ins Documents-Verzeichnis, verschiebt eine Datei eine Ebene nach oben, kehrt zurück<br><br>

✅ <strong>4. Mehrere Dateien verschieben und dann prüfen</strong><br>
<code>mv *.log logs/</code><br>
<code>ls logs/</code><br>
→ Verschiebt alle .log-Dateien ins logs-Verzeichnis, ls zeigt den Inhalt<br><br>

✅ <strong>5. Ordner erstellen, dann Dateien hinein verschieben</strong><br>
<code>mkdir old_files</code><br>
<code>mv file1.txt file2.txt old_files/</code><br>
<code>ls old_files/</code><br>
→ Erstellt den Ordner, verschiebt Dateien hinein, prüft den Inhalt
          `,
          additionalExamples: `
✅ <strong>1. Datei verschieben und dann prüfen wo du bist</strong><br>
<code>mv file.txt backup/</code><br>
<code>pwd</code><br>
→ Verschiebt die Datei, pwd zeigt deinen aktuellen Pfad<br><br>

✅ <strong>2. Datei umbenennen und dann den Ordner auflisten</strong><br>
<code>mv old.txt new.txt</code><br>
<code>ls</code><br>
→ Benennt die Datei um, ls zeigt dass nur new.txt existiert<br><br>

✅ <strong>3. In einen Ordner wechseln, verschieben, zurückkehren</strong><br>
<code>cd Documents</code><br>
<code>mv report.txt ../archive/</code><br>
<code>cd ..</code><br>
→ Wechselt ins Documents-Verzeichnis, verschiebt eine Datei eine Ebene nach oben, kehrt zurück<br><br>

✅ <strong>4. Mehrere Dateien verschieben und dann prüfen</strong><br>
<code>mv *.log logs/</code><br>
<code>ls logs/</code><br>
→ Verschiebt alle .log-Dateien ins logs-Verzeichnis, ls zeigt den Inhalt<br><br>

✅ <strong>5. Ordner erstellen, dann Dateien hinein verschieben</strong><br>
<code>mkdir old_files</code><br>
<code>mv file1.txt file2.txt old_files/</code><br>
<code>ls old_files/</code><br>
→ Erstellt den Ordner, verschiebt Dateien hinein, prüft den Inhalt
          `,
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `mv datei.txt Ordner/`?",
              options: [
                "Kopiert die Datei",
                "Verschiebt die Datei in den Ordner",
                "Löscht die Datei",
                "Zeigt die Datei an",
              ],
              correctIndex: 1,
              explanation: "`mv` verschiebt Dateien von einem Ort zum anderen.",
            },
            {
              level: "mittel",
              prompt: "Was macht `mv alt.txt neu.txt`?",
              options: [
                "Kopiert alt.txt zu neu.txt",
                "Benennt alt.txt in neu.txt um",
                "Löscht beide Dateien",
                "Zeigt beide Dateien an",
              ],
              correctIndex: 1,
              explanation:
                "Wenn das Ziel keine existierende Datei/Ordner ist, benennt `mv` die Datei um.",
            },
            {
              level: "schwer",
              prompt:
                "Wie verhinderst du, dass `mv` eine existierende Datei überschreibt?",
              options: [
                "mv -n datei.txt ziel.txt",
                "mv -i datei.txt ziel.txt",
                "mv --safe datei.txt ziel.txt",
                "Das geht nicht",
              ],
              correctIndex: 1,
              explanation:
                "`mv -i` (interactive) fragt vor dem Überschreiben nach – sicherer für wichtige Dateien.",
            },
          ],
        },

        cp: {
          title: "cp",
          description: "Kopiert Dateien.",
          explanation: "Datei kopieren.",
          simpleExample: "cp notes.txt notes_backup.txt",
          detail:
            "Mit cp -i vor dem Überschreiben nachfragen; mit cp -u nur neuere kopieren.",
          complexExample: "cp ~/.bashrc ~/.bashrc.backup_$(date +%F)",
          complexExampleExplanation: [
            {
              line: "cp ~/.bashrc ~/.bashrc.backup_$(date +%F)",
              explanation:
                "Kopiert .bashrc aus dem Home-Verzeichnis, $(date +%F) wird durch das aktuelle Datum (YYYY-MM-DD) ersetzt, erstellt z.B. .bashrc.backup_2025-01-15",
            },
          ],
          additionalExamples: `
✅ <strong>1. Backup erstellen und dann prüfen wo du bist</strong><br>
<code>cp notes.txt notes_backup.txt</code><br>
<code>pwd</code><br>
→ Kopiert die Datei, dann zeigt pwd deinen aktuellen Pfad<br><br>

✅ <strong>2. Datei kopieren und dann den Inhalt des Ordners anzeigen</strong><br>
<code>cp datei.txt backup/</code><br>
<code>ls backup/</code><br>
→ Kopiert die Datei ins backup-Verzeichnis, ls zeigt was drin ist<br><br>

✅ <strong>3. In einen Ordner wechseln, kopieren, zurückkehren</strong><br>
<code>cd Documents</code><br>
<code>cp report.txt ../backup/</code><br>
<code>cd ..</code><br>
→ Wechselt ins Documents-Verzeichnis, kopiert eine Datei eine Ebene nach oben ins backup, kehrt zurück<br><br>

✅ <strong>4. Mehrere Dateien kopieren und dann auflisten</strong><br>
<code>cp *.txt backup/</code><br>
<code>ls -a backup/</code><br>
→ Kopiert alle .txt-Dateien ins backup-Verzeichnis, ls -a zeigt alle Dateien (inkl. versteckter)<br><br>

✅ <strong>5. Ordner erstellen, dann Datei hinein kopieren</strong><br>
<code>mkdir my_backup</code><br>
<code>cp important.txt my_backup/</code><br>
<code>ls my_backup/</code><br>
→ Erstellt zuerst den Ordner, kopiert dann die Datei hinein, prüft mit ls
          `,
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `cp datei.txt backup.txt`?",
              options: [
                "Verschiebt datei.txt",
                "Kopiert datei.txt zu backup.txt",
                "Löscht datei.txt",
                "Zeigt datei.txt an",
              ],
              correctIndex: 1,
              explanation:
                "`cp` kopiert Dateien – die Originaldatei bleibt erhalten.",
            },
            {
              level: "mittel",
              prompt: "Was macht `cp -u quelle.txt ziel.txt`?",
              options: [
                "Kopiert nur, wenn ziel.txt älter ist",
                "Kopiert nur, wenn ziel.txt neuer ist",
                "Kopiert immer",
                "Löscht ziel.txt",
              ],
              correctIndex: 0,
              explanation:
                "`-u` (update) kopiert nur, wenn die Quelldatei neuer ist als die Zieldatei.",
            },
            {
              level: "schwer",
              prompt: "Wie erstellst du ein Backup mit Datum im Dateinamen?",
              options: [
                "cp datei.txt datei.txt.backup",
                "cp datei.txt datei.txt.backup_$(date +%F)",
                "cp datei.txt datei_backup",
                "cp -d datei.txt backup/",
              ],
              correctIndex: 1,
              explanation:
                "Mit `$(date +%F)` wird das aktuelle Datum im Format YYYY-MM-DD eingefügt.",
            },
          ],
        },

        cp_r: {
          title: "cp -r",
          description: "Kopiert einen Ordner rekursiv mit Inhalt.",
          explanation: "Ordner rekursiv kopieren.",
          simpleExample: "cp -r ProjektA ProjektA_backup",
          detail:
            "-r oder besser -R ist für Verzeichnisse notwendig – sonst Fehler.",
          complexExample: "cp -r /var/www/site /var/backups/site_$(date +%F)",
          complexExampleExplanation: [
            {
              line: "cp -r /var/www/site /var/backups/site_$(date +%F)",
              explanation:
                "Kopiert rekursiv (-r) den gesamten site-Ordner inklusive aller Unterordner und Dateien, $(date +%F) fügt das Datum zum Zielnamen hinzu für ein datiertes Backup",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `cp -r Ordner1 Ordner2`?",
              options: [
                "Kopiert nur den Ordner ohne Inhalt",
                "Kopiert den Ordner rekursiv mit allen Inhalten",
                "Verschiebt den Ordner",
                "Löscht den Ordner",
              ],
              correctIndex: 1,
              explanation:
                "`-r` (recursive) kopiert den gesamten Ordner inklusive aller Unterordner und Dateien.",
            },
            {
              level: "mittel",
              prompt:
                "Was passiert, wenn du `cp Ordner1 Ordner2` ohne `-r` ausführst?",
              options: [
                "Es funktioniert normal",
                "Fehler: Ordner können nicht kopiert werden",
                "Es kopiert nur die Dateien im Ordner",
                "Es erstellt einen leeren Ordner",
              ],
              correctIndex: 1,
              explanation:
                "Ohne `-r` gibt `cp` einen Fehler aus, da Ordner nicht direkt kopiert werden können.",
            },
            {
              level: "schwer",
              prompt: "Was ist der Unterschied zwischen `cp -r` und `cp -R`?",
              options: [
                "Kein Unterschied",
                "-R ist besser für Links",
                "-r funktioniert nicht",
                "-R ist schneller",
              ],
              correctIndex: 0,
              explanation:
                "In den meisten Systemen sind `-r` und `-R` gleichwertig, beide kopieren rekursiv.",
            },
          ],
        },

        rm: {
          title: "rm",
          description: "Löscht Dateien.",
          explanation: "Datei löschen.",
          simpleExample: "rm temp.txt",
          detail: "Kein Papierkorb! Weg ist weg. Nutze rm -i für Sicherheit.",
          complexExample: "rm -i *.tmp",
          complexExampleExplanation: [
            {
              line: "rm -i *.tmp",
              explanation:
                "Löscht alle .tmp-Dateien, -i (interactive) fragt vor jedem Löschen nach Bestätigung (sicherer als ohne -i)",
            },
          ],
          additionalExamples: `
✅ <strong>1. Datei löschen und dann prüfen ob sie weg ist</strong><br>
<code>rm temp.txt</code><br>
<code>ls</code><br>
→ Löscht die Datei, ls zeigt dass sie nicht mehr existiert<br><br>

✅ <strong>2. Dateien auflisten, dann bestimmte löschen</strong><br>
<code>ls *.log</code><br>
<code>rm *.log</code><br>
→ Zeigt alle .log-Dateien, rm löscht sie alle<br><br>

✅ <strong>3. In einen Ordner wechseln, löschen, zurückkehren</strong><br>
<code>cd temp/</code><br>
<code>rm old_file.txt</code><br>
<code>cd ..</code><br>
→ Wechselt ins temp-Verzeichnis, löscht eine Datei, kehrt zurück<br><br>

✅ <strong>4. Datei kopieren, dann Original löschen</strong><br>
<code>cp important.txt backup/</code><br>
<code>rm important.txt</code><br>
→ Kopiert die Datei ins Backup, löscht dann das Original<br><br>

✅ <strong>5. Liste speichern, dann Dateien löschen</strong><br>
<code>ls > dateien_liste.txt</code><br>
<code>rm temp*.txt</code><br>
→ Speichert die Liste, löscht dann alle temp*.txt Dateien
          `,
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `rm datei.txt`?",
              options: [
                "Verschiebt datei.txt in den Papierkorb",
                "Löscht datei.txt endgültig",
                "Kopiert datei.txt",
                "Zeigt datei.txt an",
              ],
              correctIndex: 1,
              explanation:
                "`rm` löscht Dateien endgültig – es gibt keinen Papierkorb in der Shell.",
            },
            {
              level: "mittel",
              prompt:
                "Wie kannst du sicherstellen, dass `rm` vor dem Löschen fragt?",
              options: [
                "rm -f datei.txt",
                "rm -i datei.txt",
                "rm -r datei.txt",
                "rm --ask datei.txt",
              ],
              correctIndex: 1,
              explanation:
                "`rm -i` (interactive) fragt vor jedem Löschen nach – viel sicherer.",
            },
            {
              level: "schwer",
              prompt: "Was ist der Unterschied zwischen `rm -f` und `rm -i`?",
              options: [
                "Beide fragen nach",
                "-f erzwingt Löschen ohne Nachfrage, -i fragt nach",
                "-f fragt nach, -i nicht",
                "Kein Unterschied",
              ],
              correctIndex: 1,
              explanation:
                "`-f` (force) erzwingt das Löschen ohne Nachfrage, `-i` (interactive) fragt nach – genau das Gegenteil.",
            },
          ],
        },

        rm_r: {
          title: "rm -r",
          description: "Löscht Ordner rekursiv inkl. aller Inhalte.",
          explanation: "Ordner rekursiv löschen.",
          simpleExample: "rm -r Backup/",
          detail:
            "rm -rf (force) ist extrem gefährlich – löscht ohne Nachfragen, auch schreibgeschütztes.",
          complexExample: "rm -r build/ dist/ .cache/ 2>/dev/null",
          complexExampleExplanation: [
            {
              line: "rm -r build/ dist/ .cache/ 2>/dev/null",
              explanation:
                "Löscht rekursiv (-r) drei Ordner, 2>/dev/null leitet Fehler (stderr) ins Nichts um, sodass Fehlermeldungen (z.B. wenn Ordner nicht existieren) nicht angezeigt werden",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `rm -r Ordner/`?",
              options: [
                "Löscht nur den leeren Ordner",
                "Löscht den Ordner rekursiv mit allen Inhalten",
                "Kopiert den Ordner",
                "Zeigt den Ordner an",
              ],
              correctIndex: 1,
              explanation:
                "`-r` (recursive) löscht den gesamten Ordner inklusive aller Unterordner und Dateien.",
            },
            {
              level: "mittel",
              prompt: "Warum ist `rm -rf` besonders gefährlich?",
              options: [
                "Es ist langsam",
                "Es löscht ohne Nachfrage, auch schreibgeschützte Dateien",
                "Es kopiert Dateien",
                "Es zeigt zu viele Informationen",
              ],
              correctIndex: 1,
              explanation:
                "`-rf` kombiniert rekursiv + force – löscht alles ohne Nachfrage, auch schreibgeschützte Dateien. Sehr gefährlich!",
            },
            {
              level: "schwer",
              prompt: "Was macht `rm -r build/ dist/ .cache/ 2>/dev/null`?",
              options: [
                "Löscht die Ordner und zeigt Fehler",
                "Löscht die Ordner und versteckt Fehler (wenn Ordner nicht existieren)",
                "Kopiert die Ordner",
                "Zeigt die Ordner an",
              ],
              correctIndex: 1,
              explanation:
                "`2>/dev/null` leitet Fehler (stderr) um, sodass Fehlermeldungen nicht angezeigt werden, wenn Ordner nicht existieren.",
            },
          ],
        },

        cat: {
          title: "cat",
          description: "Gibt den Inhalt einer Datei auf stdout aus.",
          explanation: "Datei anzeigen.",
          simpleExample: "cat notes.txt",
          detail:
            "Mehrere Dateien werden hintereinander ausgegeben: cat a.txt b.txt.",
          complexExample: "cat header.conf main.conf footer.conf > full.conf",
          complexExampleExplanation: [
            {
              line: "cat header.conf main.conf footer.conf > full.conf",
              explanation:
                "cat liest drei Dateien nacheinander und gibt sie hintereinander aus, > leitet die kombinierte Ausgabe in full.conf um (überschreibt die Datei)",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `cat datei.txt`?",
              options: [
                "Kopiert datei.txt",
                "Zeigt den Inhalt von datei.txt an",
                "Löscht datei.txt",
                "Erstellt datei.txt",
              ],
              correctIndex: 1,
              explanation:
                "`cat` (concatenate) gibt den Inhalt einer Datei auf stdout aus.",
            },
            {
              level: "mittel",
              prompt: "Was macht `cat a.txt b.txt`?",
              options: [
                "Zeigt nur a.txt",
                "Zeigt a.txt und b.txt hintereinander",
                "Vergleicht die Dateien",
                "Löscht beide Dateien",
              ],
              correctIndex: 1,
              explanation:
                "`cat` kann mehrere Dateien verketten und gibt sie hintereinander aus.",
            },
            {
              level: "schwer",
              prompt: "Wie fügst du mehrere Config-Dateien zu einer zusammen?",
              options: [
                "cat header.conf main.conf footer.conf > full.conf",
                "cat header.conf main.conf footer.conf < full.conf",
                "cat header.conf | main.conf | footer.conf",
                "cat header.conf && main.conf && footer.conf",
              ],
              correctIndex: 0,
              explanation:
                "Mit `>` wird die Ausgabe in eine Datei umgeleitet – alle drei Dateien werden zu `full.conf` zusammengefügt.",
            },
          ],
        },

        sort: {
          title: "sort",
          description: "Sortiert Zeilen alphabetisch.",
          explanation: "alphabetisch sortieren.",
          simpleExample: "sort namen.txt",
          detail: "Mit -r wird absteigend sortiert.",
          complexExample: "sort namen.txt | uniq > namen_uniq.txt",
          complexExampleExplanation: [
            {
              line: "sort namen.txt | uniq > namen_uniq.txt",
              explanation:
                "sort sortiert die Zeilen alphabetisch, | leitet an uniq weiter (entfernt aufeinanderfolgende Duplikate), > speichert das Ergebnis in namen_uniq.txt",
            },
          ],
          additionalExamples: `
✅ <strong>1. Datei anzeigen, dann sortieren</strong><br>
<code>cat namen.txt</code><br>
<code>sort namen.txt</code><br>
→ cat zeigt den Inhalt, sort zeigt die sortierte Version<br><br>

✅ <strong>2. Nach bestimmten Zeilen suchen, dann sortieren</strong><br>
<code>grep "admin" users.txt</code><br>
<code>grep "admin" users.txt | sort</code><br>
→ grep findet alle "admin" Zeilen, sort sortiert sie alphabetisch<br><br>

✅ <strong>3. Mehrere Dateien zusammenfügen und sortieren</strong><br>
<code>cat liste1.txt liste2.txt</code><br>
<code>cat liste1.txt liste2.txt | sort</code><br>
→ cat zeigt beide Dateien zusammen, sort sortiert das kombinierte Ergebnis<br><br>

✅ <strong>4. Sortieren und nur die ersten 10 Zeilen zeigen</strong><br>
<code>sort große_liste.txt</code><br>
<code>sort große_liste.txt | head -n 10</code><br>
→ Sortiert die Liste, head zeigt nur die ersten 10 Zeilen<br><br>

✅ <strong>5. Sortieren, Duplikate entfernen, dann zählen</strong><br>
<code>sort emails.txt | uniq</code><br>
<code>sort emails.txt | uniq | wc -l</code><br>
→ Sortiert, entfernt Duplikate mit uniq, wc -l zählt die eindeutigen Zeilen
          `,
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `sort datei.txt`?",
              options: [
                "Zeigt datei.txt an",
                "Sortiert die Zeilen alphabetisch",
                "Löscht datei.txt",
                "Kopiert datei.txt",
              ],
              correctIndex: 1,
              explanation: "`sort` sortiert Zeilen alphabetisch (aufsteigend).",
            },
            {
              level: "mittel",
              prompt: "Wie sortierst du absteigend (rückwärts)?",
              options: [
                "sort -d datei.txt",
                "sort -r datei.txt",
                "sort -n datei.txt",
                "sort --reverse datei.txt",
              ],
              correctIndex: 1,
              explanation:
                "`sort -r` (reverse) sortiert absteigend – von Z nach A.",
            },
            {
              level: "schwer",
              prompt: "Was macht `sort namen.txt | uniq > namen_uniq.txt`?",
              options: [
                "Sortiert und zeigt Duplikate",
                "Sortiert, entfernt Duplikate und speichert in namen_uniq.txt",
                "Löscht namen.txt",
                "Kopiert namen.txt",
              ],
              correctIndex: 1,
              explanation:
                "Zuerst sortieren (damit Duplikate zusammen sind), dann `uniq` entfernt Duplikate, `>` speichert das Ergebnis.",
            },
          ],
        },

        sort_n: {
          title: "sort -n",
          description:
            "Sortiert Zeilen numerisch (Zahlen korrekt, nicht als Text).",
          explanation: "numerisch sortieren.",
          simpleExample: "sort -n zahlen.txt",
          detail:
            "Mit -n wird z. B. 2 vor 10 einsortiert (bei normalem sort käme 10 vor 2).",
          complexExample: "sort -n zahlen.txt | tail -n 5",
          complexExampleExplanation: [
            {
              line: "sort -n zahlen.txt | tail -n 5",
              explanation:
                "sort -n sortiert numerisch (nicht alphabetisch, damit 2 vor 10 kommt), | leitet an tail -n 5 weiter, das die letzten 5 Zeilen zeigt (also die 5 größten Zahlen)",
            },
          ],
          additionalExamples: `
✅ <strong>1. Datei anzeigen, dann numerisch sortieren</strong><br>
<code>cat zahlen.txt</code><br>
<code>sort -n zahlen.txt</code><br>
→ cat zeigt den Inhalt, sort -n sortiert Zahlen korrekt (2 vor 10)<br><br>

✅ <strong>2. Normal sortieren vs. numerisch sortieren</strong><br>
<code>sort zahlen.txt</code><br>
<code>sort -n zahlen.txt</code><br>
→ sort sortiert als Text (10 vor 2), sort -n sortiert numerisch (2 vor 10)<br><br>

✅ <strong>3. Sortieren und dann die größten Zahlen zeigen</strong><br>
<code>sort -n zahlen.txt</code><br>
<code>sort -n zahlen.txt | tail -n 5</code><br>
→ Sortiert numerisch, tail zeigt die letzten 5 (die größten)<br><br>

✅ <strong>4. Sortieren, Duplikate entfernen, dann zählen</strong><br>
<code>sort -n zahlen.txt | uniq</code><br>
<code>sort -n zahlen.txt | uniq | wc -l</code><br>
→ Sortiert numerisch, entfernt Duplikate, wc -l zählt eindeutige Zahlen<br><br>

✅ <strong>5. Mehrere Dateien kombinieren und numerisch sortieren</strong><br>
<code>cat liste1.txt liste2.txt | sort -n</code><br>
→ Kombiniert beide Dateien, sort -n sortiert alle Zahlen korrekt
          `,
          questions: [
            {
              level: "leicht",
              prompt: "Was ist der Unterschied zwischen `sort` und `sort -n`?",
              options: [
                "Kein Unterschied",
                "sort sortiert alphabetisch, sort -n numerisch",
                "sort -n ist schneller",
                "sort -n funktioniert nicht",
              ],
              correctIndex: 1,
              explanation:
                "`sort` sortiert als Text (10 kommt vor 2), `sort -n` sortiert numerisch (2 kommt vor 10).",
            },
            {
              level: "mittel",
              prompt: "Wie sortierst du eine Datei mit Zahlen numerisch?",
              options: [
                "sort zahlen.txt",
                "sort -n zahlen.txt",
                "sort --number zahlen.txt",
                "sort -r zahlen.txt",
              ],
              correctIndex: 1,
              explanation:
                "`sort -n` sortiert numerisch – wichtig für Zahlen, damit 2 vor 10 kommt.",
            },
            {
              level: "schwer",
              prompt: "Was macht `sort -n zahlen.txt | tail -n 5`?",
              options: [
                "Zeigt die ersten 5 Zahlen",
                "Zeigt die 5 größten Zahlen",
                "Löscht die letzten 5 Zeilen",
                "Kopiert die Datei",
              ],
              correctIndex: 1,
              explanation:
                "Sortiert numerisch (kleinste zuerst), dann `tail -n 5` zeigt die letzten 5 Zeilen = die 5 größten Zahlen.",
            },
          ],
        },

        uniq: {
          title: "uniq",
          description: "Entfernt doppelte aufeinanderfolgende Zeilen.",
          explanation: "entfernt aufeinanderfolgende Duplikate.",
          simpleExample: "uniq liste.txt",
          detail:
            "Oft mit sort kombiniert, weil nur direkt aufeinanderfolgende Duplikate erkannt werden.",
          complexExample: "sort namen.txt | uniq -c | sort -n",
          complexExampleExplanation: [
            {
              line: "sort namen.txt | uniq -c | sort -n",
              explanation:
                "sort sortiert alphabetisch, | leitet an uniq -c weiter (zählt Vorkommen jedes Namens), | leitet an sort -n weiter (sortiert nach Anzahl, kleinste zuerst)",
            },
          ],
          additionalExamples: `
✅ <strong>1. Datei anzeigen, dann Duplikate entfernen</strong><br>
<code>cat liste.txt</code><br>
<code>uniq liste.txt</code><br>
→ cat zeigt den Inhalt, uniq entfernt aufeinanderfolgende Duplikate<br><br>

✅ <strong>2. Erst sortieren, dann Duplikate entfernen</strong><br>
<code>sort namen.txt</code><br>
<code>sort namen.txt | uniq</code><br>
→ Sortiert die Namen, uniq entfernt dann alle Duplikate (weil sie zusammen sind)<br><br>

✅ <strong>3. Mehrere Dateien kombinieren, sortieren, Duplikate entfernen</strong><br>
<code>cat file1.txt file2.txt | sort</code><br>
<code>cat file1.txt file2.txt | sort | uniq</code><br>
→ Kombiniert beide Dateien, sort sortiert, uniq entfernt Duplikate<br><br>

✅ <strong>4. Nach etwas suchen, dann Duplikate entfernen</strong><br>
<code>grep "user" log.txt</code><br>
<code>grep "user" log.txt | sort | uniq</code><br>
→ Findet alle "user" Einträge, sort sortiert, uniq entfernt doppelte Zeilen<br><br>

✅ <strong>5. Duplikate entfernen und dann zählen</strong><br>
<code>sort emails.txt | uniq</code><br>
<code>sort emails.txt | uniq | wc -l</code><br>
→ Sortiert, entfernt Duplikate, wc -l zählt wie viele eindeutige Einträge es gibt
          `,
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `uniq datei.txt`?",
              options: [
                "Sortiert die Datei",
                "Entfernt aufeinanderfolgende doppelte Zeilen",
                "Kopiert die Datei",
                "Löscht die Datei",
              ],
              correctIndex: 1,
              explanation:
                "`uniq` entfernt nur direkt aufeinanderfolgende Duplikate – daher oft mit `sort` kombiniert.",
            },
            {
              level: "mittel",
              prompt: "Warum wird `uniq` oft mit `sort` kombiniert?",
              options: [
                "Weil sort schneller ist",
                "Weil uniq nur aufeinanderfolgende Duplikate erkennt",
                "Weil sort mehr Funktionen hat",
                "Weil uniq nicht funktioniert",
              ],
              correctIndex: 1,
              explanation:
                "`uniq` erkennt nur direkt aufeinanderfolgende Duplikate. `sort` bringt alle Duplikate zusammen, dann kann `uniq` sie entfernen.",
            },
            {
              level: "schwer",
              prompt: "Was macht `sort namen.txt | uniq -c | sort -n`?",
              options: [
                "Zeigt nur eindeutige Namen",
                "Sortiert, zählt Vorkommen jedes Namens, sortiert nach Häufigkeit",
                "Löscht Duplikate",
                "Kopiert die Datei",
              ],
              correctIndex: 1,
              explanation:
                "Sortiert → `uniq -c` zählt Vorkommen → `sort -n` sortiert nach Anzahl (häufigste zuletzt).",
            },
          ],
        },

        find_name: {
          title: "find . -name",
          description:
            "Sucht rekursiv nach Dateien/Ordnern mit Namen, der zum Muster passt.",
          explanation: "nach Name suchen.",
          simpleExample: 'find . -name "notes.txt"',
          detail: 'Muster können Wildcards enthalten: find . -name "*.log".',
          complexExample: 'find . -name "*.log" -type f -exec rm {} \\;',
          complexExampleExplanation: [
            {
              line: 'find . -name "*.log" -type f -exec rm {} \\;',
              explanation:
                "find sucht ab dem aktuellen Verzeichnis (.) nach Dateien (-type f) mit Namen *.log, -exec rm {} \\; führt rm für jede gefundene Datei aus ({} wird durch den Dateinamen ersetzt)",
            },
          ],
          additionalExamples: `
✅ <strong>1. Alle .config-Dateien im aktuellen Verzeichnis finden</strong><br>
<code>find . -name "*.config"</code><br><br>

✅ <strong>2. .config-Dateien nur im aktuellen Verzeichnis (ohne Unterordner)</strong><br>
<code>find . -maxdepth 1 -name "*.config"</code><br><br>

✅ <strong>3. Nur reguläre Dateien (keine Ordner, keine Symlinks)</strong><br>
<code>find . -type f -name "*.config"</code><br><br>

✅ <strong>4. Rekursiv und case-insensitive (.CONFIG, .Config usw.)</strong><br>
<code>find . -iname "*.config"</code><br><br>

✅ <strong>5. Alle .config-Dateien + Dateigröße anzeigen</strong><br>
<code>find . -type f -name "*.config" -exec ls -lh {} \\;</code><br><br>

✅ <strong>6. Nur die Anzahl der .config-Dateien</strong><br>
<code>find . -type f -name "*.config" | wc -l</code><br><br>

✅ <strong>7. Unterhalb eines bestimmten Verzeichnisses (z. B. /etc)</strong><br>
<code>find /etc -type f -name "*.config"</code><br><br>

🛑 <strong>Gefährliche Varianten (nur Info, nicht nutzen!)</strong><br>
<em>(Niemals löschen ohne exakt getestetes Pattern)</em><br><br>
<code>find . -name "*.config" -delete</code><br>
→ sehr riskant, löscht sofort.<br><br>

💡 <strong>Safe Default für dich:</strong><br>
Wenn du einfach alle .config-Dateien finden möchtest:<br>
<code>find . -type f -name "*.config"</code>
          `,
          questions: [
            {
              level: "leicht",
              prompt: 'Was macht `find . -name "datei.txt"`?',
              options: [
                "Erstellt datei.txt",
                "Sucht rekursiv nach datei.txt",
                "Löscht datei.txt",
                "Kopiert datei.txt",
              ],
              correctIndex: 1,
              explanation:
                "`find . -name` sucht rekursiv ab dem aktuellen Verzeichnis (.) nach Dateien/Ordnern mit diesem Namen.",
            },
            {
              level: "mittel",
              prompt: "Wie suchst du nach allen .log-Dateien?",
              options: [
                'find . -name "log"',
                'find . -name "*.log"',
                "find . -type log",
                "find . -ext log",
              ],
              correctIndex: 1,
              explanation:
                'Mit Wildcards: `find . -name "*.log"` findet alle Dateien, die mit .log enden.',
            },
            {
              level: "schwer",
              prompt:
                'Was macht `find . -name "*.log" -type f -exec rm {} \\;`?',
              options: [
                "Zeigt alle .log-Dateien",
                "Löscht alle .log-Dateien rekursiv",
                "Kopiert alle .log-Dateien",
                "Erstellt .log-Dateien",
              ],
              correctIndex: 1,
              explanation:
                "Findet alle .log-Dateien (`-type f` = nur Dateien), dann `-exec rm {} \\;` löscht jede gefundene Datei.",
            },
          ],
        },

        find_maxdepth: {
          title: "find . -maxdepth 1 -type d",
          description:
            "Listet nur Ordner im aktuellen Verzeichnis (keine Unterordner).",
          explanation: "nur Ordner im aktuellen Verzeichnis.",
          simpleExample: "find . -maxdepth 1 -type d",
          detail: 'Mit ! -name "." schließt du das aktuelle Verzeichnis aus.',
          complexExample:
            'find . -maxdepth 1 -type d ! -name "." -printf "%f\\n" > folders.txt',
          complexExampleExplanation: [
            {
              line: 'find . -maxdepth 1 -type d ! -name "." -printf "%f\\n" > folders.txt',
              explanation:
                'find sucht nur im aktuellen Verzeichnis (-maxdepth 1) nach Ordnern (-type d), ! -name "." schließt das aktuelle Verzeichnis aus, -printf "%f\\n" gibt nur den Dateinamen (ohne Pfad) aus, > speichert in folders.txt',
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `find . -maxdepth 1 -type d`?",
              options: [
                "Findet alle Ordner rekursiv",
                "Findet nur Ordner im aktuellen Verzeichnis (keine Unterordner)",
                "Findet nur Dateien",
                "Löscht Ordner",
              ],
              correctIndex: 1,
              explanation:
                "`-maxdepth 1` begrenzt die Suche auf das aktuelle Verzeichnis, `-type d` sucht nur nach Ordnern.",
            },
            {
              level: "mittel",
              prompt:
                "Wie schließt du das aktuelle Verzeichnis (.) aus der Suche aus?",
              options: [
                'find . -maxdepth 1 -type d -name "."',
                'find . -maxdepth 1 -type d ! -name "."',
                "find . -maxdepth 0 -type d",
                "Das geht nicht",
              ],
              correctIndex: 1,
              explanation:
                'Mit `! -name "."` (NOT name) schließt du das aktuelle Verzeichnis aus.',
            },
            {
              level: "schwer",
              prompt:
                'Was macht `find . -maxdepth 1 -type d ! -name "." -printf "%f\\n" > folders.txt`?',
              options: [
                "Zeigt alle Ordner",
                "Speichert nur die Ordnernamen (ohne Pfad) in folders.txt",
                "Löscht alle Ordner",
                "Kopiert alle Ordner",
              ],
              correctIndex: 1,
              explanation:
                'Findet Ordner, schließt . aus, `-printf "%f\\n"` gibt nur den Dateinamen (ohne Pfad) aus, `>` speichert in folders.txt.',
            },
          ],
        },

        ls_R: {
          title: "ls -R",
          description:
            "Listet den gesamten Verzeichnisbaum rekursiv (alle Ordner und Dateien darunter).",
          explanation:
            "Listet den gesamten Verzeichnisbaum rekursiv (alle Ordner und Dateien darunter).",
          simpleExample: "ls -R",
          detail:
            "Ohne Filter sehr unübersichtlich → wird oft mit grep kombiniert.",
          complexExample: 'ls -R | grep ":$"',
          complexExampleExplanation: [
            {
              line: 'ls -R | grep ":$"',
              explanation:
                'ls -R listet rekursiv alle Dateien und Ordner, | leitet an grep weiter, ":$" filtert nur Zeilen, die mit einem Doppelpunkt enden (Ordner werden von ls -R mit : am Ende angezeigt)',
            },
          ],
          additionalExamples: `
✅ <strong>1. Normale Liste vs. rekursive Liste</strong><br>
<code>ls</code><br>
<code>ls -R</code><br>
→ ls zeigt nur das aktuelle Verzeichnis, ls -R zeigt alles rekursiv<br><br>

✅ <strong>2. Rekursive Liste speichern und dann anzeigen</strong><br>
<code>ls -R > alle_struktur.txt</code><br>
<code>cat alle_struktur.txt</code><br>
→ Speichert die gesamte Struktur in eine Datei, cat zeigt den Inhalt<br><br>

✅ <strong>3. Nach bestimmten Dateien suchen in der rekursiven Liste</strong><br>
<code>ls -R</code><br>
<code>ls -R | grep ".txt$"</code><br>
→ Zeigt alles rekursiv, grep filtert nur .txt-Dateien<br><br>

✅ <strong>4. Nur Ordner aus der rekursiven Liste zeigen</strong><br>
<code>ls -R</code><br>
<code>ls -R | grep ":$"</code><br>
→ Zeigt alles rekursiv, grep filtert nur Ordner (endet mit :)<br><br>

✅ <strong>5. Rekursive Liste sortieren und dann begrenzen</strong><br>
<code>ls -R | sort</code><br>
<code>ls -R | sort | head -n 20</code><br>
→ Sortiert die rekursive Liste alphabetisch, head zeigt nur die ersten 20 Einträge
          `,
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `ls -R`?",
              options: [
                "Listet nur das aktuelle Verzeichnis",
                "Listet den gesamten Verzeichnisbaum rekursiv",
                "Löscht alle Dateien",
                "Kopiert alle Dateien",
              ],
              correctIndex: 1,
              explanation:
                "`-R` (recursive) listet alle Dateien und Ordner rekursiv durch alle Unterordner.",
            },
            {
              level: "mittel",
              prompt: "Warum wird `ls -R` oft mit `grep` kombiniert?",
              options: [
                "Weil es schneller ist",
                "Weil die Ausgabe ohne Filter sehr unübersichtlich ist",
                "Weil grep mehr Funktionen hat",
                "Weil ls -R nicht funktioniert",
              ],
              correctIndex: 1,
              explanation:
                "Die rekursive Ausgabe kann sehr lang sein – `grep` filtert nach bestimmten Mustern.",
            },
            {
              level: "schwer",
              prompt: "Wie zeigst du nur Ordner im gesamten Verzeichnisbaum?",
              options: [
                "ls -R | grep files",
                'ls -R | grep ":$"',
                'ls -R | grep "^d"',
                "ls -R | sort",
              ],
              correctIndex: 1,
              explanation:
                '`ls -R` zeigt Ordner mit `:` am Ende an – `grep ":$"` filtert nur diese Zeilen.',
            },
          ],
        },

        ls_aR: {
          title: "ls -aR",
          description:
            "Rekursives Auflisten aller Dateien UND versteckter Dateien/Ordner.",
          explanation:
            "Rekursives Auflisten aller Dateien UND versteckter Dateien/Ordner.",
          simpleExample: "ls -aR",
          detail: "Zeigt ., .., .git, .config, usw. in jedem Unterordner.",
          complexExample: 'ls -aR ~ | grep "^\\." | wc -l',
          complexExampleExplanation: [
            {
              line: 'ls -aR ~ | grep "^\\." | wc -l',
              explanation:
                "ls -aR listet rekursiv alle Dateien im Home-Verzeichnis (inkl. versteckter), | leitet an grep weiter (filtert nur Zeilen die mit . beginnen), | leitet an wc -l weiter (zählt die Anzahl der Zeilen/Dateien)",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Was zeigt `ls -aR` zusätzlich zu `ls -R`?",
              options: [
                "Nur größere Dateien",
                "Versteckte Dateien und Ordner (beginnen mit .)",
                "Nur ausführbare Dateien",
                "Nur Ordner",
              ],
              correctIndex: 1,
              explanation:
                "`-a` zeigt versteckte Dateien, `-R` rekursiv – kombiniert: alle versteckten Dateien in allen Unterordnern.",
            },
            {
              level: "mittel",
              prompt: "Was zeigt `ls -aR` in jedem Unterordner?",
              options: [
                "Nur .",
                "Nur ..",
                "., .., .git, .config, usw.",
                "Nur Dateien",
              ],
              correctIndex: 2,
              explanation:
                "`-aR` zeigt in jedem Unterordner auch versteckte Einträge wie `.`, `..`, `.git`, `.config` etc.",
            },
            {
              level: "schwer",
              prompt:
                "Wie zählst du alle versteckten Dateien im Home-Verzeichnis?",
              options: [
                "ls -aR ~ | wc -l",
                'ls -aR ~ | grep "^\\." | wc -l',
                'ls -R ~ | grep "^\\."',
                'find ~ -name ".*"',
              ],
              correctIndex: 1,
              explanation:
                '`ls -aR ~` listet alles rekursiv, `grep "^\\."` filtert nur versteckte Dateien (beginnen mit .), `wc -l` zählt.',
            },
          ],
        },

        tree: {
          title: "tree",
          description: "Zeigt Verzeichnisstruktur in Baumform.",
          explanation: "Zeigt Verzeichnisstruktur in Baumform.",
          simpleExample: "tree",
          detail: "Wird oft manuell installiert (sudo apt install tree).",
          complexExample: "tree -d ~/Projects",
          complexExampleExplanation: [
            {
              line: "tree -d ~/Projects",
              explanation:
                "Zeigt die Verzeichnisstruktur von ~/Projects in Baumform, -d zeigt nur Ordner (directories), keine Dateien",
            },
          ],
          additionalExamples: `
✅ <strong>1. Normale Liste vs. Baumstruktur</strong><br>
<code>ls</code><br>
<code>tree</code><br>
→ ls zeigt flache Liste, tree zeigt hierarchische Struktur<br><br>

✅ <strong>2. Baumstruktur speichern und dann anzeigen</strong><br>
<code>tree > struktur.txt</code><br>
<code>cat struktur.txt</code><br>
→ Speichert die Baumstruktur in eine Datei, cat zeigt den Inhalt<br><br>

✅ <strong>3. In einen Ordner wechseln und Baumstruktur zeigen</strong><br>
<code>cd projects</code><br>
<code>tree</code><br>
→ Wechselt ins projects-Verzeichnis, zeigt die Struktur dort<br><br>

✅ <strong>4. Baumstruktur begrenzen und dann speichern</strong><br>
<code>tree -L 2</code><br>
<code>tree -L 2 > struktur_2_ebenen.txt</code><br>
→ Zeigt nur 2 Ebenen, speichert das Ergebnis<br><br>

✅ <strong>5. Baumstruktur anzeigen und dann nach etwas suchen</strong><br>
<code>tree</code><br>
<code>tree | grep "config"</code><br>
→ Zeigt die Struktur, grep filtert nur Zeilen mit "config"
          `,
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `tree`?",
              options: [
                "Löscht Bäume",
                "Zeigt Verzeichnisstruktur in Baumform",
                "Kopiert Verzeichnisse",
                "Sortiert Dateien",
              ],
              correctIndex: 1,
              explanation:
                "`tree` zeigt die Verzeichnisstruktur als visuellen Baum – sehr übersichtlich.",
            },
            {
              level: "mittel",
              prompt: "Was musst du tun, wenn `tree` nicht verfügbar ist?",
              options: [
                "Nichts, es ist immer installiert",
                "Manuell installieren: sudo apt install tree",
                "Es gibt keinen Ersatz",
                "Es funktioniert automatisch",
              ],
              correctIndex: 1,
              explanation:
                "`tree` ist nicht standardmäßig installiert – muss mit `sudo apt install tree` (oder ähnlich) installiert werden.",
            },
            {
              level: "schwer",
              prompt: "Wie zeigst du nur Ordner in der Baumstruktur?",
              options: ["tree -f", "tree -d", "tree -a", "tree -l"],
              correctIndex: 1,
              explanation:
                "`tree -d` (directory-only) zeigt nur Ordner, keine Dateien – perfekt für Strukturübersicht.",
            },
          ],
        },

        tree_d: {
          title: "tree -d",
          description: "Zeigt nur Ordner (directory-only mode).",
          explanation: "Zeigt nur Ordner (directory-only mode).",
          simpleExample: "tree -d",
          detail: "Perfekt, um reinen Ordneraufbau zu sehen.",
          complexExample: "tree -d -L 2",
          complexExampleExplanation: [
            {
              line: "tree -d -L 2",
              explanation:
                "Zeigt nur Ordner (-d) in Baumform, -L 2 begrenzt die Tiefe auf 2 Ebenen (nur direkt sichtbare Ordner und deren Unterordner)",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `tree -d`?",
              options: [
                "Zeigt nur Dateien",
                "Zeigt nur Ordner",
                "Zeigt alles",
                "Löscht Ordner",
              ],
              correctIndex: 1,
              explanation:
                "`-d` steht für 'directory-only' – zeigt nur Ordner, keine Dateien.",
            },
            {
              level: "mittel",
              prompt: "Wann ist `tree -d` besonders nützlich?",
              options: [
                "Wenn man Dateien sehen will",
                "Wenn man nur den reinen Ordneraufbau sehen will",
                "Wenn man Dateien löschen will",
                "Wenn man Dateien kopieren will",
              ],
              correctIndex: 1,
              explanation:
                "`tree -d` ist perfekt, um die reine Verzeichnisstruktur ohne Dateien zu überblicken.",
            },
            {
              level: "schwer",
              prompt: "Wie begrenzt du die Tiefe auf 2 Ebenen?",
              options: [
                "tree -d -L 2",
                "tree -d -d 2",
                "tree -d -max 2",
                "tree -d 2",
              ],
              correctIndex: 0,
              explanation:
                "`-L 2` begrenzt die Tiefe auf 2 Ebenen – kombiniert mit `-d` nur Ordner bis Ebene 2.",
            },
          ],
        },

        tree_L: {
          title: "tree -L",
          description: "Begrenzt die Tiefe der rekursiven Baumdarstellung.",
          explanation: "Begrenzt die Tiefe der rekursiven Baumdarstellung.",
          simpleExample: "tree -L 1",
          detail: "Hilft, tiefe Strukturen übersichtlich zu halten.",
          complexExample: "sudo tree -L 3 /",
          complexExampleExplanation: [
            {
              line: "sudo tree -L 3 /",
              explanation:
                "sudo gibt Root-Rechte, tree zeigt die Verzeichnisstruktur des Wurzelverzeichnisses (/), -L 3 begrenzt die Tiefe auf 3 Ebenen (benötigt sudo für Systemverzeichnisse)",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `tree -L 1`?",
              options: [
                "Zeigt nur die erste Ebene",
                "Zeigt alle Ebenen",
                "Löscht die erste Ebene",
                "Kopiert die erste Ebene",
              ],
              correctIndex: 0,
              explanation:
                "`-L 1` begrenzt die Ausgabe auf die erste Ebene – nur direkt sichtbare Ordner/Dateien.",
            },
            {
              level: "mittel",
              prompt: "Warum ist `tree -L` nützlich?",
              options: [
                "Weil es schneller ist",
                "Weil es tiefe Strukturen übersichtlich hält",
                "Weil es mehr zeigt",
                "Weil es Dateien löscht",
              ],
              correctIndex: 1,
              explanation:
                "Bei sehr tiefen Verzeichnisstrukturen hilft `-L`, die Ausgabe übersichtlich zu begrenzen.",
            },
            {
              level: "schwer",
              prompt: "Wie zeigst du die obersten drei Ebenen des Systems?",
              options: [
                "tree -L 3 /",
                "tree -d 3 /",
                "tree -a 3 /",
                "tree 3 /",
              ],
              correctIndex: 0,
              explanation:
                "`sudo tree -L 3 /` zeigt die obersten 3 Ebenen des Wurzelverzeichnisses (benötigt sudo für Systemverzeichnisse).",
            },
          ],
        },

        echo: {
          title: "echo",
          description: "Gibt Text im Terminal aus.",
          explanation: "Gibt Text im Terminal aus.",
          simpleExample: 'echo "Hallo Welt"',
          detail: "Mit >> nützlich zum Schreiben in Logdateien.",
          complexExample: 'echo "Starte Backup am $(date)" >> backup.log',
          complexExampleExplanation: [
            {
              line: 'echo "Starte Backup am $(date)" >> backup.log',
              explanation:
                "echo gibt Text aus, $(date) wird durch das aktuelle Datum und die Uhrzeit ersetzt, >> hängt den Text an backup.log an (ohne Überschreibung)",
            },
          ],
          additionalExamples: `
✅ <strong>1. Text ausgeben und dann in eine Datei schreiben</strong><br>
<code>echo "Hallo"</code><br>
<code>echo "Hallo" > greeting.txt</code><br>
→ Erst zeigt echo den Text, dann schreibt > ihn in eine Datei<br><br>

✅ <strong>2. Text an eine Datei anhängen (statt überschreiben)</strong><br>
<code>echo "Zeile 1" > log.txt</code><br>
<code>echo "Zeile 2" >> log.txt</code><br>
→ > überschreibt, >> hängt an (beide Zeilen bleiben erhalten)<br><br>

✅ <strong>3. Mehrere Zeilen schreiben und dann anzeigen</strong><br>
<code>echo "Start" > status.txt</code><br>
<code>echo "Läuft" >> status.txt</code><br>
<code>cat status.txt</code><br>
→ Schreibt zwei Zeilen, cat zeigt den Inhalt<br><br>

✅ <strong>4. Text in Datei schreiben und dann den Ordner auflisten</strong><br>
<code>echo "Test" > test.txt</code><br>
<code>ls</code><br>
→ Erstellt eine Datei mit echo, ls zeigt dass sie existiert<br><br>

✅ <strong>5. Fehlerausgabe umleiten (statt normale Ausgabe)</strong><br>
<code>echo "Fehler!"</code><br>
<code>echo "Fehler!" > output.txt</code><br>
<code>echo "Fehler!" 2> error.txt</code><br>
→ > schreibt normale Ausgabe, 2> schreibt Fehlerausgabe
          `,
          questions: [
            {
              level: "leicht",
              prompt: 'Was macht `echo "Hallo"`?',
              options: [
                "Löscht Hallo",
                "Gibt 'Hallo' im Terminal aus",
                "Kopiert Hallo",
                "Erstellt eine Datei Hallo",
              ],
              correctIndex: 1,
              explanation:
                "`echo` gibt Text auf stdout aus – im Terminal sichtbar.",
            },
            {
              level: "mittel",
              prompt: "Wie schreibst du Text in eine Logdatei?",
              options: [
                'echo "Text" > log.txt',
                'echo "Text" >> log.txt',
                'echo "Text" | log.txt',
                'echo "Text" log.txt',
              ],
              correctIndex: 1,
              explanation:
                "Mit `>>` wird Text an die Datei angehängt – ideal für Logdateien, die wachsen sollen.",
            },
            {
              level: "schwer",
              prompt:
                'Was macht `echo "Starte Backup am $(date)" >> backup.log`?',
              options: [
                "Zeigt nur das Datum",
                "Schreibt 'Starte Backup am [aktuelles Datum]' in backup.log",
                "Löscht backup.log",
                "Kopiert backup.log",
              ],
              correctIndex: 1,
              explanation:
                "`$(date)` wird durch das aktuelle Datum ersetzt, dann wird der gesamte Text an backup.log angehängt.",
            },
          ],
        },

        redirect_overwrite: {
          title: ">",
          description: "Leitet die Ausgabe in eine Datei um (überschreibt).",
          explanation: "Leitet die Ausgabe in eine Datei um (überschreibt).",
          simpleExample: 'echo "Hallo" > info.txt',
          detail: "Achtung: überschreibt komplett ohne Warnung.",
          complexExample: "ls /etc > etc_contents.txt",
          complexExampleExplanation: [
            {
              line: "ls /etc > etc_contents.txt",
              explanation:
                "ls listet den Inhalt von /etc auf, > leitet die Ausgabe in etc_contents.txt um (überschreibt die Datei komplett, falls sie existiert)",
            },
          ],
          additionalExamples: `
✅ <strong>1. Text ausgeben vs. in Datei speichern</strong><br>
<code>echo "Hallo"</code><br>
<code>echo "Hallo" > greeting.txt</code><br>
→ Erst zeigt echo den Text, dann speichert > ihn in eine Datei<br><br>

✅ <strong>2. Dateiliste speichern und dann anzeigen</strong><br>
<code>ls</code><br>
<code>ls > dateien.txt</code><br>
<code>cat dateien.txt</code><br>
→ ls zeigt Dateien, > speichert die Liste, cat zeigt den Inhalt<br><br>

✅ <strong>3. Dateiinhalt kopieren in neue Datei</strong><br>
<code>cat original.txt</code><br>
<code>cat original.txt > backup.txt</code><br>
→ Zeigt den Inhalt, dann speichert > ihn in backup.txt<br><br>

✅ <strong>4. Nach etwas suchen und Ergebnisse speichern</strong><br>
<code>grep "Error" log.txt</code><br>
<code>grep "Error" log.txt > fehler.txt</code><br>
→ Findet Fehler, > speichert alle Treffer in fehler.txt<br><br>

✅ <strong>5. Mehrere Dateien kombinieren und speichern</strong><br>
<code>cat file1.txt file2.txt</code><br>
<code>cat file1.txt file2.txt > kombiniert.txt</code><br>
→ Zeigt beide Dateien zusammen, > speichert das kombinierte Ergebnis
          `,
          questions: [
            {
              level: "leicht",
              prompt: 'Was macht `echo "Text" > datei.txt`?',
              options: [
                "Hängt Text an datei.txt an",
                "Überschreibt datei.txt mit Text (oder erstellt die Datei)",
                "Zeigt Text nur im Terminal",
                "Löscht datei.txt",
              ],
              correctIndex: 1,
              explanation:
                "`>` überschreibt die Datei komplett oder erstellt sie, wenn sie nicht existiert.",
            },
            {
              level: "mittel",
              prompt: "Was passiert, wenn die Datei bereits existiert?",
              options: [
                "Es wird nachgefragt",
                "Die Datei wird komplett überschrieben ohne Warnung",
                "Die Datei wird gelöscht",
                "Nichts passiert",
              ],
              correctIndex: 1,
              explanation:
                "`>` überschreibt ohne Warnung – Vorsicht! Alle bisherigen Inhalte gehen verloren.",
            },
            {
              level: "schwer",
              prompt: "Was macht `ls /etc > etc_contents.txt`?",
              options: [
                "Zeigt /etc im Terminal",
                "Speichert die Liste von /etc in etc_contents.txt",
                "Löscht /etc",
                "Kopiert /etc",
              ],
              correctIndex: 1,
              explanation:
                "Die Ausgabe von `ls /etc` wird in die Datei etc_contents.txt umgeleitet (überschreibt sie).",
            },
          ],
        },

        redirect_append: {
          title: ">>",
          description: "Hängt die Ausgabe ans Ende einer Datei an.",
          explanation: "Hängt die Ausgabe ans Ende einer Datei an.",
          simpleExample: 'echo "Neue Zeile" >> log.txt',
          detail: "Datei wird nicht gelöscht wie bei >.",
          complexExample: 'echo "$(date): Prozess gestartet" >> system.log',
          complexExampleExplanation: [
            {
              line: 'echo "$(date): Prozess gestartet" >> system.log',
              explanation:
                "echo gibt Text aus, $(date) wird durch Datum/Uhrzeit ersetzt, >> hängt den Text am Ende von system.log an (bisheriger Inhalt bleibt erhalten)",
            },
          ],
          additionalExamples: `
✅ <strong>1. Überschreiben vs. Anhängen</strong><br>
<code>echo "Zeile 1" > log.txt</code><br>
<code>echo "Zeile 2" >> log.txt</code><br>
→ > überschreibt, >> hängt an (beide Zeilen bleiben erhalten)<br><br>

✅ <strong>2. Text anhängen und dann anzeigen</strong><br>
<code>echo "Neu" >> status.txt</code><br>
<code>cat status.txt</code><br>
→ Hängt Text an die Datei, cat zeigt den gesamten Inhalt<br><br>

✅ <strong>3. Liste speichern, dann weitere Einträge anhängen</strong><br>
<code>ls > dateien.txt</code><br>
<code>ls -a >> dateien.txt</code><br>
→ Speichert normale Liste, >> hängt versteckte Dateien an<br><br>

✅ <strong>4. Mehrere Zeilen nacheinander anhängen</strong><br>
<code>echo "Start" >> log.txt</code><br>
<code>echo "Mitte" >> log.txt</code><br>
<code>echo "Ende" >> log.txt</code><br>
→ Hängt drei Zeilen nacheinander an, alle bleiben erhalten<br><br>

✅ <strong>5. Suche-Ergebnisse anhängen statt überschreiben</strong><br>
<code>grep "Error" log1.txt > fehler.txt</code><br>
<code>grep "Error" log2.txt >> fehler.txt</code><br>
→ Speichert erste Suche, >> hängt zweite Suche an (kombiniert beide)
          `,
          questions: [
            {
              level: "leicht",
              prompt: "Was ist der Unterschied zwischen `>` und `>>`?",
              options: [
                "Kein Unterschied",
                "`>` überschreibt, `>>` hängt an",
                "`>>` ist schneller",
                "`>` funktioniert nicht",
              ],
              correctIndex: 1,
              explanation:
                "`>` überschreibt die Datei komplett, `>>` hängt neuen Inhalt am Ende an.",
            },
            {
              level: "mittel",
              prompt: "Was passiert mit dem bisherigen Inhalt bei `>>`?",
              options: [
                "Er wird gelöscht",
                "Er bleibt erhalten, neuer Inhalt wird angehängt",
                "Er wird überschrieben",
                "Nichts passiert",
              ],
              correctIndex: 1,
              explanation:
                "Bei `>>` bleibt der bisherige Inhalt erhalten – neuer Inhalt wird einfach angehängt.",
            },
            {
              level: "schwer",
              prompt:
                'Was macht `echo "$(date): Prozess gestartet" >> system.log`?',
              options: [
                "Überschreibt system.log",
                "Hängt '[Datum]: Prozess gestartet' an system.log an",
                "Löscht system.log",
                "Zeigt nur das Datum",
              ],
              correctIndex: 1,
              explanation:
                "Das aktuelle Datum wird eingefügt, dann wird der Text an system.log angehängt (ideal für Logs).",
            },
          ],
        },

        redirect_stderr: {
          title: "2>",
          description: "Leitet die Fehlerausgabe (stderr) in eine Datei.",
          explanation: "Leitet die Fehlerausgabe (stderr) in eine Datei.",
          simpleExample: "command 2> fehler.txt",
          detail: "Sehr nützlich, um Fehlermeldungen zu isolieren.",
          complexExample: 'find / -name "*.conf" 2> /tmp/find_errors.log',
          complexExampleExplanation: [
            {
              line: 'find / -name "*.conf" 2> /tmp/find_errors.log',
              explanation:
                "find sucht ab dem Wurzelverzeichnis (/) rekursiv nach .conf-Dateien, 2> leitet Fehler (stderr) in /tmp/find_errors.log um (normale Ausgabe bleibt im Terminal)",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `command 2> fehler.txt`?",
              options: [
                "Leitet stdout in fehler.txt",
                "Leitet stderr (Fehlerausgabe) in fehler.txt",
                "Löscht fehler.txt",
                "Kopiert fehler.txt",
              ],
              correctIndex: 1,
              explanation:
                "`2>` leitet stderr (Stream 2 = Fehlerausgabe) in die Datei um.",
            },
            {
              level: "mittel",
              prompt: "Warum ist `2>` nützlich?",
              options: [
                "Weil es schneller ist",
                "Weil es Fehlermeldungen isoliert und von normaler Ausgabe trennt",
                "Weil es mehr zeigt",
                "Weil es Dateien löscht",
              ],
              correctIndex: 1,
              explanation:
                "Fehlermeldungen werden isoliert – normale Ausgabe bleibt im Terminal, Fehler landen in der Datei.",
            },
            {
              level: "schwer",
              prompt:
                'Was macht `find / -name "*.conf" 2> /tmp/find_errors.log`?',
              options: [
                "Zeigt alle Fehler im Terminal",
                "Sucht nach .conf-Dateien, Fehler landen in /tmp/find_errors.log",
                "Löscht alle .conf-Dateien",
                "Kopiert alle .conf-Dateien",
              ],
              correctIndex: 1,
              explanation:
                "Sucht rekursiv nach .conf-Dateien, normale Ausgabe bleibt im Terminal, Fehler (z.B. Berechtigungsfehler) landen in der Logdatei.",
            },
          ],
        },

        whoami: {
          title: "whoami",
          description: "Zeigt den aktuellen Benutzer.",
          explanation: "Zeigt den aktuellen Benutzer.",
          simpleExample: "whoami → user",
          detail: "Wird oft in Scripts verwendet, um Berechtigungen zu prüfen.",
          complexExample:
            'echo "Dieses Script läuft als: $(whoami)" >> script.log',
          complexExampleExplanation: [
            {
              line: 'echo "Dieses Script läuft als: $(whoami)" >> script.log',
              explanation:
                "echo gibt Text aus, $(whoami) wird durch den aktuellen Benutzernamen ersetzt, >> hängt den Text an script.log an (für Logging/Debugging)",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `whoami`?",
              options: [
                "Zeigt alle Benutzer",
                "Zeigt den aktuellen Benutzer",
                "Löscht Benutzer",
                "Erstellt Benutzer",
              ],
              correctIndex: 1,
              explanation:
                "`whoami` zeigt den Namen des aktuell angemeldeten Benutzers.",
            },
            {
              level: "mittel",
              prompt: "Wofür wird `whoami` oft in Scripts verwendet?",
              options: [
                "Um Dateien zu löschen",
                "Um Berechtigungen zu prüfen",
                "Um Dateien zu kopieren",
                "Um Dateien zu sortieren",
              ],
              correctIndex: 1,
              explanation:
                "Scripts prüfen oft mit `whoami`, ob sie mit den richtigen Berechtigungen laufen.",
            },
            {
              level: "schwer",
              prompt:
                'Was macht `echo "Dieses Script läuft als: $(whoami)" >> script.log`?',
              options: [
                "Zeigt nur whoami",
                "Schreibt 'Dieses Script läuft als: [Benutzername]' in script.log",
                "Löscht script.log",
                "Kopiert script.log",
              ],
              correctIndex: 1,
              explanation:
                "`$(whoami)` wird durch den Benutzernamen ersetzt, dann wird der Text in script.log geschrieben.",
            },
          ],
        },

        chmod: {
          title: "chmod",
          description: "Ändert Dateirechte (read/write/execute).",
          explanation: "Ändert Dateirechte (read/write/execute).",
          simpleExample: "chmod +x script.sh",
          detail:
            "chmod 755 wird häufig für webserver-readable Scripts genutzt.",
          complexExample: "chmod u=rwx,go=rx meinprogramm",
          complexExampleExplanation: [
            {
              line: "chmod u=rwx,go=rx meinprogramm",
              explanation:
                "Setzt Rechte mit symbolischer Notation: u (user/Besitzer) = rwx (read/write/execute), go (group/others) = rx (read/execute), sehr präzise Kontrolle über Dateirechte",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `chmod +x script.sh`?",
              options: [
                "Löscht script.sh",
                "Macht script.sh ausführbar",
                "Kopiert script.sh",
                "Zeigt script.sh an",
              ],
              correctIndex: 1,
              explanation:
                "`+x` fügt Ausführungsrechte hinzu – die Datei kann dann mit `./script.sh` ausgeführt werden.",
            },
            {
              level: "mittel",
              prompt: "Was bedeutet `chmod 755`?",
              options: [
                "Nur lesen",
                "Besitzer: rwx, Gruppe/Andere: rx (häufig für webserver-readable Scripts)",
                "Nur schreiben",
                "Keine Rechte",
              ],
              correctIndex: 1,
              explanation:
                "755 = Besitzer: read/write/execute (7), Gruppe/Andere: read/execute (5) – Standard für ausführbare Scripts.",
            },
            {
              level: "schwer",
              prompt: "Was macht `chmod u=rwx,go=rx meinprogramm`?",
              options: [
                "Setzt Rechte für alle gleich",
                "Setzt Besitzer (u): rwx, Gruppe/Andere (go): rx",
                "Löscht alle Rechte",
                "Kopiert die Datei",
              ],
              correctIndex: 1,
              explanation:
                "Symbolische Notation: u (user) = rwx, go (group/others) = rx – sehr präzise Kontrolle.",
            },
          ],
        },

        chmod_R: {
          title: "chmod -R",
          description: "Ändert Rechte rekursiv für Ordner + Unterordner.",
          explanation: "Ändert Rechte rekursiv für Ordner + Unterordner.",
          simpleExample: "chmod -R 755 public/",
          detail: "Schnell sehr gefährlich, wenn im falschen Pfad ausgeführt.",
          complexExample: "chmod -R 700 ~/.ssh",
          complexExampleExplanation: [
            {
              line: "chmod -R 700 ~/.ssh",
              explanation:
                "Ändert Rechte rekursiv (-R) für .ssh und alle Inhalte, 700 bedeutet nur Besitzer hat alle Rechte (rwx), niemand sonst - perfekt für sensible Verzeichnisse wie SSH-Keys",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `chmod -R 755 public/`?",
              options: [
                "Ändert Rechte nur für public/",
                "Ändert Rechte rekursiv für public/ und alle Unterordner/Dateien",
                "Löscht public/",
                "Kopiert public/",
              ],
              correctIndex: 1,
              explanation:
                "`-R` (recursive) wendet die Rechteänderung auf den gesamten Verzeichnisbaum an.",
            },
            {
              level: "mittel",
              prompt: "Warum ist `chmod -R` gefährlich?",
              options: [
                "Weil es langsam ist",
                "Weil es schnell sehr gefährlich ist, wenn im falschen Pfad ausgeführt",
                "Weil es nichts macht",
                "Weil es Dateien kopiert",
              ],
              correctIndex: 1,
              explanation:
                "Im falschen Pfad (z.B. `/` statt `./`) werden Rechte systemweit geändert – sehr gefährlich!",
            },
            {
              level: "schwer",
              prompt: "Was macht `chmod -R 700 ~/.ssh`?",
              options: [
                "Macht .ssh für alle lesbar",
                "Setzt .ssh und alle Inhalte auf 700 (nur Besitzer: rwx)",
                "Löscht .ssh",
                "Kopiert .ssh",
              ],
              correctIndex: 1,
              explanation:
                "700 = nur Besitzer hat alle Rechte (rwx), niemand sonst – perfekt für sensible Verzeichnisse wie .ssh.",
            },
          ],
        },

        chown: {
          title: "chown",
          description: "Ändert den Besitzer einer Datei.",
          explanation: "Ändert den Besitzer einer Datei.",
          simpleExample: "sudo chown user file.txt",
          detail:
            "Die Kombination chown user:group file ändert Besitzer + Gruppe.",
          complexExample: "sudo chown www-data:www-data -R /var/www/site",
          complexExampleExplanation: [
            {
              line: "sudo chown www-data:www-data -R /var/www/site",
              explanation:
                "sudo gibt Root-Rechte, chown ändert Besitzer und Gruppe, www-data:www-data setzt beide auf www-data, -R rekursiv für den gesamten /var/www/site Baum (Standard für Web-Server)",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `sudo chown user file.txt`?",
              options: [
                "Ändert die Rechte",
                "Ändert den Besitzer von file.txt zu 'user'",
                "Löscht file.txt",
                "Kopiert file.txt",
              ],
              correctIndex: 1,
              explanation:
                "`chown` ändert den Besitzer – benötigt meist `sudo`, da man normalerweise nicht Besitzer anderer Dateien ändern kann.",
            },
            {
              level: "mittel",
              prompt: "Wie änderst du Besitzer UND Gruppe?",
              options: [
                "chown user file",
                "chown user:group file",
                "chown user,group file",
                "chown user.group file",
              ],
              correctIndex: 1,
              explanation:
                "Mit `user:group` werden beide auf einmal geändert – z.B. `chown www-data:www-data file`.",
            },
            {
              level: "schwer",
              prompt:
                "Was macht `sudo chown www-data:www-data -R /var/www/site`?",
              options: [
                "Ändert nur die Rechte",
                "Ändert Besitzer und Gruppe rekursiv auf www-data für den gesamten /var/www/site Baum",
                "Löscht /var/www/site",
                "Kopiert /var/www/site",
              ],
              correctIndex: 1,
              explanation:
                "Rekursiv (`-R`) wird Besitzer und Gruppe auf www-data gesetzt – Standard für Web-Server-Verzeichnisse.",
            },
          ],
        },

        chgrp: {
          title: "chgrp",
          description: "Ändert nur die Gruppenzugehörigkeit einer Datei.",
          explanation: "Ändert nur die Gruppenzugehörigkeit einer Datei.",
          simpleExample: "sudo chgrp staff file.txt",
          detail: "Wird oft verwendet, wenn mehrere User Zugriff benötigen.",
          complexExample: "sudo chgrp developers -R project/",
          complexExampleExplanation: [
            {
              line: "sudo chgrp developers -R project/",
              explanation:
                "sudo gibt Root-Rechte, chgrp ändert nur die Gruppe (nicht den Besitzer), developers ist der Gruppenname, -R rekursiv für den gesamten project/ Baum (alle Entwickler in dieser Gruppe haben Zugriff)",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `sudo chgrp staff file.txt`?",
              options: [
                "Ändert den Besitzer",
                "Ändert nur die Gruppe von file.txt zu 'staff'",
                "Löscht file.txt",
                "Kopiert file.txt",
              ],
              correctIndex: 1,
              explanation:
                "`chgrp` ändert nur die Gruppe, nicht den Besitzer – nützlich für Gruppen-Zugriff.",
            },
            {
              level: "mittel",
              prompt: "Wann wird `chgrp` oft verwendet?",
              options: [
                "Wenn man Dateien löschen will",
                "Wenn mehrere User Zugriff benötigen",
                "Wenn man Dateien kopieren will",
                "Wenn man Dateien sortieren will",
              ],
              correctIndex: 1,
              explanation:
                "Wenn mehrere Benutzer Zugriff auf Dateien brauchen, setzt man sie in eine gemeinsame Gruppe.",
            },
            {
              level: "schwer",
              prompt: "Was macht `sudo chgrp developers -R project/`?",
              options: [
                "Ändert nur den Besitzer",
                "Ändert die Gruppe rekursiv auf 'developers' für den gesamten project/ Baum",
                "Löscht project/",
                "Kopiert project/",
              ],
              correctIndex: 1,
              explanation:
                "Rekursiv (`-R`) wird die Gruppe auf 'developers' gesetzt – alle Entwickler in dieser Gruppe haben dann Zugriff.",
            },
          ],
        },

        touch: {
          title: "touch",
          description:
            "Erstellt eine leere Datei oder aktualisiert das Änderungsdatum.",
          explanation:
            "Erstellt eine leere Datei oder aktualisiert das Änderungsdatum.",
          simpleExample: "touch notes.txt",
          detail: "Wird oft genutzt, um Testdateien zu erzeugen.",
          complexExample: "touch $(date +backup_%F.txt)",
          complexExampleExplanation: [
            {
              line: "touch $(date +backup_%F.txt)",
              explanation:
                "touch erstellt eine leere Datei, $(date +backup_%F.txt) wird durch das aktuelle Datum im Format backup_YYYY-MM-DD.txt ersetzt (z.B. backup_2025-01-15.txt)",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `touch notes.txt`?",
              options: [
                "Löscht notes.txt",
                "Erstellt eine leere Datei notes.txt (oder aktualisiert das Datum, wenn sie existiert)",
                "Kopiert notes.txt",
                "Zeigt notes.txt an",
              ],
              correctIndex: 1,
              explanation:
                "`touch` erstellt eine leere Datei, wenn sie nicht existiert, oder aktualisiert das Änderungsdatum.",
            },
            {
              level: "mittel",
              prompt: "Wofür wird `touch` oft verwendet?",
              options: [
                "Um Dateien zu löschen",
                "Um Testdateien zu erzeugen",
                "Um Dateien zu kopieren",
                "Um Dateien zu sortieren",
              ],
              correctIndex: 1,
              explanation:
                "Schnell eine leere Datei erstellen – ideal für Tests oder als Platzhalter.",
            },
            {
              level: "schwer",
              prompt: "Was macht `touch $(date +backup_%F.txt)`?",
              options: [
                "Erstellt eine Datei mit dem aktuellen Datum im Namen",
                "Löscht alle Backup-Dateien",
                "Kopiert alle Backup-Dateien",
                "Zeigt alle Backup-Dateien",
              ],
              correctIndex: 0,
              explanation:
                "`$(date +%F)` wird durch das Datum (YYYY-MM-DD) ersetzt, dann wird eine Datei wie `backup_2025-01-15.txt` erstellt.",
            },
          ],
        },

        head: {
          title: "head",
          description: "Zeigt die ersten Zeilen einer Datei.",
          explanation: "Zeigt die ersten Zeilen einer Datei.",
          simpleExample: "head file.txt",
          detail: "Immer 10 Zeilen, außer man nutzt -n.",
          complexExample: "head -n 3 error.log",
          complexExampleExplanation: [
            {
              line: "head -n 3 error.log",
              explanation:
                "head zeigt die ersten Zeilen einer Datei, -n 3 begrenzt die Ausgabe auf die ersten 3 Zeilen (nützlich um schnell den Anfang einer Logdatei zu sehen)",
            },
          ],
          additionalExamples: `
✅ <strong>1. Ganze Datei anzeigen vs. nur Anfang</strong><br>
<code>cat große_datei.txt</code><br>
<code>head große_datei.txt</code><br>
→ cat zeigt alles, head zeigt nur die ersten 10 Zeilen<br><br>

✅ <strong>2. Nach etwas suchen, dann nur die ersten Treffer zeigen</strong><br>
<code>grep "Error" log.txt</code><br>
<code>grep "Error" log.txt | head -n 5</code><br>
→ grep findet alle Fehler, head zeigt nur die ersten 5<br><br>

✅ <strong>3. Datei sortieren und dann nur den Anfang zeigen</strong><br>
<code>sort namen.txt</code><br>
<code>sort namen.txt | head -n 10</code><br>
→ Sortiert die Namen, head zeigt nur die ersten 10 (alphabetisch erste)<br><br>

✅ <strong>4. Erste Zeilen zeigen und dann zählen</strong><br>
<code>head -n 20 data.txt</code><br>
<code>head -n 20 data.txt | wc -l</code><br>
→ Zeigt die ersten 20 Zeilen, wc -l zählt dass es genau 20 sind<br><br>

✅ <strong>5. Mehrere Dateien zusammenfügen und nur Anfang zeigen</strong><br>
<code>cat file1.txt file2.txt</code><br>
<code>cat file1.txt file2.txt | head -n 15</code><br>
→ cat kombiniert beide Dateien, head zeigt nur die ersten 15 Zeilen
          `,
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `head file.txt`?",
              options: [
                "Zeigt die letzten Zeilen",
                "Zeigt die ersten 10 Zeilen",
                "Löscht die ersten Zeilen",
                "Kopiert die ersten Zeilen",
              ],
              correctIndex: 1,
              explanation:
                "`head` zeigt standardmäßig die ersten 10 Zeilen einer Datei.",
            },
            {
              level: "mittel",
              prompt: "Wie zeigst du nur die ersten 3 Zeilen?",
              options: [
                "head -3 file.txt",
                "head -n 3 file.txt",
                "head --lines 3 file.txt",
                "Alle oben genannten funktionieren",
              ],
              correctIndex: 3,
              explanation:
                "Alle Varianten funktionieren: `-n 3`, `-3`, `--lines 3` – alle zeigen die ersten 3 Zeilen.",
            },
            {
              level: "schwer",
              prompt: "Was macht `head -n 3 error.log`?",
              options: [
                "Zeigt die letzten 3 Zeilen",
                "Zeigt die ersten 3 Zeilen von error.log",
                "Löscht die ersten 3 Zeilen",
                "Kopiert error.log",
              ],
              correctIndex: 1,
              explanation:
                "Zeigt nur die ersten 3 Zeilen – nützlich, um schnell den Anfang einer Logdatei zu sehen.",
            },
          ],
        },

        tail: {
          title: "tail",
          description: "Zeigt die letzten Zeilen einer Datei.",
          explanation: "Zeigt die letzten Zeilen einer Datei.",
          simpleExample: "tail file.txt",
          detail: "Mit -f live-Logausgabe: extrem wichtig für Monitoring.",
          complexExample: "tail -f /var/log/syslog",
          complexExampleExplanation: [
            {
              line: "tail -f /var/log/syslog",
              explanation:
                "tail zeigt die letzten Zeilen, -f (follow) überwacht die Datei live und zeigt neue Zeilen automatisch an, sobald sie hinzugefügt werden (perfekt für Live-Log-Monitoring)",
            },
          ],
          additionalExamples: `
✅ <strong>1. Ganze Datei vs. nur Ende anzeigen</strong><br>
<code>cat log.txt</code><br>
<code>tail log.txt</code><br>
→ cat zeigt alles, tail zeigt nur die letzten 10 Zeilen<br><br>

✅ <strong>2. Nach Fehlern suchen, dann nur die letzten Treffer zeigen</strong><br>
<code>grep "Error" log.txt</code><br>
<code>grep "Error" log.txt | tail -n 5</code><br>
→ grep findet alle Fehler, tail zeigt nur die letzten 5<br><br>

✅ <strong>3. Datei sortieren und dann das Ende zeigen</strong><br>
<code>sort namen.txt</code><br>
<code>sort namen.txt | tail -n 10</code><br>
→ Sortiert die Namen, tail zeigt die letzten 10 (alphabetisch letzte)<br><br>

✅ <strong>4. Letzte Zeilen zeigen und dann zählen</strong><br>
<code>tail -n 20 data.txt</code><br>
<code>tail -n 20 data.txt | wc -l</code><br>
→ Zeigt die letzten 20 Zeilen, wc -l zählt dass es genau 20 sind<br><br>

✅ <strong>5. Mehrere Dateien zusammenfügen und nur Ende zeigen</strong><br>
<code>cat file1.txt file2.txt</code><br>
<code>cat file1.txt file2.txt | tail -n 15</code><br>
→ cat kombiniert beide Dateien, tail zeigt nur die letzten 15 Zeilen
          `,
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `tail file.txt`?",
              options: [
                "Zeigt die ersten Zeilen",
                "Zeigt die letzten 10 Zeilen",
                "Löscht die letzten Zeilen",
                "Kopiert die letzten Zeilen",
              ],
              correctIndex: 1,
              explanation:
                "`tail` zeigt standardmäßig die letzten 10 Zeilen einer Datei.",
            },
            {
              level: "mittel",
              prompt: "Was ist besonders wichtig an `tail -f`?",
              options: [
                "Es ist schneller",
                "Live-Logausgabe: zeigt neue Zeilen in Echtzeit (extrem wichtig für Monitoring)",
                "Es zeigt mehr Zeilen",
                "Es löscht Dateien",
              ],
              correctIndex: 1,
              explanation:
                "`-f` (follow) zeigt neue Zeilen live an, sobald sie zur Datei hinzugefügt werden – essentiell für Log-Monitoring.",
            },
            {
              level: "schwer",
              prompt: "Was macht `tail -f /var/log/syslog`?",
              options: [
                "Zeigt nur die letzten 10 Zeilen",
                "Zeigt die Logdatei live und aktualisiert sich automatisch bei neuen Einträgen",
                "Löscht die Logdatei",
                "Kopiert die Logdatei",
              ],
              correctIndex: 1,
              explanation:
                "Live-Monitoring: neue Log-Einträge erscheinen automatisch im Terminal – perfekt zum Debuggen.",
            },
          ],
        },

        wc_l: {
          title: "wc -l",
          description: "Zählt Zeilen in einer Datei oder Eingabe.",
          explanation: "Zählt Zeilen in einer Datei oder Eingabe.",
          simpleExample: "wc -l file.txt",
          detail: "Mit Piping mächtig: zählt Ergebnisse nach Filtern.",
          complexExample: "ls | wc -l",
          complexExampleExplanation: [
            {
              line: "ls | wc -l",
              explanation:
                "ls listet Dateien im aktuellen Verzeichnis auf, | leitet die Ausgabe an wc -l weiter, das die Anzahl der Zeilen (also Dateien/Ordner) zählt",
            },
          ],
          additionalExamples: `
✅ <strong>1. Datei anzeigen und dann Zeilen zählen</strong><br>
<code>cat log.txt</code><br>
<code>wc -l log.txt</code><br>
→ cat zeigt den Inhalt, wc -l zählt wie viele Zeilen es sind<br><br>

✅ <strong>2. Dateien auflisten und dann zählen</strong><br>
<code>ls</code><br>
<code>ls | wc -l</code><br>
→ ls zeigt Dateien, wc -l zählt wie viele Dateien/Ordner es sind<br><br>

✅ <strong>3. Nach etwas suchen und Treffer zählen</strong><br>
<code>grep "Error" log.txt</code><br>
<code>grep "Error" log.txt | wc -l</code><br>
→ Findet alle Fehler, wc -l zählt wie viele Treffer es gibt<br><br>

✅ <strong>4. Erste Zeilen zeigen und dann zählen</strong><br>
<code>head -n 20 data.txt</code><br>
<code>head -n 20 data.txt | wc -l</code><br>
→ Zeigt die ersten 20 Zeilen, wc -l bestätigt dass es genau 20 sind<br><br>

✅ <strong>5. Sortieren, Duplikate entfernen, dann zählen</strong><br>
<code>sort namen.txt | uniq</code><br>
<code>sort namen.txt | uniq | wc -l</code><br>
→ Sortiert und entfernt Duplikate, wc -l zählt wie viele eindeutige Namen es gibt
          `,
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `wc -l file.txt`?",
              options: [
                "Zählt Wörter",
                "Zählt Zeilen",
                "Zählt Zeichen",
                "Löscht Zeilen",
              ],
              correctIndex: 1,
              explanation:
                "`wc -l` zählt die Anzahl der Zeilen in einer Datei.",
            },
            {
              level: "mittel",
              prompt: "Warum ist `wc -l` mit Piping mächtig?",
              options: [
                "Weil es schneller ist",
                "Weil es Ergebnisse nach Filtern zählen kann",
                "Weil es mehr zeigt",
                "Weil es Dateien löscht",
              ],
              correctIndex: 1,
              explanation:
                "Nach Filtern (z.B. `grep`, `find`) kann man mit `wc -l` schnell zählen, wie viele Treffer es gibt.",
            },
            {
              level: "schwer",
              prompt: "Was macht `ls | wc -l`?",
              options: [
                "Zeigt alle Dateien",
                "Zählt die Anzahl der Dateien/Ordner im aktuellen Verzeichnis",
                "Löscht alle Dateien",
                "Kopiert alle Dateien",
              ],
              correctIndex: 1,
              explanation:
                "`ls` listet Dateien, `|` leitet an `wc -l` weiter, das die Anzahl der Zeilen (also Dateien) zählt.",
            },
          ],
        },

        wc_w: {
          title: "wc -w",
          description: "Zählt Wörter.",
          explanation: "Zählt Wörter.",
          simpleExample: "wc -w text.txt",
          detail: "Oft zusammen mit head/tail verwendet.",
          complexExample: "ifconfig | head -n 7 | wc -w",
          complexExampleExplanation: [
            {
              line: "ifconfig | head -n 7 | wc -w",
              explanation:
                "ifconfig zeigt Netzwerkinformationen, | leitet an head -n 7 weiter (zeigt nur die ersten 7 Zeilen), | leitet an wc -w weiter (zählt die Anzahl der Wörter in diesen Zeilen)",
            },
          ],
          additionalExamples: `
✅ <strong>1. Datei anzeigen und dann Wörter zählen</strong><br>
<code>cat text.txt</code><br>
<code>wc -w text.txt</code><br>
→ cat zeigt den Inhalt, wc -w zählt wie viele Wörter es sind<br><br>

✅ <strong>2. Erste Zeilen zeigen und dann Wörter zählen</strong><br>
<code>head -n 10 log.txt</code><br>
<code>head -n 10 log.txt | wc -w</code><br>
→ Zeigt die ersten 10 Zeilen, wc -w zählt die Wörter darin<br><br>

✅ <strong>3. Nach etwas suchen und dann Wörter zählen</strong><br>
<code>grep "Error" log.txt</code><br>
<code>grep "Error" log.txt | wc -w</code><br>
→ Findet alle Fehler-Zeilen, wc -w zählt die Wörter in den Treffern<br><br>

✅ <strong>4. Letzte Zeilen zeigen und dann Wörter zählen</strong><br>
<code>tail -n 5 status.txt</code><br>
<code>tail -n 5 status.txt | wc -w</code><br>
→ Zeigt die letzten 5 Zeilen, wc -w zählt die Wörter<br><br>

✅ <strong>5. Mehrere Dateien kombinieren und Wörter zählen</strong><br>
<code>cat file1.txt file2.txt</code><br>
<code>cat file1.txt file2.txt | wc -w</code><br>
→ Kombiniert beide Dateien, wc -w zählt alle Wörter zusammen
          `,
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `wc -w text.txt`?",
              options: [
                "Zählt Zeilen",
                "Zählt Wörter",
                "Zählt Zeichen",
                "Löscht Wörter",
              ],
              correctIndex: 1,
              explanation:
                "`wc -w` zählt die Anzahl der Wörter in einer Datei.",
            },
            {
              level: "mittel",
              prompt: "Womit wird `wc -w` oft kombiniert?",
              options: ["Mit rm", "Mit head/tail", "Mit cp", "Mit mv"],
              correctIndex: 1,
              explanation:
                "Oft kombiniert mit `head` oder `tail`, um nur einen Teil der Datei zu analysieren.",
            },
            {
              level: "schwer",
              prompt: "Was macht `ifconfig | head -n 7 | wc -w`?",
              options: [
                "Zeigt ifconfig",
                "Zählt die Wörter in den ersten 7 Zeilen von ifconfig",
                "Löscht ifconfig",
                "Kopiert ifconfig",
              ],
              correctIndex: 1,
              explanation:
                "`ifconfig` Ausgabe → erste 7 Zeilen (`head -n 7`) → Wörter zählen (`wc -w`) – nützlich für schnelle Analyse.",
            },
          ],
        },
      };

      // Haupt-Badge-Konfiguration (5 zentrale Kompetenz-Badges)
      const mainBadges = [
        {
          id: "linux_voyer",
          name: "Linux Voyer",
          icon: "👁️",
          colorClass: "badge-voyer",
          subSegments: ["segment4", "segment5"], // System & Rechte + Erweiterte Techniken
          segments: [
            {
              id: "segment4",
              name: "System & Rechte",
              icon: "🔐",
              colorClass: "segment-4",
              quizIds: [
                "whoami",
                "chmod",
                "chmod_R",
                "chown",
                "chgrp",
                "touch",
                "head",
                "tail",
                "wc_l",
                "wc_w",
              ],
            },
            {
              id: "segment5",
              name: "Erweiterte Techniken",
              icon: "⚙️",
              colorClass: "segment-5",
              quizIds: ["redirect", "nano_flow"],
            },
          ],
        },
        {
          id: "linux_operator",
          name: "Linux Operator",
          icon: "⚙️",
          colorClass: "badge-operator",
          subSegments: ["segment2"], // Dateioperationen & Suche
          segments: [
            {
              id: "segment2",
              name: "Dateioperationen & Suche",
              icon: "🔍",
              colorClass: "segment-2",
              quizIds: [
                "cp_r",
                "rm",
                "rm_r",
                "cat",
                "grep",
                "sort",
                "sort_n",
                "uniq",
                "find_name",
                "find_maxdepth",
              ],
            },
          ],
        },
        {
          id: "cli_connoisseur",
          name: "CLI-Konnoisseur",
          icon: "🎯",
          colorClass: "badge-connoisseur",
          subSegments: ["segment3"], // Auflistung & Umleitung
          segments: [
            {
              id: "segment3",
              name: "Auflistung & Umleitung",
              icon: "📋",
              colorClass: "segment-3",
              quizIds: [
                "ls_R",
                "ls_aR",
                "tree",
                "tree_d",
                "tree_L",
                "echo",
                "redirect_overwrite",
                "redirect_append",
                "redirect_stderr",
                "pipe",
              ],
            },
          ],
        },
        {
          id: "linux_navigator",
          name: "Linux Navigator",
          icon: "🧭",
          colorClass: "badge-navigator",
          subSegments: ["segment1"], // Navigation & Grundlagen
          segments: [
            {
              id: "segment1",
              name: "Navigation & Grundlagen",
              icon: "🧭",
              colorClass: "segment-1",
              quizIds: [
                "pwd",
                "cd",
                "cd_parent",
                "ls",
                "ls_a",
                "ls_la",
                "mkdir",
                "mkdir_p",
                "mv",
                "cp",
              ],
            },
          ],
        },
        {
          id: "morelinux",
          name: "MoreLinux",
          icon: "👑",
          colorClass: "badge-morelinux",
          subSegments: [], // Bisheriges Linux Master
          segments: [],
        },
      ];

      // Legacy badgeSegments für Kompatibilität (wird später entfernt)
      const badgeSegments = [
        {
          id: "segment1",
          name: "Navigation & Grundlagen",
          icon: "🧭",
          colorClass: "segment-1",
          quizIds: [
            "pwd",
            "cd",
            "cd_parent",
            "ls",
            "ls_a",
            "ls_la",
            "mkdir",
            "mkdir_p",
            "mv",
            "cp",
          ],
        },
        {
          id: "segment2",
          name: "Dateioperationen & Suche",
          icon: "🔍",
          colorClass: "segment-2",
          quizIds: [
            "cp_r",
            "rm",
            "rm_r",
            "cat",
            "grep",
            "sort",
            "sort_n",
            "uniq",
            "find_name",
            "find_maxdepth",
          ],
        },
        {
          id: "segment3",
          name: "Auflistung & Umleitung",
          icon: "📋",
          colorClass: "segment-3",
          quizIds: [
            "ls_R",
            "ls_aR",
            "tree",
            "tree_d",
            "tree_L",
            "echo",
            "redirect_overwrite",
            "redirect_append",
            "redirect_stderr",
            "pipe",
          ],
        },
        {
          id: "segment4",
          name: "System & Rechte",
          icon: "🔐",
          colorClass: "segment-4",
          quizIds: [
            "whoami",
            "chmod",
            "chmod_R",
            "chown",
            "chgrp",
            "touch",
            "head",
            "tail",
            "wc_l",
            "wc_w",
          ],
        },
        {
          id: "segment5",
          name: "Erweiterte Techniken",
          icon: "⚙️",
          colorClass: "segment-5",
          quizIds: ["redirect", "nano_flow"],
        },
        {
          id: "segment6",
          name: "Fortgeschrittene Workflows",
          icon: "🚀",
          colorClass: "segment-6",
          quizIds: [],
        },
      ];

      // Masterquiz-Daten
      const masterQuizData = {
        segment1: {
          title: "Masterquiz: Navigation & Grundlagen",
          scenario:
            "Du bist Systemadministrator und musst ein Backup-System für tägliche Dokumente einrichten. Das Backup-Verzeichnis soll mit dem aktuellen Datum benannt werden, und alle wichtigen Dateien sollen automatisch gesichert werden.",
          question:
            "Du musst ein tägliches Backup-System erstellen. Welche Befehlssequenz erstellt ein Backup-Verzeichnis mit dem aktuellen Datum, kopiert alle `.txt`-Dateien dorthin, wechselt in das Backup-Verzeichnis und zeigt den aktuellen Pfad an?",
          options: [
            "mkdir backups/$(date +%Y-%m-%d) && cp *.txt backups/$(date +%Y-%m-%d)/ && cd backups/$(date +%Y-%m-%d) && pwd",
            "cd backups && mkdir $(date +%Y-%m-%d) && cp *.txt",
            "mkdir -p backups && cp *.txt backups/ && pwd",
            "ls -la backups/$(date +%Y-%m-%d)",
          ],
          correctIndex: 0,
          explanation:
            "Die Sequenz nutzt `mkdir` für das Verzeichnis (mit Datum), kopiert alle `.txt`-Dateien, wechselt ins Backup-Verzeichnis und zeigt den Pfad mit `pwd`. Die Kombination aus `mkdir`, `cp`, `cd` und `pwd` ist essentiell.",
        },
        segment2: {
          title: "Masterquiz: Dateioperationen & Suche",
          scenario:
            "Du musst eine Log-Analyse durchführen: Finde alle `.log`-Dateien im aktuellen Verzeichnisbaum, filtere nach Fehler-Einträgen, entferne Duplikate und erstelle eine sortierte Zusammenfassung.",
          question:
            'Du musst alle Fehlermeldungen aus Log-Dateien extrahieren. Welche Befehlssequenz findet alle `.log`-Dateien, sucht nach "ERROR", sortiert die Ergebnisse, entfernt Duplikate und zählt die eindeutigen Treffer?',
          options: [
            'find . -name "*.log" | grep "ERROR" | sort | uniq | wc -l',
            'find . -name "*.log" -type f -exec grep "ERROR" {} \\; | sort | uniq | wc -l',
            'grep -r "ERROR" *.log | sort | uniq',
            'cat *.log | grep "ERROR" | sort',
          ],
          correctIndex: 1,
          explanation:
            "`find` sucht rekursiv nach `.log`-Dateien, `-exec grep` durchsucht jede gefundene Datei, `sort` sortiert die Ergebnisse, `uniq` entfernt Duplikate, und `wc -l` zählt die Zeilen. Die Kombination aus `find`, `grep`, `sort` und `uniq` ist typisch für Log-Analysen.",
        },
        segment3: {
          title: "Masterquiz: Auflistung & Umleitung",
          scenario:
            "Du richtest ein Logging-System für eine Anwendung ein. Die Anwendung soll ihre Ausgaben in eine Logdatei schreiben, Fehler sollen separat gespeichert werden, und du musst die Verzeichnisstruktur dokumentieren.",
          question:
            "Du richtest ein Logging-System ein. Welche Befehlssequenz erstellt die Verzeichnisstruktur `logs/app`, schreibt eine Startnachricht mit Datum in die Logdatei, und dokumentiert die Verzeichnisstruktur (Fehler sollen in eine separate Datei)?",
          options: [
            'mkdir logs/app && echo "$(date)" >> logs/app/application.log && tree -L 2 logs/ > structure.txt 2> errors.log',
            'mkdir -p logs/app && echo "$(date): Started" >> logs/app/application.log && tree -L 2 logs/ > logs/app/structure.txt 2> logs/app/errors.log',
            'cd logs && mkdir app && echo "Started" > application.log',
            'tree logs/ > structure.txt && echo "Started" >> application.log',
          ],
          correctIndex: 1,
          explanation:
            "`mkdir -p` erstellt die Struktur, `echo` mit `>>` hängt an (ideal für Logs), `tree -L 2` zeigt die Struktur begrenzt, und `2>` leitet Fehler separat um. Die Kombination aus `echo`, `>>`, `2>`, und `tree` ist typisch für Logging-Setups.",
        },
        segment4: {
          title: "Masterquiz: System & Rechte",
          scenario:
            "Du installierst ein Web-Server-Script und musst sicherstellen, dass es mit den richtigen Berechtigungen läuft. Das Script muss ausführbar sein, und du musst prüfen, wer es ausführt.",
          question:
            "Du installierst ein Web-Server-Script. Welche Sequenz erstellt das Script, setzt die Rechte auf 755 (Besitzer: rwx, Gruppe/Andere: rx), ändert Besitzer und Gruppe auf www-data, und prüft, wer es ausführen würde?",
          options: [
            "touch deploy.sh && chmod 755 deploy.sh && sudo chown www-data:www-data deploy.sh && whoami",
            "chmod +x deploy.sh && chown www-data deploy.sh",
            "touch deploy.sh && chmod 777 deploy.sh && whoami",
            "mkdir deploy.sh && chmod 755 deploy.sh",
          ],
          correctIndex: 0,
          explanation:
            "`touch` erstellt die Datei, `chmod 755` setzt die Standard-Web-Server-Rechte, `chown user:group` ändert Besitzer und Gruppe, und `whoami` prüft den aktuellen Benutzer. Die Kombination aus `touch`, `chmod`, `chown` und `whoami` ist essentiell für sichere Script-Installationen.",
        },
      };

      const commandCards = Array.from(
        document.querySelectorAll(".command-card")
      );
      // Map visible category text to normalized category keys and add category classes
      (function assignCategoryClasses() {
        const categoryMap = {
          Navigation: "navigation",
          Auflisten: "listing",
          Suche: "search",
          Pipes: "pipes",
          Umleitung: "redirect",
          Workflow: "workflow",
          Dateien: "files",
          System: "system",
          Rechte: "permissions",
        };
        commandCards.forEach((card) => {
          const tagEl = card.querySelector(".command-tag");
          if (!tagEl) return;
          const raw = tagEl.textContent.trim();
          const key =
            categoryMap[raw] || raw.toLowerCase().replace(/\s+/g, "-");
          card.classList.add("category-" + key);
        });
      })();

      const quizRoot = document.getElementById("quiz-root");
      const quizBodyEl = document.getElementById("quiz-body");
      const quizTitleEl = document.getElementById("quiz-title");
      const quizSubtitleEl = document.getElementById("quiz-subtitle");
      const quizFeedbackEl = document.getElementById("quiz-feedback");
      const quizSubmitBtn = document.getElementById("quiz-submit-btn");
      const quizCloseBtn = document.getElementById("quiz-close-btn");

      let currentQuizId = null;
      let activeFilterSegment = null; // Aktives Filter-Segment (null = kein Filter)
      let activeFilterAchievement = null; // Aktives Achievement-Filter (null = kein Filter)

      // Achievement System
      const achievements = [
        { threshold: 10, name: "Linux Voyeur", icon: "👁️", class: "badge-10" },
        {
          threshold: 20,
          name: "Linux Operator",
          icon: "⚙️",
          class: "badge-20",
        },
        {
          threshold: 30,
          name: "CLI Connoisseur",
          icon: "🎯",
          class: "badge-30",
        },
        {
          threshold: 40,
          name: "Linux Navigator",
          icon: "🧭",
          class: "badge-40",
        },
        { threshold: 50, name: "Linux Master", icon: "👑", class: "badge-50" },
        {
          threshold: 60,
          name: 'Linux Basics "it\'s something"',
          icon: "🏆",
          class: "badge-60",
        },
      ];

      function getTotalCorrectAnswers() {
        const stored = localStorage.getItem("quizResults");
        if (!stored) return 0;
        try {
          const results = JSON.parse(stored);
          return Object.values(results).reduce((sum, count) => sum + count, 0);
        } catch {
          return 0;
        }
      }

      function saveQuizResult(quizId, correctCount) {
        const stored = localStorage.getItem("quizResults");
        let results = {};
        if (stored) {
          try {
            results = JSON.parse(stored);
          } catch {
            results = {};
          }
        }
        // Nur speichern, wenn alle Fragen richtig waren (3/3) und noch nicht gespeichert
        if (correctCount === 3 && !results[quizId]) {
          results[quizId] = correctCount;
          localStorage.setItem("quizResults", JSON.stringify(results));

          // Update badge progress
          updateBadgeProgress();

          return true; // New completion
        }
        return false; // Already completed or not all correct
      }

      // Migration: Convert quizResults to badgeProgress
      function migrateToBadgeProgress() {
        const stored = localStorage.getItem("badgeProgress");
        if (stored) return; // Already migrated

        const quizResults = localStorage.getItem("quizResults");
        if (!quizResults) {
          localStorage.setItem("badgeProgress", JSON.stringify({}));
          return;
        }

        try {
          const results = JSON.parse(quizResults);
          const badgeProgress = {};

          badgeSegments.forEach((segment) => {
            let count = 0;
            segment.quizIds.forEach((id) => {
              if (results[id] === 3) count++;
            });
            badgeProgress[segment.id] = count;
          });

          localStorage.setItem("badgeProgress", JSON.stringify(badgeProgress));
        } catch (e) {
          console.error("Migration error:", e);
          localStorage.setItem("badgeProgress", JSON.stringify({}));
        }
      }

      // Get badge progress from localStorage
      function getBadgeProgress() {
        const stored = localStorage.getItem("badgeProgress");
        if (!stored) {
          migrateToBadgeProgress();
          return getBadgeProgress();
        }
        try {
          return JSON.parse(stored);
        } catch {
          return {};
        }
      }

      // Update badge progress based on quizResults
      function updateBadgeProgress() {
        const quizResults = localStorage.getItem("quizResults");
        if (!quizResults) return;

        try {
          const results = JSON.parse(quizResults);
          const badgeProgress = {};

          badgeSegments.forEach((segment) => {
            let count = 0;
            segment.quizIds.forEach((id) => {
              if (results[id] === 3) count++;
            });
            badgeProgress[segment.id] = count;
          });

          localStorage.setItem("badgeProgress", JSON.stringify(badgeProgress));
        } catch (e) {
          console.error("Update badge progress error:", e);
        }
      }

      // Get segment progress
      function getSegmentProgress(segmentId) {
        const progress = getBadgeProgress();
        return progress[segmentId] || 0;
      }

      // Check if master quiz is completed
      function isMasterQuizCompleted(segmentId) {
        const stored = localStorage.getItem("masterQuizCompleted");
        if (!stored) return false;
        try {
          const completed = JSON.parse(stored);
          return completed[segmentId] === true;
        } catch {
          return false;
        }
      }

      // Mark master quiz as completed
      function setMasterQuizCompleted(segmentId) {
        const stored = localStorage.getItem("masterQuizCompleted");
        let completed = {};
        if (stored) {
          try {
            completed = JSON.parse(stored);
          } catch {
            completed = {};
          }
        }
        completed[segmentId] = true;
        localStorage.setItem("masterQuizCompleted", JSON.stringify(completed));
      }

      // Check if achievement master quiz is completed
      function isAchievementMasterCompleted(threshold) {
        const stored = localStorage.getItem("achievementMasterCompleted");
        if (!stored) return false;
        try {
          const completed = JSON.parse(stored);
          return completed[threshold] === true;
        } catch {
          return false;
        }
      }

      // Mark achievement master quiz as completed
      function setAchievementMasterCompleted(threshold) {
        const stored = localStorage.getItem("achievementMasterCompleted");
        let completed = {};
        if (stored) {
          try {
            completed = JSON.parse(stored);
          } catch {
            completed = {};
          }
        }
        completed[threshold] = true;
        localStorage.setItem(
          "achievementMasterCompleted",
          JSON.stringify(completed)
        );
      }

      // Get segment ID from achievement threshold
      function getSegmentIdFromThreshold(threshold) {
        const mapping = {
          10: "segment1",
          20: "segment2",
          30: "segment3",
          40: "segment4",
          50: "segment5",
          60: "segment6",
        };
        return mapping[threshold] || null;
      }

      // Get achievement threshold from segment ID
      function getAchievementThresholdFromSegment(segmentId) {
        const mapping = {
          segment1: 10,
          segment2: 20,
          segment3: 30,
          segment4: 40,
          segment5: 50,
          segment6: 60,
        };
        return mapping[segmentId] || null;
      }

      // Get all quiz IDs for an achievement threshold
      function getQuizIdsForAchievement(threshold) {
        const segmentMapping = {
          10: "segment1", // Linux Voyeur - Navigation & Grundlagen
          20: "segment2", // Linux Operator - Dateioperationen & Suche
          30: "segment3", // CLI Connoisseur - Auflistung & Umleitung
          40: "segment4", // Linux Navigator - System & Rechte
          50: "segment5", // Linux Master - Erweiterte Techniken
          60: "segment6", // Linux Basics - Fortgeschrittene Workflows
        };

        const segmentId = segmentMapping[threshold];
        if (segmentId) {
          const segment = badgeSegments.find((s) => s.id === segmentId);
          if (segment) {
            return [...segment.quizIds]; // Return copy of quiz IDs for this segment
          }
        }

        // Fallback: return empty array
        return [];
      }

      // Check if all quizzes for an achievement are completed
      function areAllAchievementQuizzesCompleted(threshold) {
        const quizIds = getQuizIdsForAchievement(threshold);
        const stored = localStorage.getItem("quizResults");
        if (!stored) return false;

        try {
          const results = JSON.parse(stored);
          return quizIds.every((quizId) => results[quizId] === 3);
        } catch {
          return false;
        }
      }

      // Filter cards by achievement quiz IDs
      function filterCardsByAchievement(threshold) {
        if (threshold === null) {
          // Filter entfernen - alle Karten anzeigen (außer die durch Suche versteckten)
          const searchInput = document.getElementById("search-input");
          if (searchInput && searchInput.value.trim()) {
            // Suche ist aktiv, wird separat behandelt
            return;
          }
          commandCards.forEach((card) => {
            card.classList.remove("hidden");
          });
          // Segment-Filter auch zurücksetzen
          activeFilterSegment = null;
          updateBadgeDisplay();
          return;
        }

        const quizIds = getQuizIdsForAchievement(threshold);

        // Segment-Filter zurücksetzen wenn Achievement-Filter aktiv
        activeFilterSegment = null;
        updateBadgeDisplay();

        // Alle Karten durchgehen und entsprechend filtern
        commandCards.forEach((card) => {
          const quizId = card.dataset.quizId;
          if (!quizId) return; // Skip cards without quiz ID

          const belongsToAchievement = quizIds.includes(quizId);
          // Wenn Karte zu Achievement gehört, anzeigen, sonst verstecken
          if (belongsToAchievement) {
            card.classList.remove("hidden");
          } else {
            card.classList.add("hidden");
          }
        });
      }

      function updateAchievements() {
        const totalCorrect = getTotalCorrectAnswers();
        const container = document.getElementById("achievements-container");
        const progressEl = document.getElementById("achievement-progress");

        if (!container || !progressEl) return;

        container.innerHTML = "";
        achievements.forEach((achievement) => {
          const isUnlocked = totalCorrect >= achievement.threshold;
          const isMasterCompleted = isAchievementMasterCompleted(
            achievement.threshold
          );
          const segmentId = getSegmentIdFromThreshold(achievement.threshold);

          const badge = document.createElement("div");
          let badgeClasses = `achievement-badge ${achievement.class} ${
            isUnlocked ? "unlocked" : "locked"
          }`;

          if (isMasterCompleted) {
            badgeClasses += " golden";
          }

          badge.className = badgeClasses;
          badge.innerHTML = `<span class="achievement-icon">${achievement.icon}</span><span>${achievement.name}</span>`;

          // Click-Handler für alle Badges (auch gesperrte)
          badge.style.cursor = "pointer";
          const allQuizzesCompleted = isUnlocked
            ? areAllAchievementQuizzesCompleted(achievement.threshold)
            : false;

          if (isMasterCompleted) {
            badge.title = "Master-Quiz abgeschlossen! 🏆";
          } else if (allQuizzesCompleted) {
            badge.title = "Alle Quiz abgeschlossen! Klicken für Master-Quiz";
          } else if (isUnlocked) {
            badge.title = "Klicken um zugehörige Quiz anzuzeigen";
          } else {
            badge.title = `Noch gesperrt. Klicken um benötigte Quiz anzuzeigen (${achievement.threshold} Fragen nötig)`;
          }

          badge.addEventListener("click", () => {
            // Toggle Filter
            if (activeFilterAchievement === achievement.threshold) {
              // Filter entfernen
              activeFilterAchievement = null;
              filterCardsByAchievement(null);
            } else {
              // Filter setzen
              activeFilterAchievement = achievement.threshold;
              filterCardsByAchievement(achievement.threshold);

              // Wenn alle Quiz abgeschlossen sind, Master-Quiz anbieten
              if (isUnlocked && allQuizzesCompleted && segmentId) {
                setTimeout(() => {
                  if (
                    confirm(
                      `Alle Quiz für "${achievement.name}" sind abgeschlossen! Möchtest du das Master-Quiz starten?`
                    )
                  ) {
                    openMasterQuiz(segmentId);
                  }
                }, 100);
              }
            }

            // Segment-Filter zurücksetzen wenn Achievement-Filter aktiv
            if (activeFilterAchievement) {
              activeFilterSegment = null;
              updateBadgeDisplay();
            }
          });

          container.appendChild(badge);
        });

        progressEl.textContent = `Fortschritt: ${totalCorrect}/60 Fragen richtig beantwortet`;
      }

      // Berechne Fortschritt für ein Haupt-Badge (10 Segmente = 10% pro Segment)
      function getMainBadgeProgress(mainBadge) {
        // Sammle alle Quiz-IDs aus allen Segmenten
        const allQuizIds = [];
        mainBadge.segments.forEach((segment) => {
          allQuizIds.push(...segment.quizIds);
        });

        if (allQuizIds.length === 0) {
          return {
            completedSegments: 0,
            totalSegments: 10,
            percentage: 0,
            totalCompleted: 0,
            totalQuizzes: 0,
          };
        }

        // Zähle abgeschlossene Quiz direkt aus quizResults
        const quizResults = localStorage.getItem("quizResults");
        let totalCompleted = 0;
        if (quizResults) {
          try {
            const results = JSON.parse(quizResults);
            allQuizIds.forEach((quizId) => {
              if (results[quizId] === 3) {
                totalCompleted++;
              }
            });
          } catch (e) {
            // Ignore
          }
        }

        // Berechne Anzahl der abgeschlossenen Segmente (max 10)
        // Jedes Segment entspricht 10% des Fortschritts
        const completedSegments = Math.min(
          10,
          Math.floor((totalCompleted / allQuizIds.length) * 10)
        );

        return {
          completedSegments,
          totalSegments: 10,
          percentage: Math.round((completedSegments / 10) * 100),
          totalCompleted,
          totalQuizzes: allQuizIds.length,
        };
      }

      // Update Badge Display für neue Struktur
      function updateBadgeDisplay() {
        const container = document.getElementById("badges-header");
        if (!container) return;

        container.innerHTML = "";

        // Initialisiere Migration beim ersten Laden
        migrateToBadgeProgress();

        // Haupt-Badge Reihe
        const mainRow = document.createElement("div");
        mainRow.className = "main-badges-row";

        mainBadges.forEach((mainBadge) => {
          const progress = getMainBadgeProgress(mainBadge);

          const badge = document.createElement("div");
          badge.className = `main-badge ${mainBadge.colorClass}`;

          // Markiere aktives Badge
          if (
            activeFilterSegment &&
            mainBadge.subSegments.includes(activeFilterSegment)
          ) {
            badge.classList.add("active");
          }

          // Click-Handler für Filter-Funktion
          badge.addEventListener("click", () => {
            // Wenn bereits aktiv, Filter entfernen
            if (
              activeFilterSegment &&
              mainBadge.subSegments.includes(activeFilterSegment)
            ) {
              activeFilterSegment = null;
            } else {
              // Filter auf erstes Sub-Segment setzen
              if (mainBadge.subSegments.length > 0) {
                activeFilterSegment = mainBadge.subSegments[0];
              }
              activeFilterAchievement = null;
            }
            filterCardsBySegment();
            updateBadgeDisplay();
          });

          // Doppelklick-Handler für Master-Quiz (wenn alle Segmente abgeschlossen)
          if (progress.completedSegments >= 10) {
            badge.style.cursor = "pointer";
            badge.title = "Doppelklick für Master-Quiz";
            badge.addEventListener("dblclick", (e) => {
              e.stopPropagation();
              // Öffne Master-Quiz für erstes Sub-Segment
              if (mainBadge.subSegments.length > 0) {
                openMasterQuiz(mainBadge.subSegments[0]);
              }
            });
          } else {
            badge.title = `${mainBadge.name}: ${progress.completedSegments}/10 Segmente`;
          }

          badge.innerHTML = `
            <div class="main-badge-header">
              <span class="main-badge-icon">${mainBadge.icon}</span>
              <span class="main-badge-name">${mainBadge.name}</span>
            </div>
            <div class="main-badge-progress-container">
              <div class="main-badge-progress-bar">
                <div class="main-badge-progress-fill" style="width: ${progress.percentage}%"></div>
              </div>
              <div class="main-badge-progress-text">${progress.completedSegments}/10</div>
            </div>
          `;

          mainRow.appendChild(badge);
        });

        container.appendChild(mainRow);
      }

      // Filtere Kacheln nach Segment
      function filterCardsBySegment() {
        // Wenn Achievement-Filter aktiv ist, Segment-Filter ignorieren
        if (activeFilterAchievement) {
          return;
        }

        if (!activeFilterSegment) {
          // Kein Filter aktiv - alle Kacheln anzeigen (außer die, die durch Suche versteckt sind)
          commandCards.forEach((card) => {
            // Nur hidden entfernen, wenn es durch Segment-Filter gesetzt wurde
            // Die Suche wird separat behandelt
            const searchInput = document.getElementById("search-input");
            if (searchInput && searchInput.value.trim()) {
              // Wenn Suche aktiv ist, wird die Karte durch die Suchfunktion gefiltert
              return;
            }
            card.classList.remove("hidden");
          });
          return;
        }

        // Finde das aktive Segment
        const segment = badgeSegments.find((s) => s.id === activeFilterSegment);
        if (!segment) return;

        // Zeige nur Kacheln, die zu diesem Segment gehören
        commandCards.forEach((card) => {
          const quizId = card.dataset.quizId;
          const belongsToSegment = segment.quizIds.includes(quizId);
          card.classList.toggle("hidden", !belongsToSegment);
        });
      }

      // Assign badges to cards
      function assignBadgeToCards() {
        badgeSegments.forEach((segment) => {
          segment.quizIds.forEach((quizId) => {
            const card = commandCards.find((c) => c.dataset.quizId === quizId);
            if (card) {
              const header = card.querySelector(".command-header");
              if (header && !header.querySelector(".badge-mini")) {
                const miniBadge = document.createElement("span");
                miniBadge.className = `badge-mini ${segment.colorClass}`;
                miniBadge.textContent = segment.icon;
                miniBadge.title = segment.name;
                header.insertBefore(miniBadge, header.firstChild);
              }
            }
          });
        });
      }

      // Open Master Quiz
      function openMasterQuiz(segmentId) {
        const masterQuiz = masterQuizData[segmentId];
        if (!masterQuiz) {
          console.warn("Kein Masterquiz für Segment:", segmentId);
          return;
        }

        const modal = document.getElementById("master-quiz-root");
        const titleEl = document.getElementById("master-quiz-title");
        const bodyEl = document.getElementById("master-quiz-body");
        const feedbackEl = document.getElementById("master-quiz-feedback");

        if (!modal || !titleEl || !bodyEl) return;

        titleEl.textContent = masterQuiz.title;
        feedbackEl.textContent = "";
        bodyEl.innerHTML = "";

        // Scenario
        const scenarioDiv = document.createElement("div");
        scenarioDiv.className = "master-quiz-scenario";
        scenarioDiv.textContent = masterQuiz.scenario;
        bodyEl.appendChild(scenarioDiv);

        // Question
        const questionDiv = document.createElement("div");
        questionDiv.className = "quiz-question";
        const optionsHTML = masterQuiz.options
          .map(
            (opt, idx) => `
              <label class="quiz-option" data-option-index="${idx}">
                <input type="radio" name="master-quiz-option" value="${idx}" />
                <span><code>${opt}</code></span>
              </label>
            `
          )
          .join("");
        questionDiv.innerHTML = `
          <div class="quiz-question-title">${masterQuiz.question}</div>
          <div class="quiz-options">
            ${optionsHTML}
          </div>
        `;
        // Chicken-Button für Master-Quiz hinzufügen
        const chickenBtn = document.createElement("button");
        chickenBtn.type = "button";
        chickenBtn.className = "quiz-chicken-btn";
        chickenBtn.textContent = "🐔 Lösung zeigen";
        chickenBtn.dataset.correctIndex = masterQuiz.correctIndex;
        chickenBtn.addEventListener("click", function () {
          const correctIdx = parseInt(this.dataset.correctIndex);
          const optionsDiv = questionDiv.querySelector(".quiz-options");
          const allLabels = optionsDiv.querySelectorAll("label");
          allLabels.forEach((label, labelIdx) => {
            if (labelIdx === correctIdx) {
              label.classList.add("highlight-correct");
              const radio = label.querySelector("input[type=radio]");
              if (radio) radio.checked = true;
            } else {
              label.classList.remove("highlight-correct");
            }
          });
          this.disabled = true;
          this.style.opacity = "0.5";
          this.style.cursor = "not-allowed";
        });
        questionDiv.appendChild(chickenBtn);
        bodyEl.appendChild(questionDiv);

        modal.classList.remove("hidden");
        modal.setAttribute("aria-hidden", "false");
        currentMasterQuizSegment = segmentId;
      }

      // Close Master Quiz
      function closeMasterQuiz() {
        const modal = document.getElementById("master-quiz-root");
        if (modal) {
          modal.classList.add("hidden");
          modal.setAttribute("aria-hidden", "true");
        }
        currentMasterQuizSegment = null;
      }

      // Parse Hotkeys Content
      function parseHotkeysContent() {
        return [
          {
            title: "Navigation & Bewegung",
            items: [
              {
                shortcut: "H, J, K, L",
                description: "Cursor/Navigation (vim-Style)",
              },
              {
                shortcut: "↑ / ↓ / ← / →",
                description: "Klassische Navigation",
              },
              {
                shortcut: "Ctrl + U / Ctrl + D",
                description: "Halbseite hoch/runter",
              },
              {
                shortcut: "Ctrl + B / Ctrl + F",
                description: "Ganze Seite hoch/runter",
              },
            ],
          },
          {
            title: "Dateien & Verzeichnisse",
            items: [
              { shortcut: "Tab", description: "Autocomplete" },
              {
                shortcut: "Ctrl + R",
                description: "Reverse Search (vergangene Befehle finden)",
              },
              {
                shortcut: "Ctrl + A",
                description: "Cursor an den Anfang der Zeile",
              },
              {
                shortcut: "Ctrl + E",
                description: "Cursor ans Ende der Zeile",
              },
              { shortcut: "Ctrl + W", description: "Vorheriges Wort löschen" },
              {
                shortcut: "Ctrl + K",
                description: "Alles rechts vom Cursor löschen",
              },
              { shortcut: "Ctrl + C", description: "Prozess abbrechen" },
              { shortcut: "Ctrl + Z", description: "Prozess pausieren" },
              { shortcut: "fg / bg", description: "Prozesse fortsetzen" },
            ],
          },
          {
            title: "Quality-of-Life-Improvements",
            items: [
              {
                shortcut: "alias",
                description: "Alias erstellen (z. B. alias ll='ls -la')",
              },
              {
                shortcut: "history",
                description: "History mit Zeitstempeln aktivieren",
              },
              {
                shortcut: "less",
                description: "Statt cat für lange Dateien nutzen",
              },
              {
                shortcut: "fzf",
                description: "Fuzzy Suche in Dateien + History",
              },
              {
                shortcut: "ripgrep (rg)",
                description: "Statt grep benutzen – deutlich schneller",
              },
            ],
          },
          {
            title: "Dateien & Navigation",
            items: [
              {
                shortcut: "nnn / ranger",
                description: "Visuelle Terminal-Dateimanager",
              },
              {
                shortcut: "zoxide",
                description: "Ultraschnelles Wechseln zwischen Verzeichnissen",
              },
              {
                shortcut: "bat",
                description: "Moderne cat-Alternative mit Syntax-Highlighting",
              },
              {
                shortcut: "fd",
                description: "Moderne, intuitive Alternative zu find",
              },
            ],
          },
          {
            title: "Skript-Workflow",
            items: [
              { shortcut: "#!/bin/bash", description: "Shell-Skripte starten" },
              { shortcut: "set -e", description: "Script stoppt bei Fehlern" },
              {
                shortcut: "chmod +x",
                description: "Skripte ausführbar machen",
              },
            ],
          },
          {
            title: "Produktivität",
            items: [
              {
                shortcut: "tmux",
                description: "Terminal in Sessions splitten",
              },
              { shortcut: "SSH-Keys", description: "Statt Passwort" },
              {
                shortcut: ".bashrc /.zshrc",
                description: "Custom prompts – schnelleres visuelles Feedback",
              },
            ],
          },
          {
            title: "Fehler vermeiden",
            items: [
              {
                shortcut: "--dry-run",
                description: "Optionen nutzen (wo verfügbar)",
              },
              {
                shortcut: "mv -i / cp -i / rm -i",
                description: "Interaktive Rückfrage aktivieren",
              },
              {
                shortcut: "Trash-CLI",
                description: "Statt sofortigem Löschen",
              },
            ],
          },
        ];
      }

      // Parse Kali Tools Content
      function parseKaliToolsContent() {
        return [
          {
            title: "Grund-Setup nach Installation",
            items: [
              {
                name: "System aktualisieren",
                command: "sudo apt update && sudo apt full-upgrade -y",
                description:
                  "Aktualisiert alle Pakete und das System auf den neuesten Stand.",
                benefit:
                  "Stellt sicher, dass alle Tools aktuell und sicherheitsrelevante Updates installiert sind.",
                example:
                  "Nach der Installation von Kali Linux sollte dies dein erster Befehl sein. Führt eine vollständige Systemaktualisierung durch und installiert alle verfügbaren Updates für maximalen Schutz und Kompatibilität.",
                badgeRequired: null,
                difficulty: "easy",
              },
              {
                name: "Kali-Tweaks",
                command: "sudo kali-tweaks",
                description:
                  "Interaktives Konfigurationstool für Shell, Mirrors, VM-Optimierungen und Hardening.",
                benefit:
                  "Ermöglicht schnelle Systemoptimierung ohne manuelle Konfiguration mehrerer Dateien.",
                example:
                  "Öffnet ein interaktives Menü, in dem du Shell-Einstellungen (z.B. Zsh), Repository-Mirrors, VM-Optimierungen und Sicherheits-Hardening-Optionen konfigurieren kannst. Perfekt für eine schnelle Erstkonfiguration.",
                badgeRequired: null,
                difficulty: "easy",
              },
              {
                name: "Firewall einrichten (UFW)",
                command:
                  "sudo apt install ufw\nsudo ufw default deny incoming\nsudo ufw default allow outgoing\nsudo ufw enable",
                description:
                  "Konfiguriert eine einfache Firewall: blockiert eingehende, erlaubt ausgehende Verbindungen.",
                benefit:
                  "Grundlegender Schutz vor unerwünschten Netzwerkzugriffen während Pentesting-Aktivitäten.",
                example:
                  "Installiert und konfiguriert UFW (Uncomplicated Firewall): Blockiert standardmäßig alle eingehenden Verbindungen, erlaubt aber alle ausgehenden. Überprüfe den Status mit 'sudo ufw status'.",
                badgeRequired: null,
                difficulty: "easy",
              },
            ],
          },
          {
            title: "Wichtige Metapackages",
            items: [
              {
                name: "kali-linux-top10",
                command: "sudo apt install kali-linux-top10",
                description:
                  "Installiert die 10 wichtigsten Standardtools von Kali Linux in einem Paket.",
                benefit:
                  "Perfekt für Einsteiger – installiert automatisch die essentiellen Tools, die du am häufigsten brauchst.",
                example:
                  "Installiert in einem Schritt: Nmap, Wireshark, Metasploit, Aircrack-ng, Burp Suite, John the Ripper, Hydra, sqlmap, OWASP ZAP und Social Engineering Toolkit. Perfekt für den Start!",
                badgeRequired: "segment1",
                difficulty: "medium",
              },
              {
                name: "kali-linux-default",
                command: "sudo apt install kali-linux-default",
                description:
                  "Vollständige Desktop-Grundausstattung mit allen Standardtools.",
                benefit:
                  "Ideal für eine komplette Kali-Installation mit allen wichtigen Tools auf einmal.",
                example:
                  "Installiert alle Standard-Pentesting-Tools die in Kali Linux enthalten sind. Ideal für eine vollständige Installation, benötigt aber mehr Speicherplatz und Zeit.",
                badgeRequired: "segment1",
                difficulty: "medium",
              },
              {
                name: "kali-tools-web",
                command: "sudo apt install kali-tools-web",
                description:
                  "Tool-Sammlung speziell für Web-Pentesting und Web-Anwendungs-Tests.",
                benefit:
                  "Konzentriert alle Web-Testing-Tools an einem Ort – effizient für Web-Sicherheitstests.",
                example:
                  "Installiert Tools wie Burp Suite, OWASP ZAP, sqlmap, Nikto, dirb, wpscan und viele weitere Web-Pentesting-Tools. Ideal wenn du dich auf Web-Anwendungstests spezialisierst.",
                badgeRequired: "segment3",
                difficulty: "advanced",
              },
              {
                name: "kali-tools-802-11",
                command: "sudo apt install kali-tools-802-11",
                description:
                  "Tools für WLAN-Sicherheitstests und Wireless-Netzwerk-Analyse.",
                benefit:
                  "Unverzichtbar für Wireless-Pentesting – alles was du für WLAN-Tests brauchst.",
                example:
                  "Installiert Aircrack-ng Suite, Reaver, Wifite, Fern WiFi Cracker und weitere WLAN-Testing-Tools. Erfordert eine kompatible WLAN-Karte mit Monitor-Mode-Unterstützung.",
                badgeRequired: "segment5",
                difficulty: "expert",
              },
              {
                name: "kali-tools-reverse-engineering",
                command: "sudo apt install kali-tools-reverse-engineering",
                description:
                  "Umfangreiche Toolsammlung für Reverse Engineering und Exploit-Entwicklung.",
                benefit:
                  "Für fortgeschrittene Sicherheitsforschung und Malware-Analyse essentiell.",
                example:
                  "Installiert Tools wie Ghidra, Radare2, IDA Free, Binary Ninja, APKTool, JD-GUI und weitere Reverse-Engineering-Tools. Für Malware-Analyse und Exploit-Entwicklung.",
                badgeRequired: "segment5",
                difficulty: "expert",
              },
            ],
          },
          {
            title: "Netzwerk & Reconnaissance",
            items: [
              {
                name: "Nmap",
                command: "sudo apt install nmap",
                description:
                  "Der Standard-Portscanner zum Erkunden von Netzwerken und offenen Ports.",
                benefit:
                  "Das wichtigste Tool für Netzwerk-Reconnaissance – zeigt dir alle erreichbaren Dienste auf.",
                example:
                  "Beispiel: 'nmap -sV -p 80,443 192.168.1.1' scannt die Ports 80 und 443 auf einem Host und versucht die Dienstversionen zu identifizieren. 'nmap -sn 192.168.1.0/24' führt einen Ping-Scan eines ganzen Netzwerks durch.",
                badgeRequired: "segment1",
                difficulty: "medium",
              },
              {
                name: "Wireshark",
                command: "sudo apt install wireshark",
                description:
                  "GUI-basierter Netzwerk-Protokoll-Analysator für tiefgreifende Traffic-Analyse.",
                benefit:
                  "Unverzichtbar zum Verstehen von Netzwerk-Kommunikation und zum Identifizieren von Anomalien.",
                example:
                  "Starte Wireshark mit 'wireshark' (GUI) oder verwende 'tshark' (CLI). Fange Traffic auf einer Netzwerkschnittstelle ab, filtere nach Protokollen (z.B. 'http' oder 'tcp.port == 80') und analysiere Pakete im Detail.",
                badgeRequired: "segment1",
                difficulty: "medium",
              },
            ],
          },
          {
            title: "Web & Dienste",
            items: [
              {
                name: "Burp Suite Community",
                command: "sudo apt install burpsuite",
                description:
                  "HTTP/HTTPS-Proxy zum Abfangen und Manipulieren von Web-Anfragen.",
                benefit:
                  "Das Standard-Tool für Web-Pentesting – ermöglicht detaillierte Analyse und Exploitation von Web-Apps.",
                example:
                  "Starte Burp Suite mit 'burpsuite'. Konfiguriere deinen Browser auf localhost:8080 als Proxy. Alle HTTP/HTTPS-Requests werden abgefangen. Verwende den Repeater um Anfragen zu manipulieren, den Intruder für Bruteforce-Angriffe oder den Scanner für automatische Schwachstellensuche.",
                badgeRequired: "segment3",
                difficulty: "advanced",
              },
              {
                name: "sqlmap",
                command: "sudo apt install sqlmap",
                description:
                  "Automatisiertes Tool zum Testen und Exploitieren von SQL-Injection-Schwachstellen.",
                benefit:
                  "Spart enorm Zeit bei SQL-Injection-Tests und zeigt dir direkt verwertbare Exploits.",
                example:
                  "Beispiel: 'sqlmap -u \"http://example.com/page?id=1\" --dbs' testet auf SQL-Injection und listet Datenbanken auf. Mit '--dump -D database_name -T table_name' kannst du Tabellen auslesen. '--os-shell' versucht eine interaktive Shell zu erhalten.",
                badgeRequired: "segment3",
                difficulty: "advanced",
              },
            ],
          },
          {
            title: "Exploitation",
            items: [
              {
                name: "Metasploit Framework",
                command: "sudo apt install metasploit-framework",
                description:
                  "Umfassendes Framework für Exploit-Entwicklung, -Testing und Post-Exploitation.",
                benefit:
                  "Das mächtigste Exploitation-Tool – bietet tausende vorgefertigte Exploits und Payloads.",
                example:
                  "Starte msfconsole mit 'msfconsole'. Suche nach Exploits mit 'search [dienst]', z.B. 'search apache'. Nutze einen Exploit mit 'use exploit/...', setze Parameter mit 'set RHOSTS 192.168.1.1', und führe aus mit 'exploit'. Mit 'show payloads' siehst du verfügbare Payloads.",
                badgeRequired: "segment5",
                difficulty: "expert",
              },
            ],
          },
          {
            title: "Passwörter & Credentials",
            items: [
              {
                name: "Hydra",
                command: "sudo apt install hydra",
                description:
                  "Bruteforce-Tool für Passwörter und verschiedene Netzwerkdienste (SSH, FTP, HTTP, etc.).",
                benefit:
                  "Ermöglicht schnelles Testen von Login-Credentials gegen verschiedene Dienste.",
                example:
                  "Beispiel SSH: 'hydra -l admin -P passwords.txt ssh://192.168.1.1' testet das Passwort 'admin' mit einer Passwortliste. Für HTTP-Basic-Auth: 'hydra -l admin -P passwords.txt http-get://192.168.1.1/login'. Verwende 'hydra -h' für alle Optionen.",
                badgeRequired: "segment3",
                difficulty: "advanced",
              },
              {
                name: "John the Ripper",
                command: "sudo apt install john",
                description:
                  "Schneller Passwort-Cracker für offline Hash-Cracking und Passwort-Analyse.",
                benefit:
                  "Effizient beim Knacken gehashter Passwörter – unterstützt viele Hash-Algorithmen.",
                example:
                  "Speichere Hashes in einer Datei (z.B. hashes.txt). Verwende 'john hashes.txt' für Standard-Cracking. Mit 'john --wordlist=passwords.txt hashes.txt' verwendest du eine Passwortliste. 'john --show hashes.txt' zeigt geknackte Passwörter an.",
                badgeRequired: "segment4",
                difficulty: "advanced",
              },
            ],
          },
          {
            title: "WLAN (optional)",
            items: [
              {
                name: "Aircrack-ng Suite",
                command: "sudo apt install aircrack-ng",
                description:
                  "Komplett-Suite für WLAN-Sicherheitstests: Sniffing, Cracking, Angriffe auf WLAN-Netzwerke.",
                benefit:
                  "Das Standard-Tool für Wireless-Pentesting – von Netzwerk-Analyse bis Passwort-Cracking.",
                example:
                  "Workflow: 1) 'airmon-ng start wlan0' aktiviert Monitor-Mode, 2) 'airodump-ng wlan0mon' listet WLAN-Netzwerke, 3) 'airodump-ng -c [Kanal] --bssid [MAC] -w capture wlan0mon' fängt Handshakes ab, 4) 'aircrack-ng -w wordlist.txt capture.cap' crackt das Passwort. Benötigt kompatible WLAN-Karte.",
                badgeRequired: "segment5",
                difficulty: "expert",
              },
            ],
          },
          {
            title: "Shell & Workflow",
            items: [
              {
                name: "Zsh",
                command: "sudo apt install zsh",
                description:
                  "Erweiterte Shell mit besserer Autovervollständigung, Plugins und Themes.",
                benefit:
                  "Verbessert deine Produktivität drastisch – besonders mit Oh My Zsh für Customization.",
                example:
                  "Nach Installation: 'chsh -s $(which zsh)' setzt Zsh als Standard-Shell. Installiere Oh My Zsh mit: 'sh -c \"$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"'. Konfiguriere Plugins und Themes in ~/.zshrc.",
                badgeRequired: "segment1",
                difficulty: "medium",
              },
              {
                name: "tmux",
                command: "sudo apt install tmux",
                description:
                  "Terminal-Multiplexer zum Splitten von Terminal-Fenstern und Session-Management.",
                benefit:
                  "Ermöglicht paralleles Arbeiten mit mehreren Terminal-Sessions – essentiell für komplexe Pentests.",
                example:
                  "Starte tmux mit 'tmux'. Tastenkombinationen (Standard-Präfix: Ctrl+b): Split horizontal 'C-b %', split vertikal 'C-b \"', wechsle zwischen Panes mit 'C-b Pfeiltasten', erstelle neues Fenster 'C-b c', liste Sessions 'tmux ls', attach Session 'tmux attach -t [name]'.",
                badgeRequired: "segment2",
                difficulty: "medium",
              },
            ],
          },
          {
            title: "Entwicklungsumgebung",
            items: [
              {
                name: "Git",
                command: "sudo apt install git",
                description:
                  "Versionskontroll-System für Code- und Script-Verwaltung.",
                benefit:
                  "Unverzichtbar für Organisierung deiner Exploits, Scripts und Pentesting-Tools.",
                example:
                  "Konfiguriere Git: 'git config --global user.name \"Dein Name\"' und 'git config --global user.email \"email@example.com\"'. Erstelle Repo: 'git init', füge Dateien hinzu: 'git add .', committe: 'git commit -m \"Message\"', klone Repos: 'git clone https://github.com/user/repo.git'.",
                badgeRequired: "segment1",
                difficulty: "medium",
              },
              {
                name: "curl",
                command: "sudo apt install curl",
                description:
                  "Kommandozeilen-Tool für HTTP/HTTPS-Anfragen und API-Testing.",
                benefit:
                  "Schnelle Möglichkeit Web-Requests zu testen und API-Endpunkte zu analysieren.",
                example:
                  "Einfacher GET-Request: 'curl http://example.com'. POST mit Daten: 'curl -X POST -d \"key=value\" http://example.com/api'. Mit Headers: 'curl -H \"Authorization: Bearer token\" http://example.com/api'. Output speichern: 'curl -o file.html http://example.com'.",
                badgeRequired: "segment2",
                difficulty: "medium",
              },
              {
                name: "build-essential",
                command: "sudo apt install build-essential",
                description:
                  "Grundlegende Compiler und Build-Tools (gcc, make, etc.) für Software-Kompilierung.",
                benefit:
                  "Benötigt um viele Exploits und Tools aus Source-Code zu kompilieren.",
                example:
                  "Enthält gcc (C-Compiler), g++ (C++-Compiler), make (Build-Automation) und weitere Entwickler-Tools. Nach Installation kannst du Source-Code kompilieren: 'gcc program.c -o program' oder 'make' in einem Projekt-Verzeichnis ausführen.",
                badgeRequired: "segment2",
                difficulty: "medium",
              },
              {
                name: "Neovim",
                command: "sudo apt install neovim",
                description:
                  "Moderner Vim-Editor mit verbesserter Plugin-Unterstützung und Konfiguration.",
                benefit:
                  "Ermöglicht effizientes Scripting und Code-Editieren direkt im Terminal.",
                example:
                  "Starte Neovim mit 'nvim datei.txt'. Basis-Befehle: Insert-Mode 'i', Normal-Mode ESC, speichern und beenden ':wq', speichern ':w', beenden ohne speichern ':q!'. Erweitere mit Plugins über Plugin-Manager wie vim-plug in ~/.config/nvim/init.vim.",
                badgeRequired: "segment2",
                difficulty: "medium",
              },
              {
                name: "kali-system-gui",
                command: "sudo apt install kali-system-gui",
                description:
                  "GUI-Werkzeuge und Desktop-Umgebungskomponenten für Kali Linux.",
                benefit:
                  "Stellt sicher, dass alle grafischen Tools und Desktop-Funktionen verfügbar sind.",
                example:
                  "Installiert alle GUI-Komponenten und Desktop-Umgebungstools für Kali Linux. Erforderlich wenn du grafische Tools wie Wireshark GUI, Burp Suite oder andere GUI-basierte Pentesting-Tools verwenden möchtest.",
                badgeRequired: "segment1",
                difficulty: "medium",
              },
            ],
          },
          {
            title: "Netzwerk, VPN & Remote",
            items: [
              {
                name: "OpenVPN / Wireguard",
                command: "sudo apt install openvpn wireguard",
                description:
                  "VPN-Lösungen für sichere, verschlüsselte Verbindungen zu Remote-Netzwerken.",
                benefit:
                  "Essentiell für sicheres Pentesting über das Internet und Zugriff auf isolierte Netzwerke.",
                example:
                  "OpenVPN: Verbinde dich mit 'sudo openvpn --config client.ovpn'. Wireguard: Konfiguriere in /etc/wireguard/wg0.conf, starte mit 'sudo wg-quick up wg0', stoppe mit 'sudo wg-quick down wg0'. Status prüfen: 'sudo wg show'.",
                badgeRequired: "segment2",
                difficulty: "medium",
              },
              {
                name: "SSH Server",
                command: "sudo apt install openssh-server",
                description:
                  "Ermöglicht Remote-Zugriff auf dein Kali-System via Secure Shell.",
                benefit:
                  "Ermöglicht Remote-Zugriff auf dein System – nützlich für Pentests von verschiedenen Standorten.",
                example:
                  "Nach Installation startet der SSH-Service automatisch. Verbinde dich von einem anderen System: 'ssh benutzer@kali-ip'. Mit SSH-Key-Authentifizierung: 'ssh-keygen -t rsa' erstellt Keys, 'ssh-copy-id benutzer@kali-ip' kopiert öffentlichen Key. SSH-Konfiguration in /etc/ssh/sshd_config.",
                badgeRequired: "segment1",
                difficulty: "medium",
              },
            ],
          },
        ];
      }

      // Open Hotkeys Modal
      function openHotkeysModal() {
        const modal = document.getElementById("hotkeys-root");
        const bodyEl = document.getElementById("hotkeys-body");

        if (!modal || !bodyEl) return;

        bodyEl.innerHTML = "";
        const sections = parseHotkeysContent();

        sections.forEach((section) => {
          const sectionDiv = document.createElement("div");
          sectionDiv.className = "hotkeys-section";

          const title = document.createElement("div");
          title.className = "hotkeys-section-title";
          title.textContent = section.title;
          sectionDiv.appendChild(title);

          section.items.forEach((item) => {
            const itemDiv = document.createElement("div");
            itemDiv.className = "hotkeys-item";
            itemDiv.innerHTML = `
              <span class="hotkeys-shortcut">${item.shortcut}</span>
              <span class="hotkeys-description">– ${item.description}</span>
            `;
            sectionDiv.appendChild(itemDiv);
          });

          bodyEl.appendChild(sectionDiv);
        });

        modal.classList.remove("hidden");
        modal.setAttribute("aria-hidden", "false");
      }

      // Close Hotkeys Modal
      function closeHotkeysModal() {
        const modal = document.getElementById("hotkeys-root");
        if (modal) {
          modal.classList.add("hidden");
          modal.setAttribute("aria-hidden", "true");
        }
      }

      // Open Kali Tools Modal
      function openKaliToolsModal() {
        const modal = document.getElementById("kali-tools-root");
        const bodyEl = document.getElementById("kali-tools-body");

        if (!modal || !bodyEl) return;

        bodyEl.innerHTML = "";
        const sections = parseKaliToolsContent();

        sections.forEach((section) => {
          const sectionDiv = document.createElement("div");
          sectionDiv.className = "kali-tools-section";

          const title = document.createElement("div");
          title.className = "kali-tools-section-title";
          title.textContent = section.title;
          sectionDiv.appendChild(title);

          section.items.forEach((item) => {
            const itemDiv = document.createElement("div");
            itemDiv.className = "kali-tools-item";

            // Check if item is locked
            const isUnlocked = checkBadgeUnlocked(item.badgeRequired);

            // Get badge info if required
            let badgeHtml = "";
            if (item.badgeRequired) {
              const segment = badgeSegments.find(
                (s) => s.id === item.badgeRequired
              );
              if (segment) {
                const progress = getSegmentProgress(item.badgeRequired);
                const totalQuizzes = segment.quizIds.length;
                badgeHtml = `<div class="kali-tools-item-badge" style="display: inline-flex; align-items: center; gap: 0.3rem; margin-bottom: 0.4rem; padding: 0.2rem 0.5rem; border-radius: 0.4rem; background: ${
                  isUnlocked
                    ? "rgba(34, 197, 94, 0.15)"
                    : "rgba(239, 68, 68, 0.15)"
                }; border: 1px solid ${
                  isUnlocked
                    ? "rgba(34, 197, 94, 0.4)"
                    : "rgba(239, 68, 68, 0.4)"
                }; font-size: 0.8rem;">
                  <span>${segment.icon}</span>
                  <span style="color: ${
                    isUnlocked ? "#86efac" : "#fca5a5"
                  }; font-weight: 500;">${segment.name}</span>
                  <span style="color: ${
                    isUnlocked ? "#86efac" : "#fca5a5"
                  }; opacity: 0.8; font-size: 0.75rem;">${progress}/${totalQuizzes}</span>
                </div>`;
              }
            }

            let html = badgeHtml;
            html += `<span class="kali-tools-name">${item.name}</span>`;
            html += `<div class="kali-tools-description">${item.description}</div>`;

            if (item.benefit) {
              html += `<div class="kali-tools-benefit">💡 ${item.benefit}</div>`;
            }

            if (item.command) {
              // Format multi-line commands
              const formattedCommand = item.command
                .split("\n")
                .map((line) => line.trim())
                .filter((line) => line.length > 0)
                .join("\n");

              // Add chicken button for command if locked
              let commandHtml = `<div class="kali-tools-command">${formattedCommand.replace(
                /\n/g,
                "<br>"
              )}</div>`;

              // Add unlock button for command section if locked
              if (!isUnlocked && item.badgeRequired) {
                commandHtml += `<div style="margin-top: 0.5rem;">
                  <button type="button" class="kali-tools-chicken-btn" data-tool-name="${item.name.replace(
                    /"/g,
                    "&quot;"
                  )}" data-segment-id="${
                  item.badgeRequired
                }" data-unlock-type="command" title="Klicken um Inhalt ohne Quiz freizuschalten">🐔 Freischalten</button>
                </div>`;
              }

              html += commandHtml;
            }

            // Add example with blur logic
            if (item.example) {
              const blurredClass = isUnlocked
                ? ""
                : "kali-tools-example-blurred";

              html += `<div class="kali-tools-example ${blurredClass}">`;
              html += `<div class="kali-tools-example-title">`;
              html += `📝 Anwendungsbeispiel`;
              if (!isUnlocked && item.badgeRequired) {
                html += `<button type="button" class="kali-tools-chicken-btn" data-tool-name="${item.name.replace(
                  /"/g,
                  "&quot;"
                )}" data-segment-id="${
                  item.badgeRequired
                }" data-unlock-type="example" title="Klicken um Inhalt ohne Quiz freizuschalten">🐔 Freischalten</button>`;
              }
              html += `</div>`;
              html += `<div class="kali-tools-example-content">${item.example}</div>`;
              html += `</div>`;
            }

            itemDiv.innerHTML = html;

            // Add data attribute for badge requirement
            if (item.badgeRequired) {
              itemDiv.setAttribute("data-badge-required", item.badgeRequired);
            }

            // Attach chicken button event handlers for all chicken buttons
            if (!isUnlocked && item.badgeRequired) {
              const chickenBtns = itemDiv.querySelectorAll(
                ".kali-tools-chicken-btn"
              );
              chickenBtns.forEach((chickenBtn) => {
                chickenBtn.addEventListener("click", (e) => {
                  e.stopPropagation();

                  // Unlock via chicken button
                  unlockBadgeViaChicken(item.badgeRequired);

                  // Remove blur from example if present
                  const exampleDiv = itemDiv.querySelector(
                    ".kali-tools-example"
                  );
                  if (exampleDiv) {
                    exampleDiv.classList.remove("kali-tools-example-blurred");
                  }

                  // Remove all chicken buttons from this item
                  const allChickenBtns = itemDiv.querySelectorAll(
                    ".kali-tools-chicken-btn"
                  );
                  allChickenBtns.forEach((btn) => {
                    const btnParent = btn.parentElement;
                    if (btnParent && btnParent.tagName === "DIV") {
                      btn.remove();
                    } else {
                      btn.remove();
                    }
                  });

                  // Update badge display in item
                  const segment = badgeSegments.find(
                    (s) => s.id === item.badgeRequired
                  );
                  if (segment) {
                    const progress = getSegmentProgress(item.badgeRequired);
                    const totalQuizzes = segment.quizIds.length;
                    const badgeDiv = itemDiv.querySelector(
                      ".kali-tools-item-badge"
                    );
                    if (badgeDiv) {
                      badgeDiv.style.background = "rgba(34, 197, 94, 0.15)";
                      badgeDiv.style.borderColor = "rgba(34, 197, 94, 0.4)";
                      const spans = badgeDiv.querySelectorAll("span");
                      spans.forEach((span) => {
                        if (!span.textContent.match(/[\u{1F300}-\u{1F9FF}]/u)) {
                          span.style.color = "#86efac";
                        }
                      });
                    }
                  }

                  // Update badges display in header
                  updateKaliToolsBadges();

                  // Re-render the entire modal to update all items
                  setTimeout(() => {
                    openKaliToolsModal();
                  }, 100);

                  // Show feedback
                  const feedback = document.createElement("div");
                  feedback.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: rgba(34, 197, 94, 0.9);
                    color: white;
                    padding: 1rem 1.5rem;
                    border-radius: 0.5rem;
                    z-index: 100;
                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                    animation: slideIn 0.3s ease-out;
                  `;
                  feedback.textContent = `🐔 Inhalt freigeschaltet!`;
                  document.body.appendChild(feedback);
                  setTimeout(() => {
                    feedback.style.animation = "slideOut 0.3s ease-out";
                    setTimeout(() => feedback.remove(), 300);
                  }, 2000);

                  // Open overlay for example if it was an example button
                  const unlockType =
                    chickenBtn.getAttribute("data-unlock-type");
                  if (unlockType === "example" && item.example) {
                    openExampleOverlay(item);
                  }
                });
              });
            }

            sectionDiv.appendChild(itemDiv);
          });

          bodyEl.appendChild(sectionDiv);
        });

        // Update badges display AFTER rendering content
        setTimeout(() => {
          updateKaliToolsBadges();
        }, 0);

        modal.classList.remove("hidden");
        modal.setAttribute("aria-hidden", "false");
      }

      // Close Kali Tools Modal
      function closeKaliToolsModal() {
        const modal = document.getElementById("kali-tools-root");
        if (modal) {
          modal.classList.add("hidden");
          modal.setAttribute("aria-hidden", "true");
        }
      }

      // Check if badge is unlocked (including chicken button unlocks)
      function checkBadgeUnlocked(segmentId) {
        if (!segmentId) return true; // No badge required = always unlocked

        // Check if unlocked via chicken button
        const chickenUnlocks = localStorage.getItem("kaliToolsChickenUnlocks");
        if (chickenUnlocks) {
          try {
            const unlocks = JSON.parse(chickenUnlocks);
            if (unlocks[segmentId]) return true;
          } catch (e) {
            // Ignore parse errors
          }
        }

        const stored = localStorage.getItem("badgeProgress");
        if (!stored) return false;

        try {
          const badgeProgress = JSON.parse(stored);
          const progress = badgeProgress[segmentId] || 0;

          // Find segment
          const segment = badgeSegments.find((s) => s.id === segmentId);
          if (!segment) return false;

          // Check if segment is complete (all quizzes done)
          const isComplete = progress >= segment.quizIds.length;

          // Check if master quiz is completed
          const masterStored = localStorage.getItem("masterQuizResults");
          if (masterStored) {
            try {
              const masterResults = JSON.parse(masterStored);
              if (masterResults[segmentId]) return true; // Master quiz completed = unlocked
            } catch (e) {
              // Ignore parse errors
            }
          }

          return isComplete;
        } catch (e) {
          return false;
        }
      }

      // Unlock badge via chicken button
      function unlockBadgeViaChicken(segmentId) {
        if (!segmentId) return;

        let unlocks = {};
        const stored = localStorage.getItem("kaliToolsChickenUnlocks");
        if (stored) {
          try {
            unlocks = JSON.parse(stored);
          } catch (e) {
            unlocks = {};
          }
        }

        unlocks[segmentId] = true;
        localStorage.setItem(
          "kaliToolsChickenUnlocks",
          JSON.stringify(unlocks)
        );
      }

      // Update badges display in Kali Tools Modal
      function updateKaliToolsBadges() {
        const container = document.getElementById(
          "kali-tools-badges-container"
        );
        if (!container) return;

        container.innerHTML = "";

        // Get all unique badge requirements from Kali Tools items
        const sections = parseKaliToolsContent();
        const requiredSegments = new Set();

        sections.forEach((section) => {
          section.items.forEach((item) => {
            if (item.badgeRequired) {
              requiredSegments.add(item.badgeRequired);
            }
          });
        });

        // Display badges for required segments
        Array.from(requiredSegments).forEach((segmentId) => {
          const segment = badgeSegments.find((s) => s.id === segmentId);
          if (!segment) return;

          const isUnlocked = checkBadgeUnlocked(segmentId);
          const progress = getSegmentProgress(segmentId);
          const totalQuizzes = segment.quizIds.length;
          const progressPercentage =
            totalQuizzes > 0 ? Math.round((progress / totalQuizzes) * 100) : 0;

          const badge = document.createElement("div");
          badge.className = `kali-tools-badge ${
            isUnlocked ? "unlocked" : "locked"
          }`;

          badge.innerHTML = `
            <span class="kali-tools-badge-icon">${segment.icon}</span>
            <span class="kali-tools-badge-name">${segment.name}</span>
            <span class="kali-tools-badge-progress">${progress}/${totalQuizzes}</span>
          `;

          badge.title = isUnlocked
            ? `${segment.name} freigeschaltet (${progressPercentage}%)`
            : `${segment.name} benötigt: ${progress}/${totalQuizzes} Quiz abgeschlossen (${progressPercentage}%)`;

          // Click handler: scroll to relevant section or show info
          badge.addEventListener("click", () => {
            // Find first item with this badge requirement and scroll to it
            const firstItem = document.querySelector(
              `.kali-tools-item[data-badge-required="${segmentId}"]`
            );
            if (firstItem) {
              firstItem.scrollIntoView({ behavior: "smooth", block: "center" });
              // Highlight briefly
              firstItem.style.background = "rgba(239, 68, 68, 0.2)";
              setTimeout(() => {
                firstItem.style.background = "";
              }, 2000);
            }
          });

          container.appendChild(badge);
        });
      }

      // Open example overlay
      function openExampleOverlay(tool) {
        const overlay = document.getElementById("kali-tools-example-overlay");
        const overlayInner = document.getElementById(
          "kali-tools-example-overlay-inner"
        );
        const overlayTitle = document.getElementById(
          "kali-tools-example-overlay-title"
        );
        const overlayContent = document.getElementById(
          "kali-tools-example-overlay-content"
        );

        if (!overlay || !overlayInner || !overlayTitle || !overlayContent)
          return;

        overlayTitle.textContent = tool.name;

        let contentHTML = `<div class="kali-tools-name">${tool.name}</div>`;
        contentHTML += `<div class="kali-tools-description">${tool.description}</div>`;

        if (tool.benefit) {
          contentHTML += `<div class="kali-tools-benefit">💡 ${tool.benefit}</div>`;
        }

        if (tool.command) {
          const formattedCommand = tool.command
            .split("\n")
            .map((line) => line.trim())
            .filter((line) => line.length > 0)
            .join("\n");
          contentHTML += `<div class="kali-tools-command">${formattedCommand.replace(
            /\n/g,
            "<br>"
          )}</div>`;
        }

        if (tool.example) {
          contentHTML += `<div class="kali-tools-example" style="margin-top: 1rem;">
            <div class="kali-tools-example-title">📝 Anwendungsbeispiel</div>
            <div class="kali-tools-example-content">${tool.example}</div>
          </div>`;
        }

        overlayContent.innerHTML = contentHTML;
        overlay.classList.remove("hidden");
        overlay.setAttribute("aria-hidden", "false");
      }

      // Close example overlay
      function closeExampleOverlay() {
        const overlay = document.getElementById("kali-tools-example-overlay");
        if (overlay) {
          overlay.classList.add("hidden");
          overlay.setAttribute("aria-hidden", "true");
        }
      }

      let currentMasterQuizSegment = null;

      // Initial load achievements and badges
      migrateToBadgeProgress();
      updateAchievements();
      updateBadgeDisplay();
      assignBadgeToCards();

      commandCards.forEach((card) => {
        const quizId = card.dataset.quizId;
        if (!quizId) return;
        card.addEventListener("click", () => {
          openQuiz(quizId);
        });
      });

      // Helper function to search in quiz data
      function searchInQuizData(quizId, query) {
        if (!query || !quizId) return false;

        const quiz = quizData[quizId];
        if (!quiz) return false;

        const queryLower = query.toLowerCase();

        // Search in all text fields of the quiz
        const searchFields = [
          quiz.title,
          quiz.description,
          quiz.explanation,
          quiz.detail,
          quiz.simpleExample,
          quiz.complexExample,
          quiz.additionalExamples,
        ];

        // Search in questions
        if (quiz.questions && Array.isArray(quiz.questions)) {
          quiz.questions.forEach((q) => {
            if (q.prompt) searchFields.push(q.prompt);
            if (q.explanation) searchFields.push(q.explanation);
            if (q.options && Array.isArray(q.options)) {
              q.options.forEach((opt) => searchFields.push(opt));
            }
          });
        }

        // Search in complex example explanations
        if (
          quiz.complexExampleExplanation &&
          Array.isArray(quiz.complexExampleExplanation)
        ) {
          quiz.complexExampleExplanation.forEach((exp) => {
            if (exp.line) searchFields.push(exp.line);
            if (exp.explanation) searchFields.push(exp.explanation);
          });
        }

        // Check if query matches any field
        return searchFields.some((field) => {
          if (!field) return false;
          // Remove HTML tags for searching
          const text =
            typeof field === "string"
              ? field.replace(/<[^>]*>/g, "").toLowerCase()
              : String(field).toLowerCase();
          return text.includes(queryLower);
        });
      }

      // Search functionality
      const searchInput = document.getElementById("search-input");
      if (searchInput) {
        searchInput.addEventListener("input", (e) => {
          const query = e.target.value.toLowerCase().trim();

          // Finde das aktive Segment (falls vorhanden)
          const segment = activeFilterSegment
            ? badgeSegments.find((s) => s.id === activeFilterSegment)
            : null;

          // Finde Achievement-Quiz-IDs (falls Achievement-Filter aktiv)
          const achievementQuizIds = activeFilterAchievement
            ? getQuizIdsForAchievement(activeFilterAchievement)
            : null;

          commandCards.forEach((card) => {
            const quizId = card.dataset.quizId;

            // Prüfe zuerst, ob die Karte zum aktiven Segment gehört
            let belongsToSegment = true;
            if (segment) {
              belongsToSegment = segment.quizIds.includes(quizId);
            }

            // Prüfe ob Karte zum Achievement-Filter gehört
            let belongsToAchievement = true;
            if (achievementQuizIds) {
              belongsToAchievement = achievementQuizIds.includes(quizId);
            }

            // Wenn Filter aktiv und Karte gehört nicht dazu, verstecken
            if (
              (segment && !belongsToSegment) ||
              (achievementQuizIds && !belongsToAchievement)
            ) {
              card.classList.add("hidden");
              return;
            }

            // Dann prüfe Suchanfrage
            const command = card.dataset.command?.toLowerCase() || "";
            const tag =
              card.querySelector(".command-tag")?.textContent.toLowerCase() ||
              "";
            const body =
              card.querySelector(".command-body")?.textContent.toLowerCase() ||
              "";

            // Search in card content
            const matchesCardContent =
              !query ||
              command.includes(query) ||
              tag.includes(query) ||
              body.includes(query);

            // Search in quiz data (explanations, examples, questions)
            const matchesQuizData = !query || searchInQuizData(quizId, query);

            const matches = matchesCardContent || matchesQuizData;

            // Karte verstecken, wenn sie nicht zur Suche passt
            if (!matches) {
              card.classList.add("hidden");
            } else if (!segment && !achievementQuizIds) {
              // Wenn kein Filter aktiv ist, Karte anzeigen
              card.classList.remove("hidden");
            } else if (
              (segment && belongsToSegment) ||
              (achievementQuizIds && belongsToAchievement)
            ) {
              // Wenn Filter aktiv und Karte gehört dazu, anzeigen
              card.classList.remove("hidden");
            }
          });
        });
      }

      function openQuiz(quizId) {
        const quiz = quizData[quizId];
        if (!quiz) {
          console.warn("Kein Quiz definiert für:", quizId);
          return;
        }
        currentQuizId = quizId;
        quizTitleEl.textContent = "Quiz zu " + quiz.title;
        quizSubtitleEl.textContent = "3 Fragen: leicht · mittel · schwer";
        quizFeedbackEl.textContent = "";

        quizBodyEl.innerHTML = "";
        // Render command info (explanation + simple example) and a collapsible details block
        const infoWrapper = document.createElement("div");
        infoWrapper.className = "quiz-command-info";
        const titleRow = document.createElement("div");
        titleRow.className = "cmd-title";
        const titleCode = document.createElement("code");
        titleCode.textContent = quiz.title;
        titleRow.appendChild(titleCode);
        infoWrapper.appendChild(titleRow);

        const expl = document.createElement("div");
        expl.className = "cmd-expl";
        expl.textContent = quiz.explanation || quiz.description || "";
        infoWrapper.appendChild(expl);

        if (quiz.simpleExample) {
          const ex = document.createElement("div");
          ex.className = "cmd-example";
          ex.textContent = "Einfaches Beispiel: " + quiz.simpleExample;
          infoWrapper.appendChild(ex);
        }

        // details toggle + content
        const detailsToggle = document.createElement("button");
        detailsToggle.className = "quiz-details-toggle";
        detailsToggle.type = "button";
        detailsToggle.textContent = "Weitere Details anzeigen";
        const details = document.createElement("div");
        details.className = "quiz-details";
        if (quiz.detail) {
          const det = document.createElement("div");
          det.innerHTML = "<strong>Detail:</strong>\n" + quiz.detail;
          details.appendChild(det);
        }
        if (quiz.complexExample) {
          const comp = document.createElement("div");
          comp.style.marginTop = "0.5rem";
          comp.innerHTML =
            "<strong>Komplexeres Beispiel:</strong>\n" + quiz.complexExample;
          details.appendChild(comp);

          // Zeile-für-Zeile Erklärung hinzufügen
          if (
            quiz.complexExampleExplanation &&
            quiz.complexExampleExplanation.length > 0
          ) {
            const explanationToggle = document.createElement("button");
            explanationToggle.className = "quiz-details-toggle";
            explanationToggle.type = "button";
            explanationToggle.style.marginTop = "0.5rem";
            explanationToggle.textContent =
              "Zeile-für-Zeile Erklärung anzeigen";

            const explanationDiv = document.createElement("div");
            explanationDiv.className = "quiz-details complex-explanation";
            explanationDiv.style.display = "none";

            quiz.complexExampleExplanation.forEach((item, idx) => {
              const lineWrapper = document.createElement("div");
              lineWrapper.style.marginBottom = "0.8rem";

              const lineCode = document.createElement("div");
              lineCode.style.fontFamily =
                '"JetBrains Mono", "Fira Code", "Source Code Pro", ui-monospace, SFMono-Regular, Menlo, Monaco, monospace';
              lineCode.style.fontFeatureSettings = '"zero", "onum"';
              lineCode.style.fontVariantNumeric = "tabular-nums";
              lineCode.style.letterSpacing = "0.01em";
              lineCode.style.fontSize = "0.85rem";
              lineCode.style.color = "#93c5fd";
              lineCode.style.marginBottom = "0.3rem";
              lineCode.style.padding = "0.3rem 0.5rem";
              lineCode.style.background = "rgba(59, 130, 246, 0.1)";
              lineCode.style.borderRadius = "0.4rem";
              lineCode.style.borderLeft = "3px solid #3b82f6";
              lineCode.textContent = item.line;

              const explanationText = document.createElement("div");
              explanationText.style.fontSize = "0.85rem";
              explanationText.style.color = "#cbd5e1";
              explanationText.style.paddingLeft = "0.5rem";
              explanationText.textContent = item.explanation;

              lineWrapper.appendChild(lineCode);
              lineWrapper.appendChild(explanationText);
              explanationDiv.appendChild(lineWrapper);
            });

            explanationToggle.addEventListener("click", () => {
              const isShown = explanationDiv.style.display === "block";
              explanationDiv.style.display = isShown ? "none" : "block";
              explanationToggle.textContent = isShown
                ? "Zeile-für-Zeile Erklärung anzeigen"
                : "Erklärung verbergen";
            });

            details.appendChild(explanationToggle);
            details.appendChild(explanationDiv);
          }
        }

        // Additional examples (e.g., for find command)
        if (quiz.additionalExamples) {
          const addEx = document.createElement("div");
          addEx.style.marginTop = "1rem";
          addEx.style.padding = "1rem";
          addEx.style.background = "rgba(59, 130, 246, 0.05)";
          addEx.style.borderRadius = "0.5rem";
          addEx.style.border = "1px solid rgba(59, 130, 246, 0.2)";
          addEx.innerHTML =
            "<strong style='color: #93c5fd; display: block; margin-bottom: 0.8rem;'>📚 Weitere praktische Beispiele:</strong>" +
            quiz.additionalExamples;
          details.appendChild(addEx);
        }

        detailsToggle.addEventListener("click", () => {
          const isShown = details.style.display === "block";
          details.style.display = isShown ? "none" : "block";
          detailsToggle.textContent = isShown
            ? "Weitere Details anzeigen"
            : "Details verbergen";
        });
        infoWrapper.appendChild(detailsToggle);
        infoWrapper.appendChild(details);
        quizBodyEl.appendChild(infoWrapper);
        quiz.questions.forEach((q, idx) => {
          const questionId = "q_" + idx;
          const wrapper = document.createElement("div");
          wrapper.className = "quiz-question";
          const title = document.createElement("div");
          title.className = "quiz-question-title";
          title.textContent = q.prompt;
          const meta = document.createElement("div");
          meta.className = "quiz-question-meta";
          meta.textContent = "Frage " + (idx + 1) + " · Level: " + q.level;
          const options = document.createElement("div");
          options.className = "quiz-options";
          q.options.forEach((opt, optIdx) => {
            const label = document.createElement("label");
            label.className = "quiz-option";
            label.dataset.optionIndex = optIdx;
            const radio = document.createElement("input");
            radio.type = "radio";
            radio.name = questionId;
            radio.value = optIdx;
            const text = document.createElement("span");
            text.textContent = opt;
            label.appendChild(radio);
            label.appendChild(text);
            options.appendChild(label);
          });
          // Chicken-Button hinzufügen
          const chickenBtn = document.createElement("button");
          chickenBtn.type = "button";
          chickenBtn.className = "quiz-chicken-btn";
          chickenBtn.textContent = "🐔 Lösung zeigen";
          chickenBtn.dataset.questionIndex = idx;
          chickenBtn.dataset.correctIndex = q.correctIndex;
          chickenBtn.addEventListener("click", function () {
            const correctIdx = parseInt(this.dataset.correctIndex);
            const allLabels = options.querySelectorAll("label");
            allLabels.forEach((label, labelIdx) => {
              if (labelIdx === correctIdx) {
                label.classList.add("highlight-correct");
                const radio = label.querySelector("input[type=radio]");
                if (radio) radio.checked = true;
              } else {
                label.classList.remove("highlight-correct");
              }
            });
            this.disabled = true;
            this.style.opacity = "0.5";
            this.style.cursor = "not-allowed";
          });
          wrapper.dataset.quizQuestionIndex = idx;
          wrapper.appendChild(title);
          wrapper.appendChild(meta);
          wrapper.appendChild(options);
          wrapper.appendChild(chickenBtn);
          quizBodyEl.appendChild(wrapper);
        });

        quizRoot.classList.remove("hidden");
        quizRoot.setAttribute("aria-hidden", "false");
      }

      quizSubmitBtn.addEventListener("click", () => {
        if (!currentQuizId) return;
        const quiz = quizData[currentQuizId];
        const questionEls = Array.from(
          quizBodyEl.querySelectorAll(".quiz-question")
        );
        let correct = 0;
        let answered = 0;

        questionEls.forEach((qEl, idx) => {
          const radios = qEl.querySelectorAll("input[type=radio]");
          let selectedIndex = null;
          radios.forEach((r, rIdx) => {
            if (r.checked) selectedIndex = rIdx;
          });
          if (selectedIndex !== null) {
            answered++;
            if (selectedIndex === quiz.questions[idx].correctIndex) correct++;
          }
        });

        if (answered < quiz.questions.length) {
          quizFeedbackEl.textContent = "Bitte alle 3 Fragen beantworten.";
          quizFeedbackEl.style.color = "#facc15";
          return;
        }
        if (correct === quiz.questions.length) {
          // Get total before saving
          const previousTotal = getTotalCorrectAnswers();

          // Save result (only if all correct and not already completed)
          const isNewCompletion = saveQuizResult(currentQuizId, correct);

          quizFeedbackEl.textContent = "Stark! Alle Fragen korrekt. 🎉";
          quizFeedbackEl.style.color = "#22c55e";
          markCardAsCompleted(currentQuizId);

          // Celebration Animation
          triggerCelebrationAnimation(quizRoot);

          // Check for new achievements only if this was a new completion
          if (isNewCompletion) {
            const newTotal = getTotalCorrectAnswers();
            const newAchievement = achievements.find(
              (a) => newTotal >= a.threshold && previousTotal < a.threshold
            );

            if (newAchievement) {
              setTimeout(() => {
                alert(
                  `🎉 Achievement freigeschaltet: ${newAchievement.icon} ${newAchievement.name}!`
                );
              }, 500);
            }

            // Update achievements display
            updateAchievements();
            updateBadgeDisplay();

            // Check if segment is complete and trigger master quiz
            badgeSegments.forEach((segment) => {
              if (segment.quizIds.includes(currentQuizId)) {
                const progress = getSegmentProgress(segment.id);
                if (
                  progress >= segment.quizIds.length &&
                  !isMasterQuizCompleted(segment.id)
                ) {
                  // Segment complete, badge should be ready
                  updateBadgeDisplay();
                }
              }
            });
          }

          // Schließe Modal nach Animation
          setTimeout(() => {
            closeQuiz();
          }, 1200);
        } else {
          quizFeedbackEl.textContent =
            "Du hast " +
            correct +
            "/" +
            quiz.questions.length +
            " richtig. Schau dir die Erklärungen noch einmal an.";
          quizFeedbackEl.style.color = "#f97316";

          // Fehler-Feedback: Roter Flash + Shake
          triggerErrorFeedback(quizRoot);
        }
      });

      function markCardAsCompleted(quizId) {
        const card = commandCards.find((c) => c.dataset.quizId === quizId);
        if (!card) return;
        card.classList.add("quiz-done", "flash-once");
        setTimeout(() => {
          card.classList.remove("flash-once");
        }, 1000);
      }

      // Celebration Animation: Partikel brechen aus dem Modal heraus
      function triggerCelebrationAnimation(modalElement) {
        if (!modalElement) return;

        const modalInner =
          modalElement.querySelector(".quiz-modal-inner") ||
          modalElement.querySelector(".master-quiz-modal-inner");
        if (!modalInner) return;

        // Füge Celebration-Klasse hinzu
        modalElement.classList.add("celebration");

        // Erstelle Partikel
        const rect = modalInner.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        const particleCount = 20;

        for (let i = 0; i < particleCount; i++) {
          const particle = document.createElement("div");
          particle.className = "celebration-particle";

          // Zufällige Richtung und Entfernung
          const angle = (Math.PI * 2 * i) / particleCount + Math.random() * 0.5;
          const distance = 100 + Math.random() * 150;
          const tx = Math.cos(angle) * distance;
          const ty = Math.sin(angle) * distance;

          particle.style.left = centerX + "px";
          particle.style.top = centerY + "px";
          particle.style.setProperty("--tx", tx + "px");
          particle.style.setProperty("--ty", ty + "px");

          // Zufällige Größe und Farbe
          const size = 6 + Math.random() * 6;
          particle.style.width = size + "px";
          particle.style.height = size + "px";

          // Zufällige Farbvariation
          const colors = [
            "radial-gradient(circle, #fbbf24, #f59e0b)",
            "radial-gradient(circle, #fcd34d, #fbbf24)",
            "radial-gradient(circle, #fde68a, #fcd34d)",
            "radial-gradient(circle, #34d399, #10b981)",
            "radial-gradient(circle, #60a5fa, #3b82f6)",
          ];
          particle.style.background =
            colors[Math.floor(Math.random() * colors.length)];

          document.body.appendChild(particle);

          // Entferne Partikel nach Animation
          setTimeout(() => {
            particle.remove();
          }, 1500);
        }
      }

      // Fehler-Feedback: Roter Flash + Shake
      function triggerErrorFeedback(modalElement) {
        if (!modalElement) return;

        const modalInner =
          modalElement.querySelector(".quiz-modal-inner") ||
          modalElement.querySelector(".master-quiz-modal-inner");
        if (!modalInner) return;

        // Füge Shake-Klasse hinzu
        modalElement.classList.add("error-feedback");
        modalInner.classList.add("error-flash");

        // Entferne Klassen nach Animation
        setTimeout(() => {
          modalElement.classList.remove("error-feedback");
          modalInner.classList.remove("error-flash");
        }, 500);
      }

      function closeQuiz() {
        quizRoot.classList.add("hidden");
        quizRoot.setAttribute("aria-hidden", "true");
        quizFeedbackEl.textContent = "";
        currentQuizId = null;
      }

      quizCloseBtn.addEventListener("click", closeQuiz);
      quizRoot.addEventListener("click", (event) => {
        if (event.target.classList.contains("quiz-backdrop")) {
          closeQuiz();
        }
      });
      document.addEventListener("keydown", (event) => {
        if (event.key === "Escape" && !quizRoot.classList.contains("hidden")) {
          closeQuiz();
        }
        if (
          event.key === "Escape" &&
          document.getElementById("master-quiz-root") &&
          !document
            .getElementById("master-quiz-root")
            .classList.contains("hidden")
        ) {
          closeMasterQuiz();
        }
        if (
          event.key === "Escape" &&
          document.getElementById("hotkeys-root") &&
          !document.getElementById("hotkeys-root").classList.contains("hidden")
        ) {
          closeHotkeysModal();
        }
        if (
          event.key === "Escape" &&
          document.getElementById("kali-tools-root") &&
          !document
            .getElementById("kali-tools-root")
            .classList.contains("hidden")
        ) {
          closeKaliToolsModal();
        }
        if (
          event.key === "Escape" &&
          document.getElementById("kali-tools-example-overlay") &&
          !document
            .getElementById("kali-tools-example-overlay")
            .classList.contains("hidden")
        ) {
          closeExampleOverlay();
        }
      });

      // Master Quiz Submit Handler
      const masterQuizSubmitBtn = document.getElementById(
        "master-quiz-submit-btn"
      );
      const masterQuizCloseBtn = document.getElementById(
        "master-quiz-close-btn"
      );
      const masterQuizFeedbackEl = document.getElementById(
        "master-quiz-feedback"
      );

      if (masterQuizSubmitBtn) {
        masterQuizSubmitBtn.addEventListener("click", () => {
          if (!currentMasterQuizSegment) return;

          const masterQuiz = masterQuizData[currentMasterQuizSegment];
          if (!masterQuiz) return;

          const selectedOption = document.querySelector(
            'input[name="master-quiz-option"]:checked'
          );
          if (!selectedOption) {
            masterQuizFeedbackEl.textContent = "Bitte eine Antwort auswählen.";
            masterQuizFeedbackEl.style.color = "#facc15";
            return;
          }

          const selectedIndex = parseInt(selectedOption.value);

          if (selectedIndex === masterQuiz.correctIndex) {
            setMasterQuizCompleted(currentMasterQuizSegment);

            // Prüfe ob dieses Segment einem Achievement entspricht
            const achievementThreshold = getAchievementThresholdFromSegment(
              currentMasterQuizSegment
            );
            if (achievementThreshold) {
              setAchievementMasterCompleted(achievementThreshold);
            }

            masterQuizFeedbackEl.innerHTML = `<div style="color: #22c55e; font-weight: 600;">🎉 Perfekt! Masterquiz bestanden!${
              achievementThreshold ? " Badge vergoldet! 🏆" : ""
            }</div><div style="margin-top: 0.5rem; font-size: 0.85rem; color: #d1d5db;">${
              masterQuiz.explanation
            }</div>`;

            // Celebration Animation
            const masterQuizRoot = document.getElementById("master-quiz-root");
            if (masterQuizRoot) {
              triggerCelebrationAnimation(masterQuizRoot);
            }

            // Update badge display
            updateBadgeDisplay();
            updateAchievements();

            setTimeout(() => {
              closeMasterQuiz();
            }, 1200);
          } else {
            masterQuizFeedbackEl.innerHTML = `<div style="color: #f97316;">Falsch. Versuche es erneut.</div><div style="margin-top: 0.5rem; font-size: 0.85rem; color: #d1d5db;">${masterQuiz.explanation}</div>`;

            // Fehler-Feedback: Roter Flash + Shake
            const masterQuizRoot = document.getElementById("master-quiz-root");
            if (masterQuizRoot) {
              triggerErrorFeedback(masterQuizRoot);
            }
          }
        });
      }

      if (masterQuizCloseBtn) {
        masterQuizCloseBtn.addEventListener("click", closeMasterQuiz);
      }

      const masterQuizRoot = document.getElementById("master-quiz-root");
      if (masterQuizRoot) {
        masterQuizRoot.addEventListener("click", (event) => {
          if (event.target.classList.contains("quiz-backdrop")) {
            closeMasterQuiz();
          }
        });
      }

      // Hotkeys Modal Event Handlers
      const hotkeysCloseBtn = document.getElementById("hotkeys-close-btn");
      if (hotkeysCloseBtn) {
        hotkeysCloseBtn.addEventListener("click", closeHotkeysModal);
      }

      const hotkeysRoot = document.getElementById("hotkeys-root");
      if (hotkeysRoot) {
        hotkeysRoot.addEventListener("click", (event) => {
          if (event.target.classList.contains("quiz-backdrop")) {
            closeHotkeysModal();
          }
        });
      }

      // Hotkeys Card Click Handler
      const hotkeysCard = document.getElementById("hotkeys-card");
      if (hotkeysCard) {
        hotkeysCard.addEventListener("click", openHotkeysModal);
      }

      // Kali Tools Modal Event Handlers
      const kaliToolsCloseBtn = document.getElementById("kali-tools-close-btn");
      if (kaliToolsCloseBtn) {
        kaliToolsCloseBtn.addEventListener("click", closeKaliToolsModal);
      }

      const kaliToolsRoot = document.getElementById("kali-tools-root");
      if (kaliToolsRoot) {
        kaliToolsRoot.addEventListener("click", (event) => {
          if (event.target.classList.contains("quiz-backdrop")) {
            closeKaliToolsModal();
          }
        });
      }

      // Kali Tools Card Click Handler
      const kaliToolsCard = document.getElementById("kali-tools-card");
      if (kaliToolsCard) {
        kaliToolsCard.addEventListener("click", openKaliToolsModal);
      }

      // Kali Tools Example Overlay Event Handlers
      const exampleOverlayCloseBtn = document.getElementById(
        "kali-tools-example-overlay-close"
      );
      if (exampleOverlayCloseBtn) {
        exampleOverlayCloseBtn.addEventListener("click", closeExampleOverlay);
      }

      const exampleOverlay = document.getElementById(
        "kali-tools-example-overlay"
      );
      if (exampleOverlay) {
        exampleOverlay.addEventListener("click", (event) => {
          if (event.target.classList.contains("quiz-backdrop")) {
            closeExampleOverlay();
          }
        });
      }
    </script>
  </body>
</html>
