<!DOCTYPE html>
<html lang="de">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Linux CLI Quiz – Cyber Security Kurs</title>
    <style>
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        background: #0f172a;
        color: #e5e7eb;
        line-height: 1.5;
      }
      header {
        padding: 1rem 1.5rem 0.75rem;
        background: #020617;
        border-bottom: 1px solid #1f2937;
        position: sticky;
        top: 0;
        z-index: 10;
      }
      .header-inner {
        max-width: 960px;
        margin: 0 auto;
      }
      h1 {
        margin: 0 0 0.2rem;
        font-size: 1.4rem;
        font-weight: 600;
      }
      .subtitle {
        font-size: 0.9rem;
        color: #9ca3af;
        margin: 0;
      }
      .search-container {
        margin-top: 1rem;
        margin-bottom: 0.5rem;
      }
      .search-input {
        width: 100%;
        padding: 0.6rem 0.9rem;
        background: #111827;
        border: 1px solid #1f2937;
        border-radius: 0.6rem;
        color: #e5e7eb;
        font-size: 0.9rem;
        font-family: inherit;
        transition: border-color 0.2s, box-shadow 0.2s;
      }
      .search-input:focus {
        outline: none;
        border-color: #3b82f6;
        box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
      }
      .search-input::placeholder {
        color: #6b7280;
      }
      .command-card.hidden {
        display: none;
      }

      /* Achievements / Badges */
      .achievements-container {
        margin-top: 1rem;
        display: flex;
        flex-wrap: wrap;
        gap: 0.6rem;
        align-items: center;
      }
      .achievement-badge {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        padding: 0.4rem 0.7rem;
        border-radius: 999px;
        font-size: 0.75rem;
        font-weight: 600;
        border: 2px solid;
        background: linear-gradient(
          135deg,
          rgba(255, 255, 255, 0.1),
          rgba(255, 255, 255, 0.05)
        );
        backdrop-filter: blur(8px);
        transition: all 0.3s ease;
        position: relative;
        overflow: hidden;
      }
      .achievement-badge::before {
        content: "";
        position: absolute;
        inset: 0;
        background: linear-gradient(
          135deg,
          rgba(255, 255, 255, 0.2),
          transparent
        );
        opacity: 0;
        transition: opacity 0.3s ease;
      }
      .achievement-badge:hover::before {
        opacity: 1;
      }
      .achievement-badge.unlocked {
        animation: badgeUnlock 0.6s ease-out;
        box-shadow: 0 0 20px rgba(255, 215, 0, 0.5),
          0 4px 12px rgba(0, 0, 0, 0.3);
      }
      .achievement-badge.locked {
        opacity: 0.4;
        filter: grayscale(0.8);
      }
      .achievement-badge.golden {
        border-color: #fbbf24;
        background: linear-gradient(
          135deg,
          rgba(251, 191, 36, 0.4),
          rgba(245, 158, 11, 0.3)
        );
        box-shadow: 0 0 30px rgba(251, 191, 36, 0.7),
          0 4px 16px rgba(245, 158, 11, 0.4),
          inset 0 1px 0 rgba(255, 255, 255, 0.2);
        animation: goldenGlow 2s ease-in-out infinite;
        position: relative;
        overflow: visible;
      }
      .achievement-badge.golden::before {
        content: "";
        position: absolute;
        inset: -2px;
        background: linear-gradient(
          135deg,
          rgba(251, 191, 36, 0.3),
          transparent 50%,
          rgba(245, 158, 11, 0.3)
        );
        border-radius: 999px;
        z-index: -1;
        animation: goldenShine 3s ease-in-out infinite;
      }
      @keyframes goldenGlow {
        0%,
        100% {
          box-shadow: 0 0 30px rgba(251, 191, 36, 0.7),
            0 4px 16px rgba(245, 158, 11, 0.4);
        }
        50% {
          box-shadow: 0 0 40px rgba(251, 191, 36, 0.9),
            0 6px 20px rgba(245, 158, 11, 0.6);
        }
      }
      @keyframes goldenShine {
        0%,
        100% {
          opacity: 0.5;
        }
        50% {
          opacity: 0.8;
        }
      }
      .achievement-icon {
        font-size: 1rem;
      }
      .achievement-badge.badge-10 {
        border-color: #a78bfa;
        color: #c4b5fd;
        background: linear-gradient(
          135deg,
          rgba(167, 139, 250, 0.2),
          rgba(124, 58, 237, 0.1)
        );
      }
      .achievement-badge.badge-20 {
        border-color: #60a5fa;
        color: #93c5fd;
        background: linear-gradient(
          135deg,
          rgba(96, 165, 250, 0.2),
          rgba(59, 130, 246, 0.1)
        );
      }
      .achievement-badge.badge-30 {
        border-color: #34d399;
        color: #6ee7b7;
        background: linear-gradient(
          135deg,
          rgba(52, 211, 153, 0.2),
          rgba(16, 185, 129, 0.1)
        );
      }
      .achievement-badge.badge-40 {
        border-color: #f59e0b;
        color: #fcd34d;
        background: linear-gradient(
          135deg,
          rgba(245, 158, 11, 0.2),
          rgba(217, 119, 6, 0.1)
        );
      }
      .achievement-badge.badge-50 {
        border-color: #ec4899;
        color: #f9a8d4;
        background: linear-gradient(
          135deg,
          rgba(236, 72, 153, 0.2),
          rgba(219, 39, 119, 0.1)
        );
      }
      .achievement-badge.badge-60 {
        border-color: #fbbf24;
        color: #fde68a;
        background: linear-gradient(
          135deg,
          rgba(251, 191, 36, 0.2),
          rgba(245, 158, 11, 0.1)
        );
        box-shadow: 0 0 25px rgba(251, 191, 36, 0.4);
      }
      @keyframes badgeUnlock {
        0% {
          transform: scale(0.8) rotate(-5deg);
          opacity: 0;
        }
        50% {
          transform: scale(1.15) rotate(5deg);
        }
        100% {
          transform: scale(1) rotate(0deg);
          opacity: 1;
        }
      }
      @keyframes slideIn {
        from {
          transform: translateX(100%);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }
      @keyframes slideOut {
        from {
          transform: translateX(0);
          opacity: 1;
        }
        to {
          transform: translateX(100%);
          opacity: 0;
        }
      }
      .achievement-progress {
        font-size: 0.7rem;
        color: #9ca3af;
        margin-top: 0.3rem;
      }

      /* Badge-Leiste für Haupt-Badges - Professionelles Layout */
      .badges-header {
        margin-top: 1.5rem;
        margin-bottom: 1.5rem;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        width: 100%;
        padding: 1.2rem 1rem;
        background: linear-gradient(
          180deg,
          rgba(15, 23, 42, 0.4),
          rgba(15, 23, 42, 0.2)
        );
        border-radius: 1rem;
        border: 1px solid rgba(31, 41, 55, 0.5);
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
      }

      /* Haupt-Badge Reihe - Professionelle Ausrichtung mit Grid */
      .main-badges-row {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 1rem;
        justify-items: center;
        align-items: stretch;
        width: 100%;
        max-width: 1100px;
        margin: 0 auto;
        padding: 0 0.5rem;
      }

      /* Sub-Badges Reihe - Direkt unter den Haupt-Badges ausgerichtet */
      .sub-badges-row {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 1rem;
        justify-items: center;
        align-items: flex-start;
        width: 100%;
        max-width: 1100px;
        margin: 1rem auto 0;
        padding: 0 0.5rem;
      }

      .badge-group {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.5rem;
        width: 100%;
        max-width: 200px;
      }

      .sub-badge-container {
        display: flex;
        flex-direction: column;
        gap: 0.3rem;
        width: 100%;
        align-items: center;
      }

      /* Haupt-Badge Stil - Professionell ausgerichtet */
      .main-badge {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: space-between;
        gap: 0.6rem;
        padding: 1rem 1.1rem;
        border-radius: 0.85rem;
        font-size: 0.85rem;
        font-weight: 600;
        border: 2px solid;
        background: linear-gradient(
          135deg,
          rgba(255, 255, 255, 0.12),
          rgba(255, 255, 255, 0.06)
        );
        backdrop-filter: blur(10px);
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        cursor: pointer;
        position: relative;
        overflow: hidden;
        width: 100%;
        max-width: 200px;
        height: 125px;
        box-sizing: border-box;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      }

      .main-badge:hover {
        transform: translateY(-4px) scale(1.02);
        box-shadow: 0 10px 28px rgba(0, 0, 0, 0.5),
          0 4px 12px rgba(0, 0, 0, 0.3);
        border-width: 2.5px;
        z-index: 1;
      }

      .main-badge.active {
        box-shadow: 0 0 32px rgba(59, 130, 246, 0.7),
          0 8px 20px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.2);
        transform: scale(1.03);
        border-width: 2.5px;
        z-index: 2;
      }

      .main-badge-header {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.5rem;
        width: 100%;
        flex-shrink: 0;
      }

      .main-badge-icon {
        font-size: 1.3rem;
        line-height: 1;
        flex-shrink: 0;
      }

      .main-badge-name {
        font-size: 0.875rem;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        text-align: center;
        line-height: 1.2;
        font-weight: 600;
      }

      /* Ladebalken für Fortschritt */
      .main-badge-progress-bar {
        width: 100%;
        height: 7px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 4px;
        overflow: hidden;
        position: relative;
        flex-shrink: 0;
        margin: 0.2rem 0;
      }

      .main-badge-progress-fill {
        height: 100%;
        background: linear-gradient(
          90deg,
          currentColor,
          rgba(255, 255, 255, 0.8)
        );
        border-radius: 4px;
        transition: width 0.5s ease;
        position: relative;
        overflow: hidden;
      }

      .main-badge-progress-fill::after {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(
          90deg,
          transparent,
          rgba(255, 255, 255, 0.3),
          transparent
        );
        animation: shimmer 2s infinite;
      }

      @keyframes shimmer {
        0% {
          transform: translateX(-100%);
        }
        100% {
          transform: translateX(100%);
        }
      }

      .main-badge-progress-text {
        font-size: 0.7rem;
        opacity: 0.9;
        white-space: nowrap;
        text-align: center;
        width: 100%;
        font-weight: 500;
        letter-spacing: 0.02em;
        flex-shrink: 0;
        line-height: 1.3;
      }

      /* Progress Container für bessere Ausrichtung */
      .main-badge-progress-container {
        width: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.35rem;
        flex: 1;
        justify-content: center;
        min-height: 0;
      }

      /* Haupt-Badge Farben */
      .main-badge.badge-voyer {
        border-color: #ec4899;
        color: #f9a8d4;
        background: linear-gradient(
          135deg,
          rgba(236, 72, 153, 0.2),
          rgba(219, 39, 119, 0.1)
        );
      }

      .main-badge.badge-operator {
        border-color: #60a5fa;
        color: #93c5fd;
        background: linear-gradient(
          135deg,
          rgba(96, 165, 250, 0.2),
          rgba(59, 130, 246, 0.1)
        );
      }

      .main-badge.badge-connoisseur {
        border-color: #34d399;
        color: #6ee7b7;
        background: linear-gradient(
          135deg,
          rgba(52, 211, 153, 0.2),
          rgba(16, 185, 129, 0.1)
        );
      }

      .main-badge.badge-navigator {
        border-color: #a78bfa;
        color: #c4b5fd;
        background: linear-gradient(
          135deg,
          rgba(167, 139, 250, 0.2),
          rgba(124, 58, 237, 0.1)
        );
      }

      .main-badge.badge-morelinux {
        border-color: #fbbf24;
        color: #fde68a;
        background: linear-gradient(
          135deg,
          rgba(251, 191, 36, 0.2),
          rgba(245, 158, 11, 0.1)
        );
      }

      /* Unter-Badge Stil (nur visuell, nicht anklickbar) */
      .sub-badge {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.4rem;
        padding: 0.4rem 0.7rem;
        border-radius: 999px;
        font-size: 0.75rem;
        font-weight: 500;
        border: 1px solid;
        background: rgba(255, 255, 255, 0.05);
        opacity: 0.7;
        pointer-events: none;
        cursor: default;
        width: 100%;
      }

      /* Sub-Badge Farben für Segmente */
      .sub-badge.segment-1 {
        border-color: rgba(167, 139, 250, 0.5);
        color: #c4b5fd;
        background: rgba(167, 139, 250, 0.1);
      }
      .sub-badge.segment-2 {
        border-color: rgba(96, 165, 250, 0.5);
        color: #93c5fd;
        background: rgba(96, 165, 250, 0.1);
      }
      .sub-badge.segment-3 {
        border-color: rgba(52, 211, 153, 0.5);
        color: #6ee7b7;
        background: rgba(52, 211, 153, 0.1);
      }
      .sub-badge.segment-4 {
        border-color: rgba(245, 158, 11, 0.5);
        color: #fcd34d;
        background: rgba(245, 158, 11, 0.1);
      }
      .sub-badge.segment-5 {
        border-color: rgba(236, 72, 153, 0.5);
        color: #f9a8d4;
        background: rgba(236, 72, 153, 0.1);
      }

      /* Legacy Badge-Segmente (für Kompatibilität) */
      .badge-segment {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        padding: 0.5rem 0.8rem;
        border-radius: 999px;
        font-size: 0.8rem;
        font-weight: 600;
        border: 2px solid;
        background: linear-gradient(
          135deg,
          rgba(255, 255, 255, 0.1),
          rgba(255, 255, 255, 0.05)
        );
        backdrop-filter: blur(8px);
        transition: all 0.3s ease;
        cursor: pointer;
        position: relative;
        overflow: hidden;
      }
      .badge-segment {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        padding: 0.5rem 0.8rem;
        border-radius: 999px;
        font-size: 0.8rem;
        font-weight: 600;
        border: 2px solid;
        background: linear-gradient(
          135deg,
          rgba(255, 255, 255, 0.1),
          rgba(255, 255, 255, 0.05)
        );
        backdrop-filter: blur(8px);
        transition: all 0.3s ease;
        cursor: pointer;
        position: relative;
        overflow: hidden;
      }
      .badge-segment.locked {
        opacity: 0.4;
        filter: grayscale(0.8);
        cursor: not-allowed;
      }
      .badge-segment.ready {
        /* Pulsierende Animation entfernt */
        cursor: pointer;
        opacity: 0.7;
        filter: saturate(0.7);
        transition: all 0.3s ease;
      }

      .badge-segment.ready:hover {
        opacity: 1;
        filter: saturate(1);
        transform: translateY(-2px);
      }
      /* Sättigungsstufen für Fortschritt */
      .badge-segment.progress-0 {
        filter: grayscale(1) saturate(0);
        opacity: 0.4;
      }
      .badge-segment.progress-25 {
        filter: grayscale(0.75) saturate(0.25);
        opacity: 0.6;
      }
      .badge-segment.progress-50 {
        filter: grayscale(0.5) saturate(0.5);
        opacity: 0.8;
      }
      .badge-segment.progress-75 {
        filter: grayscale(0.25) saturate(0.75);
        opacity: 0.9;
      }
      .badge-segment.progress-100 {
        filter: grayscale(0) saturate(1);
        opacity: 1;
      }

      .badge-segment.unlocked {
        opacity: 1;
        filter: none;
        cursor: default;
      }
      .badge-segment.active {
        box-shadow: 0 0 25px rgba(59, 130, 246, 0.6),
          0 4px 12px rgba(0, 0, 0, 0.3);
        transform: scale(1.05);
        border-width: 3px;
      }
      .badge-segment.segment-1 {
        border-color: #a78bfa;
        color: #c4b5fd;
        background: linear-gradient(
          135deg,
          rgba(167, 139, 250, 0.2),
          rgba(124, 58, 237, 0.1)
        );
      }
      .badge-segment.segment-2 {
        border-color: #60a5fa;
        color: #93c5fd;
        background: linear-gradient(
          135deg,
          rgba(96, 165, 250, 0.2),
          rgba(59, 130, 246, 0.1)
        );
      }
      .badge-segment.segment-3 {
        border-color: #34d399;
        color: #6ee7b7;
        background: linear-gradient(
          135deg,
          rgba(52, 211, 153, 0.2),
          rgba(16, 185, 129, 0.1)
        );
      }
      .badge-segment.segment-4 {
        border-color: #f59e0b;
        color: #fcd34d;
        background: linear-gradient(
          135deg,
          rgba(245, 158, 11, 0.2),
          rgba(217, 119, 6, 0.1)
        );
      }
      .badge-segment.segment-5 {
        border-color: #ec4899;
        color: #f9a8d4;
        background: linear-gradient(
          135deg,
          rgba(236, 72, 153, 0.2),
          rgba(219, 39, 119, 0.1)
        );
      }
      .badge-segment.segment-6 {
        border-color: #fbbf24;
        color: #fde68a;
        background: linear-gradient(
          135deg,
          rgba(251, 191, 36, 0.2),
          rgba(245, 158, 11, 0.1)
        );
      }
      .badge-segment.ready {
        box-shadow: 0 0 20px rgba(59, 130, 246, 0.5),
          0 4px 12px rgba(0, 0, 0, 0.3);
      }
      .badge-segment.unlocked {
        box-shadow: 0 0 25px rgba(34, 197, 94, 0.4),
          0 4px 12px rgba(0, 0, 0, 0.3);
      }
      @keyframes badgePulse {
        0%,
        100% {
          transform: scale(1);
          box-shadow: 0 0 20px rgba(59, 130, 246, 0.5),
            0 4px 12px rgba(0, 0, 0, 0.3);
        }
        50% {
          transform: scale(1.05);
          box-shadow: 0 0 30px rgba(59, 130, 246, 0.8),
            0 6px 16px rgba(0, 0, 0, 0.4);
        }
      }
      .badge-segment-icon {
        font-size: 1.1rem;
      }
      .badge-segment-progress {
        font-size: 0.7rem;
        opacity: 0.8;
      }

      /* Mini-Badges auf Karten */
      .badge-mini {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        font-size: 0.7rem;
        border: 2px solid;
        background: rgba(255, 255, 255, 0.1);
        flex-shrink: 0;
      }
      .badge-mini.segment-1 {
        border-color: #a78bfa;
        color: #c4b5fd;
      }
      .badge-mini.segment-2 {
        border-color: #60a5fa;
        color: #93c5fd;
      }
      .badge-mini.segment-3 {
        border-color: #34d399;
        color: #6ee7b7;
      }
      .badge-mini.segment-4 {
        border-color: #f59e0b;
        color: #fcd34d;
      }
      .badge-mini.segment-5 {
        border-color: #ec4899;
        color: #f9a8d4;
      }
      .badge-mini.segment-6 {
        border-color: #fbbf24;
        color: #fde68a;
      }

      /* Hotkeys-Kachel */
      .hotkeys-card {
        border: 2px solid #fbbf24;
        background: radial-gradient(
            circle at top left,
            rgba(251, 191, 36, 0.2),
            transparent 55%
          ),
          radial-gradient(
            circle at bottom right,
            rgba(245, 158, 11, 0.15),
            transparent 55%
          ),
          #020617;
        box-shadow: 0 0 20px rgba(251, 191, 36, 0.3);
      }
      .hotkeys-card:hover {
        border-color: #fcd34d;
        box-shadow: 0 0 30px rgba(251, 191, 36, 0.5);
        transform: translateY(-2px);
      }

      /* Kali-Tools-Kachel */
      .kali-tools-card {
        border: 2px solid #ef4444;
        background: radial-gradient(
            circle at top left,
            rgba(239, 68, 68, 0.2),
            transparent 55%
          ),
          radial-gradient(
            circle at bottom right,
            rgba(220, 38, 38, 0.15),
            transparent 55%
          ),
          #020617;
        box-shadow: 0 0 20px rgba(239, 68, 68, 0.3);
      }
      .kali-tools-card:hover {
        border-color: #f87171;
        box-shadow: 0 0 30px rgba(239, 68, 68, 0.5);
        transform: translateY(-2px);
      }

      /* Beginner-Mistakes-Kachel */
      .mistakes-card {
        border: 2px solid #38bdf8;
        background: radial-gradient(
            circle at top left,
            rgba(56, 189, 248, 0.18),
            transparent 55%
          ),
          radial-gradient(
            circle at bottom right,
            rgba(14, 165, 233, 0.14),
            transparent 55%
          ),
          #020617;
        box-shadow: 0 0 20px rgba(56, 189, 248, 0.35);
      }
      .mistakes-card:hover {
        border-color: #7dd3fc;
        box-shadow: 0 0 28px rgba(56, 189, 248, 0.5);
        transform: translateY(-2px);
      }

      /* Masterquiz-Modal */
      .master-quiz-modal {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 60;
      }
      .master-quiz-modal.hidden {
        display: none;
      }
      .master-quiz-modal-inner {
        position: relative;
        z-index: 61;
        width: min(600px, 100% - 2rem);
        background: #020617;
        border-radius: 1rem;
        border: 1px solid #1f2937;
        box-shadow: 0 22px 60px rgba(0, 0, 0, 0.7);
        padding: 1.2rem 1.5rem 1.3rem;
        max-height: 85vh;
        overflow-y: auto;
      }
      .master-quiz-scenario {
        padding: 0.8rem;
        border-radius: 0.7rem;
        border: 1px solid #374151;
        background: rgba(59, 130, 246, 0.1);
        margin-bottom: 1rem;
        font-size: 0.9rem;
        line-height: 1.6;
      }

      /* Celebration Animation für erfolgreiche Quiz-Abschlüsse */
      .quiz-modal.celebration,
      .master-quiz-modal.celebration {
        animation: celebrationBreakout 1.2s ease-out forwards;
      }

      @keyframes celebrationBreakout {
        0% {
          transform: scale(1);
          opacity: 1;
        }
        30% {
          transform: scale(1.05);
        }
        100% {
          transform: scale(0.8);
          opacity: 0;
        }
      }

      .celebration-particle {
        position: fixed;
        width: 8px;
        height: 8px;
        background: radial-gradient(circle, #fbbf24, #f59e0b);
        border-radius: 50%;
        pointer-events: none;
        z-index: 1000;
        animation: particleFloat 1.5s ease-out forwards;
      }

      @keyframes particleFloat {
        0% {
          opacity: 1;
          transform: translate(0, 0) scale(1);
        }
        100% {
          opacity: 0;
          transform: translate(var(--tx), var(--ty)) scale(0);
        }
      }

      /* Fehler-Feedback: Roter Flash + Shake */
      .quiz-modal.error-feedback,
      .master-quiz-modal.error-feedback {
        animation: errorShake 0.5s ease-in-out;
      }

      @keyframes errorShake {
        0%,
        100% {
          transform: translateX(0);
        }
        10%,
        30%,
        50%,
        70%,
        90% {
          transform: translateX(-5px);
        }
        20%,
        40%,
        60%,
        80% {
          transform: translateX(5px);
        }
      }

      .quiz-modal-inner.error-flash,
      .master-quiz-modal-inner.error-flash {
        animation: errorFlash 0.4s ease-out;
      }

      /* Command Detail Modal (aligned with Masterquiz look) */
      .command-modal {
        backdrop-filter: blur(2px);
      }
      .command-modal .master-quiz-modal-inner {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }
      .command-modal .command-meta-grid {
        display: grid;
        gap: 0.9rem;
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      }
      .command-modal .command-section {
        border: 1px solid #1f2937;
        background: rgba(255, 255, 255, 0.02);
        border-radius: 0.75rem;
        padding: 0.9rem 1rem;
      }
      .command-modal .command-section h3 {
        margin: 0 0 0.4rem;
        font-size: 1rem;
        color: #c7d2fe;
      }
      .command-modal .flag-pill {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        padding: 0.35rem 0.6rem;
        border-radius: 999px;
        background: rgba(59, 130, 246, 0.12);
        border: 1px solid rgba(59, 130, 246, 0.35);
        color: #bfdbfe;
        font-weight: 600;
        margin: 0.15rem 0.25rem 0.15rem 0;
        font-size: 0.85rem;
      }
      .command-modal .flag-pill small {
        display: block;
        color: #cbd5e1;
        font-weight: 400;
      }
      .command-modal .pitfalls-list {
        margin: 0;
        padding-left: 1.2rem;
        color: #e5e7eb;
      }
      .command-modal .example-list {
        display: grid;
        gap: 0.6rem;
      }
      .command-modal .example-item {
        padding: 0.75rem;
        border-radius: 0.6rem;
        background: rgba(16, 185, 129, 0.06);
        border: 1px solid rgba(16, 185, 129, 0.35);
      }
      .command-modal .example-item code {
        display: block;
        font-family: "JetBrains Mono", "Fira Code", "Source Code Pro",
          ui-monospace, SFMono-Regular, Menlo, Monaco, monospace;
        color: #6ee7b7;
        font-size: 0.9rem;
      }
      .command-modal .command-summary {
        margin: 0;
        color: #e5e7eb;
      }

      @keyframes errorFlash {
        0% {
          box-shadow: 0 22px 60px rgba(0, 0, 0, 0.7);
        }
        50% {
          box-shadow: 0 22px 60px rgba(239, 68, 68, 0.6),
            0 0 40px rgba(239, 68, 68, 0.4);
          border-color: #ef4444;
        }
        100% {
          box-shadow: 0 22px 60px rgba(0, 0, 0, 0.7);
        }
      }

      /* Hotkeys-Modal */
      .hotkeys-modal {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 60;
      }
      .hotkeys-modal.hidden {
        display: none;
      }
      .hotkeys-modal-inner {
        position: relative;
        z-index: 61;
        width: min(700px, 100% - 2rem);
        background: #020617;
        border-radius: 1rem;
        border: 1px solid #1f2937;
        box-shadow: 0 22px 60px rgba(0, 0, 0, 0.7);
        padding: 1.2rem 1.5rem 1.3rem;
        max-height: 85vh;
        overflow-y: auto;
      }
      .hotkeys-section {
        margin-bottom: 1.5rem;
      }
      .hotkeys-section-title {
        font-size: 1.1rem;
        font-weight: 600;
        color: #fbbf24;
        margin-bottom: 0.5rem;
        padding-bottom: 0.3rem;
        border-bottom: 2px solid rgba(251, 191, 36, 0.3);
      }
      .hotkeys-item {
        padding: 0.4rem 0.6rem;
        margin-bottom: 0.3rem;
        border-radius: 0.5rem;
        background: rgba(255, 255, 255, 0.03);
        border-left: 3px solid #fbbf24;
      }
      .hotkeys-shortcut {
        font-family: "JetBrains Mono", ui-monospace, monospace;
        color: #93c5fd;
        font-weight: 600;
      }
      .hotkeys-description {
        color: #d1d5db;
        margin-left: 0.5rem;
      }

      /* Beginner-Mistakes Modal */
      .mistakes-list {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }
      .mistake-row {
        width: 100%;
        text-align: left;
        background: rgba(59, 130, 246, 0.06);
        border: 1px solid rgba(59, 130, 246, 0.3);
        border-radius: 0.7rem;
        padding: 0.75rem 0.85rem;
        color: #e5e7eb;
        cursor: pointer;
        transition: border-color 0.15s ease, transform 0.1s ease;
      }
      .mistake-row:hover {
        border-color: #93c5fd;
        transform: translateY(-1px);
      }
      .mistake-row-header {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        margin-bottom: 0.35rem;
        font-weight: 600;
      }
      .mistake-index {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 28px;
        height: 28px;
        border-radius: 0.5rem;
        background: rgba(59, 130, 246, 0.2);
        color: #bfdbfe;
        font-weight: 700;
      }
      .mistake-title {
        flex: 1;
        font-size: 0.95rem;
      }
      .mistake-description {
        font-size: 0.9rem;
        color: #cbd5e1;
        margin: 0;
      }
      .mistake-example {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        margin-top: 0.35rem;
        padding: 0.4rem 0.55rem;
        border-radius: 0.5rem;
        background: rgba(34, 197, 94, 0.08);
        border: 1px solid rgba(34, 197, 94, 0.3);
        color: #bbf7d0;
        font-size: 0.85rem;
      }
      .mistake-example code {
        background: rgba(15, 23, 42, 0.6);
        padding: 0.2rem 0.45rem;
        border-radius: 0.45rem;
        border: 1px solid rgba(34, 197, 94, 0.4);
        color: #22c55e;
      }
      .mistake-meta {
        display: flex;
        flex-wrap: wrap;
        gap: 0.35rem;
        align-items: center;
        margin-top: 0.35rem;
        font-size: 0.8rem;
        color: #9ca3af;
      }

      /* Kali-Tools-Modal */
      .kali-tools-modal {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 60;
      }
      .kali-tools-modal.hidden {
        display: none;
      }
      .kali-tools-modal-inner {
        position: relative;
        z-index: 61;
        width: min(700px, 100% - 2rem);
        background: #020617;
        border-radius: 1rem;
        border: 1px solid #1f2937;
        box-shadow: 0 22px 60px rgba(0, 0, 0, 0.7);
        padding: 1.2rem 1.5rem 1.3rem;
        max-height: 85vh;
        overflow-y: auto;
      }
      .kali-tools-section {
        margin-bottom: 1.5rem;
      }
      .kali-tools-section-title {
        font-size: 1.1rem;
        font-weight: 600;
        color: #ef4444;
        margin-bottom: 0.5rem;
        padding-bottom: 0.3rem;
        border-bottom: 2px solid rgba(239, 68, 68, 0.3);
      }
      .kali-tools-item {
        padding: 0.6rem 0.8rem;
        margin-bottom: 0.5rem;
        border-radius: 0.5rem;
        background: rgba(255, 255, 255, 0.03);
        border-left: 3px solid #ef4444;
      }
      .kali-tools-name {
        font-family: "JetBrains Mono", ui-monospace, monospace;
        color: #93c5fd;
        font-weight: 600;
        display: block;
        margin-bottom: 0.3rem;
      }
      .kali-tools-description {
        color: #d1d5db;
        font-size: 0.95rem;
        line-height: 1.5;
        margin-bottom: 0.3rem;
      }
      .kali-tools-benefit {
        color: #a78bfa;
        font-size: 0.9rem;
        font-style: italic;
        margin-top: 0.3rem;
      }
      .kali-tools-command {
        font-family: "JetBrains Mono", ui-monospace, monospace;
        color: #34d399;
        font-size: 0.85rem;
        background: rgba(52, 211, 153, 0.1);
        padding: 0.2rem 0.4rem;
        border-radius: 0.3rem;
        display: inline-block;
        margin-top: 0.3rem;
      }
      .kali-tools-example {
        margin-top: 0.5rem;
        padding: 0.6rem;
        border-radius: 0.5rem;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(239, 68, 68, 0.2);
        position: relative;
      }
      .kali-tools-example-title {
        font-size: 0.85rem;
        font-weight: 600;
        color: #ef4444;
        margin-bottom: 0.4rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }
      .kali-tools-example-content {
        color: #d1d5db;
        font-size: 0.9rem;
        line-height: 1.6;
      }
      .kali-tools-example-blurred {
        filter: blur(5px);
        user-select: none;
        pointer-events: none;
        position: relative;
        overflow: hidden;
      }
      .kali-tools-example-blurred::after {
        content: "";
        position: absolute;
        inset: 0;
        background: rgba(15, 23, 42, 0.7);
        backdrop-filter: blur(2px);
      }
      .kali-tools-chicken-btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 0.3rem 0.6rem;
        margin-left: 0.5rem;
        background: rgba(239, 68, 68, 0.2);
        border: 1px solid rgba(239, 68, 68, 0.4);
        border-radius: 0.4rem;
        color: #fca5a5;
        font-size: 1.1rem;
        cursor: pointer;
        transition: all 0.2s ease;
        font-family: inherit;
      }
      .kali-tools-chicken-btn:hover {
        background: rgba(239, 68, 68, 0.3);
        border-color: rgba(239, 68, 68, 0.6);
        transform: scale(1.05);
      }
      .kali-tools-chicken-btn:active {
        transform: scale(0.95);
      }
      .kali-tools-overlay {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 70;
      }
      .kali-tools-overlay.hidden {
        display: none;
      }
      .kali-tools-overlay-inner {
        position: relative;
        z-index: 71;
        width: min(600px, 100% - 2rem);
        max-height: 80vh;
        background: #020617;
        border-radius: 1rem;
        border: 1px solid #1f2937;
        box-shadow: 0 22px 60px rgba(0, 0, 0, 0.7);
        padding: 1.5rem;
        overflow-y: auto;
      }
      .kali-tools-overlay-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1rem;
        padding-bottom: 0.8rem;
        border-bottom: 2px solid rgba(239, 68, 68, 0.3);
      }
      .kali-tools-overlay-title {
        font-size: 1.2rem;
        font-weight: 600;
        color: #ef4444;
      }
      .kali-tools-overlay-close {
        background: transparent;
        border: 1px solid rgba(239, 68, 68, 0.3);
        color: #fca5a5;
        padding: 0.3rem 0.6rem;
        border-radius: 0.4rem;
        cursor: pointer;
        font-size: 0.9rem;
        transition: all 0.2s ease;
      }
      .kali-tools-overlay-close:hover {
        background: rgba(239, 68, 68, 0.2);
        border-color: rgba(239, 68, 68, 0.5);
      }
      .kali-tools-overlay-content {
        color: #d1d5db;
        font-size: 0.95rem;
        line-height: 1.7;
      }
      .kali-tools-overlay-content .kali-tools-name {
        margin-bottom: 0.5rem;
      }
      .kali-tools-overlay-content .kali-tools-command {
        margin-top: 0.5rem;
        display: block;
      }

      /* Kali-Tools Badge Container */
      .kali-tools-badges-container {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        margin-top: 0.8rem;
        padding-top: 0.8rem;
        border-top: 1px solid rgba(239, 68, 68, 0.2);
      }
      .kali-tools-badge {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        padding: 0.4rem 0.7rem;
        border-radius: 0.5rem;
        font-size: 0.85rem;
        border: 1px solid;
        transition: all 0.2s ease;
        cursor: pointer;
      }
      .kali-tools-badge.locked {
        background: rgba(239, 68, 68, 0.1);
        border-color: rgba(239, 68, 68, 0.3);
        color: #fca5a5;
        opacity: 0.6;
      }
      .kali-tools-badge.unlocked {
        background: rgba(34, 197, 94, 0.15);
        border-color: rgba(34, 197, 94, 0.4);
        color: #86efac;
        opacity: 1;
      }
      .kali-tools-badge:hover {
        transform: scale(1.05);
        opacity: 1;
      }
      .kali-tools-badge-icon {
        font-size: 1rem;
      }
      .kali-tools-badge-name {
        font-weight: 500;
      }
      .kali-tools-badge-progress {
        font-size: 0.75rem;
        opacity: 0.8;
        margin-left: 0.2rem;
      }

      /* Desktop Layout - 16:9 Optimiert */
      main {
        max-width: 100%;
        margin: 0 auto;
        padding: 1rem 2rem 2rem;
        width: 100%;
      }

      .commands-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
        gap: 0.8rem;
        width: 100%;
      }

      /* Header für Desktop optimiert */
      header {
        padding: 1rem 2rem 0.75rem;
      }

      .header-inner {
        max-width: 100%;
      }
      .command-card {
        border-radius: 0.9rem;
        border: 1px solid #1f2937;
        background: radial-gradient(
            circle at top left,
            rgba(56, 189, 248, 0.12),
            transparent 55%
          ),
          radial-gradient(
            circle at bottom right,
            rgba(129, 140, 248, 0.12),
            transparent 55%
          ),
          #020617;
        padding: 0.9rem 1rem;
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        cursor: pointer;
        transition: transform 0.08s ease-out, box-shadow 0.08s ease-out,
          border-color 0.08s ease-out;
      }
      .command-card:hover {
        transform: translateY(-1px);
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.6);
        border-color: #3b82f6;
      }
      .command-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 0.5rem;
        margin-bottom: 0.15rem;
      }
      .command-name {
        margin: 0;
        font-size: 0.95rem;
        font-weight: 600;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .command-name code {
        background: #020617;
        padding: 0.1rem 0.35rem;
        border-radius: 999px;
        border: 1px solid #1f2937;
        font-size: 0.85rem;
      }
      .command-tag {
        font-size: 0.7rem;
        color: #9ca3af;
      }
      .command-body {
        font-size: 0.85rem;
        color: #d1d5db;
      }
      .command-body p {
        margin: 0.1rem 0;
      }
      code {
        font-family: "JetBrains Mono", "Fira Code", "Source Code Pro",
          "Cascadia Code", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
        font-size: 0.85em;
        font-feature-settings: "zero", "onum";
        font-variant-numeric: tabular-nums;
        letter-spacing: 0.01em;
      }

      /* Quiz modal */
      .quiz-backdrop {
        position: fixed;
        inset: 0;
        background: rgba(15, 23, 42, 0.7);
        backdrop-filter: blur(6px);
        z-index: 40;
      }
      .quiz-modal {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 50;
      }
      .quiz-modal.hidden {
        display: none;
      }
      .quiz-modal-inner {
        position: relative;
        z-index: 51;
        width: min(520px, 100% - 2rem);
        background: #020617;
        border-radius: 1rem;
        border: 1px solid #1f2937;
        box-shadow: 0 22px 60px rgba(0, 0, 0, 0.7);
        padding: 1rem 1.2rem 1.1rem;
        transform: translateZ(0);
        isolation: isolate;
      }
      .quiz-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 0.5rem;
        margin-bottom: 0.5rem;
      }
      .quiz-title {
        font-size: 1rem;
        font-weight: 600;
      }
      .quiz-level-pill {
        font-size: 0.7rem;
        padding: 0.12rem 0.6rem;
        border-radius: 999px;
        border: 1px solid #374151;
        color: #9ca3af;
      }
      .quiz-close-btn {
        border: none;
        background: #111827;
        border-radius: 999px;
        padding: 0.2rem 0.6rem;
        font-size: 0.8rem;
        color: #9ca3af;
        cursor: pointer;
      }
      .quiz-body {
        font-size: 0.85rem;
        color: #d1d5db;
        display: flex;
        flex-direction: column;
        gap: 0.7rem;
        margin-bottom: 0.7rem;
        max-height: 60vh;
        overflow-y: auto;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
      }

      /* Verbesserte Schriftart für Erklärungen mit besserer Unterscheidung */
      .quiz-body code,
      .quiz-body .cmd-example,
      .quiz-command-info code,
      .complex-explanation code,
      .quiz-question-title code {
        font-family: "JetBrains Mono", "Fira Code", "Source Code Pro",
          "Cascadia Code", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace !important;
        font-feature-settings: "zero", "onum", "calt" !important;
        font-variant-numeric: tabular-nums !important;
        letter-spacing: 0.02em !important;
        font-weight: 500 !important;
      }
      .quiz-question {
        padding: 0.6rem 0.7rem;
        border-radius: 0.7rem;
        border: 1px solid #1f2937;
        background: #020617;
      }
      .quiz-question-title {
        font-weight: 600;
        margin-bottom: 0.3rem;
      }
      .quiz-question-meta {
        font-size: 0.75rem;
        color: #9ca3af;
        margin-bottom: 0.35rem;
      }
      .quiz-options {
        display: flex;
        flex-direction: column;
        gap: 0.2rem;
      }
      .quiz-option {
        display: flex;
        gap: 0.4rem;
        align-items: flex-start;
        cursor: pointer;
      }
      .quiz-option input {
        margin-top: 0.12rem;
      }
      .quiz-option.highlight-correct {
        background: rgba(34, 197, 94, 0.15);
        border-left: 3px solid #22c55e;
        padding-left: 0.5rem;
        border-radius: 0.25rem;
      }
      .quiz-chicken-btn {
        margin-top: 0.5rem;
        padding: 0.35rem 0.75rem;
        font-size: 0.75rem;
        background: rgba(245, 158, 11, 0.15);
        border: 1px solid rgba(245, 158, 11, 0.3);
        border-radius: 0.4rem;
        color: #fbbf24;
        cursor: pointer;
        transition: all 0.2s ease;
        font-weight: 500;
      }
      .quiz-chicken-btn:hover {
        background: rgba(245, 158, 11, 0.25);
        border-color: rgba(245, 158, 11, 0.5);
        transform: translateY(-1px);
      }
      .quiz-chicken-btn:active {
        transform: translateY(0);
      }
      .quiz-footer {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.8rem;
      }
      .quiz-submit-btn {
        border: none;
        border-radius: 999px;
        padding: 0.45rem 0.9rem;
        background: linear-gradient(135deg, #22c55e, #4ade80);
        color: #022c22;
        font-weight: 600;
        cursor: pointer;
      }
      .quiz-submit-btn:disabled {
        opacity: 0.5;
        cursor: default;
      }
      .quiz-feedback {
        font-size: 0.8rem;
      }
      .command-card.quiz-done {
        border-color: #22c55e;
        box-shadow: 0 0 0 1px rgba(34, 197, 94, 0.6),
          0 14px 30px rgba(22, 163, 74, 0.35);
        position: relative;
      }
      .command-card.quiz-done::after {
        content: "✓ Quiz bestanden";
        position: absolute;
        top: 0.5rem;
        right: 0.7rem;
        font-size: 0.65rem;
        padding: 0.12rem 0.45rem;
        border-radius: 999px;
        background: rgba(22, 163, 74, 0.12);
        border: 1px solid rgba(22, 163, 74, 0.7);
        color: #bbf7d0;
      }
      .command-card.quiz-done.flash-once {
        animation: cardPulse 0.9s ease-out;
      }
      @keyframes cardPulse {
        0% {
          box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.8);
        }
        100% {
          box-shadow: 0 0 0 16px rgba(34, 197, 94, 0);
        }
      }
      /* Category color accents (subtle contour lines) */
      .command-card {
        position: relative;
      }
      .command-card::before {
        content: "";
        position: absolute;
        left: 0;
        top: 0;
        bottom: 0;
        width: 6px;
        border-radius: 0.9rem 0 0 0.9rem;
        pointer-events: none;
        opacity: 0;
        transition: opacity 180ms ease;
      }
      .command-card.category-navigation::before {
        background: linear-gradient(#60a5fa, #3b82f6);
        opacity: 0.95;
      }
      .command-card.category-listing::before {
        background: linear-gradient(#f59e0b, #f97316);
        opacity: 0.95;
      }
      .command-card.category-search::before {
        background: linear-gradient(#a78bfa, #7c3aed);
        opacity: 0.95;
      }
      .command-card.category-pipes::before {
        background: linear-gradient(#34d399, #10b981);
        opacity: 0.95;
      }
      .command-card.category-redirect::before {
        background: linear-gradient(#fb7185, #ef4444);
        opacity: 0.95;
      }
      .command-card.category-workflow::before {
        background: linear-gradient(#60a5fa, #f59e0b);
        opacity: 0.95;
      }
      .command-card.category-files::before {
        background: linear-gradient(#ec4899, #db2777);
        opacity: 0.95;
      }
      .command-card.category-system::before {
        background: linear-gradient(#8b5cf6, #7c3aed);
        opacity: 0.95;
      }
      .command-card.category-permissions::before {
        background: linear-gradient(#f59e0b, #d97706);
        opacity: 0.95;
      }

      /* Slightly lift the border color to match accent (keeps original look but clearer grouping) */
      .command-card.category-navigation {
        border-color: rgba(96, 165, 250, 0.22);
      }
      .command-card.category-listing {
        border-color: rgba(245, 158, 11, 0.18);
      }
      .command-card.category-search {
        border-color: rgba(167, 139, 250, 0.18);
      }
      .command-card.category-pipes {
        border-color: rgba(52, 211, 153, 0.18);
      }
      .command-card.category-redirect {
        border-color: rgba(251, 113, 133, 0.18);
      }
      .command-card.category-workflow {
        border-color: rgba(96, 165, 250, 0.12);
      }
      .command-card.category-files {
        border-color: rgba(236, 72, 153, 0.18);
      }
      .command-card.category-system {
        border-color: rgba(139, 92, 246, 0.18);
      }
      .command-card.category-permissions {
        border-color: rgba(245, 158, 11, 0.18);
      }

      /* Modal: command info and collapsible details */
      .quiz-command-info {
        margin-bottom: 0.6rem;
        padding: 0.6rem;
        border-radius: 0.6rem;
        border: 1px solid #111827;
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.01),
          rgba(255, 255, 255, 0)
        );
        font-size: 0.9rem;
        color: #d1d5db;
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
      }
      .quiz-command-info .cmd-title code {
        font-size: 0.95rem;
        padding: 0.08rem 0.35rem;
        border-radius: 999px;
        border: 1px solid #1f2937;
        background: #020617;
      }
      .quiz-command-info .cmd-example {
        color: #c7d2fe;
        font-family: "JetBrains Mono", "Fira Code", "Source Code Pro",
          ui-monospace, SFMono-Regular, Menlo, Monaco, monospace;
        font-feature-settings: "zero", "onum";
        font-variant-numeric: tabular-nums;
        letter-spacing: 0.01em;
      }
      .quiz-details-toggle {
        background: transparent;
        border: none;
        color: #93c5fd;
        cursor: pointer;
        padding: 0;
        font-size: 0.85rem;
        align-self: flex-start;
      }
      .quiz-details {
        margin-top: 0.4rem;
        padding: 0.5rem;
        border-radius: 0.6rem;
        background: rgba(255, 255, 255, 0.015);
        border: 1px solid #0b1220;
        font-size: 0.85rem;
        color: #cbd5e1;
        display: none;
        white-space: pre-wrap;
      }
      .complex-explanation {
        margin-top: 0.5rem;
        padding: 0.8rem;
        border-radius: 0.6rem;
        background: rgba(59, 130, 246, 0.05);
        border: 1px solid rgba(59, 130, 246, 0.2);
      }
      .complex-explanation > div {
        margin-bottom: 0.8rem;
      }
      .complex-explanation > div:last-child {
        margin-bottom: 0;
      }

      /* Mobile Media Queries */
      @media (max-width: 768px) {
        /* Mobile Layout */
        main {
          padding: 1rem 1rem 2rem;
        }

        header {
          padding: 1rem 1rem 0.75rem;
        }

        .header-inner {
          max-width: 100%;
        }

        /* Badges auf Mobile - Grid anpassen */
        .badges-header {
          padding: 1rem 0.75rem;
          margin-top: 1rem;
          margin-bottom: 1rem;
        }

        .main-badges-row {
          grid-template-columns: repeat(2, 1fr);
          gap: 0.75rem;
          padding: 0;
        }

        .sub-badges-row {
          grid-template-columns: repeat(2, 1fr);
          gap: 0.75rem;
          padding: 0;
          margin-top: 0.75rem;
        }

        .main-badge {
          max-width: 100%;
          padding: 0.85rem 0.9rem;
          height: auto;
          min-height: 110px;
        }

        .badge-group {
          max-width: 100%;
        }

        .main-badge-icon {
          font-size: 1rem;
        }

        .main-badge-name {
          font-size: 0.75rem;
        }

        .main-badge-progress-text {
          font-size: 0.65rem;
        }

        /* Kacheln auf Mobile - 1 Spalte */
        .commands-grid {
          grid-template-columns: 1fr;
          gap: 0.7rem;
        }

        .command-card {
          padding: 0.8rem 0.9rem;
        }
      }

      /* Sehr kleine Bildschirme */
      @media (max-width: 480px) {
        .main-badge {
          flex: 1 1 100%;
          min-width: 100%;
        }

        .main-badge-name {
          font-size: 0.7rem;
        }

        .main-badge-progress-text {
          font-size: 0.6rem;
        }
      }

      /* Desktop 16:9 Optimierung */
      @media (min-width: 1400px) {
        main {
          padding: 1rem 3rem 2rem;
        }

        .badges-header {
          padding: 1.5rem 1.2rem;
          max-width: 1200px;
          margin-left: auto;
          margin-right: auto;
        }

        .main-badges-row {
          grid-template-columns: repeat(5, 1fr);
          max-width: 1100px;
          gap: 1.2rem;
        }

        .sub-badges-row {
          grid-template-columns: repeat(5, 1fr);
          max-width: 1100px;
          gap: 1.2rem;
        }

        .main-badge {
          max-width: 200px;
        }

        .commands-grid {
          grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
          gap: 0.7rem;
        }

        .command-card {
          padding: 0.8rem 0.9rem;
        }

        .command-name {
          font-size: 0.9rem;
        }

        .command-body {
          font-size: 0.8rem;
        }
      }

      /* Tablet Optimierung */
      @media (min-width: 769px) and (max-width: 1023px) {
        .main-badges-row {
          grid-template-columns: repeat(3, 1fr);
          gap: 0.9rem;
        }

        .sub-badges-row {
          grid-template-columns: repeat(3, 1fr);
          gap: 0.9rem;
        }
      }

      /* Mittlere Desktop-Größen */
      @media (min-width: 1024px) and (max-width: 1399px) {
        .main-badges-row {
          grid-template-columns: repeat(4, 1fr);
          gap: 1rem;
        }

        .sub-badges-row {
          grid-template-columns: repeat(4, 1fr);
          gap: 1rem;
        }
      }

      /* Sehr große Bildschirme - Noch mehr Kacheln */
      @media (min-width: 1920px) {
        .commands-grid {
          grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
          gap: 0.6rem;
        }

        .command-card {
          padding: 0.7rem 0.8rem;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <div class="header-inner">
        <h1>Linux CLI Quiz</h1>
        <p class="subtitle">
          Kernbefehle aus dem Cyber-Security-Kurs – jeweils ein
          3‑Fragen‑Mini‑Quiz.
        </p>
        <div class="badges-header" id="badges-header">
          <!-- Badge-Segmente werden hier dynamisch eingefügt -->
        </div>
        <div class="achievements-container" id="achievements-container">
          <!-- Legacy Achievements - wird beibehalten für Kompatibilität -->
        </div>
        <div class="achievement-progress" id="achievement-progress">
          Fortschritt: 0/60 Fragen richtig beantwortet
        </div>
        <div class="search-container">
          <input
            type="text"
            id="search-input"
            class="search-input"
            placeholder="Befehle durchsuchen (z.B. 'ls', 'grep', 'find'...)"
            autocomplete="off"
          />
        </div>
      </div>
    </header>
    <main>
      <section class="commands-grid" id="commands-grid">
        <article class="command-card" data-command="pwd" data-quiz-id="pwd">
          <div class="command-header">
            <h2 class="command-name"><code>pwd</code></h2>
            <span class="command-tag">Navigation</span>
          </div>
          <div class="command-body">
            <p>Zeigt das aktuelle Arbeitsverzeichnis (Pfad) an.</p>
          </div>
        </article>

        <article class="command-card" data-command="cd" data-quiz-id="cd">
          <div class="command-header">
            <h2 class="command-name"><code>cd</code></h2>
            <span class="command-tag">Navigation</span>
          </div>
          <div class="command-body">
            <p>Wechselt in ein anderes Verzeichnis.</p>
          </div>
        </article>

        <article
          class="command-card"
          data-command="cd .."
          data-quiz-id="cd_parent"
        >
          <div class="command-header">
            <h2 class="command-name"><code>cd ..</code></h2>
            <span class="command-tag">Navigation</span>
          </div>
          <div class="command-body">
            <p>Springt eine Ebene in das übergeordnete Verzeichnis.</p>
          </div>
        </article>

        <article class="command-card" data-command="ls" data-quiz-id="ls">
          <div class="command-header">
            <h2 class="command-name"><code>ls</code></h2>
            <span class="command-tag">Auflisten</span>
          </div>
          <div class="command-body">
            <p>Listet Dateien und Ordner im aktuellen Verzeichnis.</p>
          </div>
        </article>

        <article class="command-card" data-command="grep" data-quiz-id="grep">
          <div class="command-header">
            <h2 class="command-name"><code>grep</code></h2>
            <span class="command-tag">Suche</span>
          </div>
          <div class="command-body">
            <p>Durchsucht Text nach Mustern.</p>
          </div>
        </article>

        <article class="command-card" data-command="pipe" data-quiz-id="pipe">
          <div class="command-header">
            <h2 class="command-name"><code>|</code> (Pipe)</h2>
            <span class="command-tag">Pipes</span>
          </div>
          <div class="command-body">
            <p>Verkettet Befehle: Ausgabe → Eingabe.</p>
          </div>
        </article>

        <article
          class="command-card"
          data-command="redirect"
          data-quiz-id="redirect"
        >
          <div class="command-header">
            <h2 class="command-name">
              <code>&gt;</code>, <code>&gt;&gt;</code>, <code>2&gt;</code>
            </h2>
            <span class="command-tag">Umleitung</span>
          </div>
          <div class="command-body">
            <p>Leitet Ausgaben und Fehler in Dateien um.</p>
          </div>
        </article>

        <article
          class="command-card"
          data-command="nano_flow"
          data-quiz-id="nano_flow"
        >
          <div class="command-header">
            <h2 class="command-name">
              <code>nano</code> + <code>chmod +x</code> +
              <code>./script.sh</code>
            </h2>
            <span class="command-tag">Workflow</span>
          </div>
          <div class="command-body">
            <p>
              Ein kompletter Mini‑Workflow zum Schreiben und Ausführen eines
              Scripts.
            </p>
          </div>
        </article>

        <article class="command-card" data-command="ls -a" data-quiz-id="ls_a">
          <div class="command-header">
            <h2 class="command-name"><code>ls -a</code></h2>
            <span class="command-tag">Auflisten</span>
          </div>
          <div class="command-body">
            <p>Listet alle Dateien, inklusive versteckter (beginnen mit .).</p>
          </div>
        </article>

        <article
          class="command-card"
          data-command="ls -la"
          data-quiz-id="ls_la"
        >
          <div class="command-header">
            <h2 class="command-name"><code>ls -la</code></h2>
            <span class="command-tag">Auflisten</span>
          </div>
          <div class="command-body">
            <p>
              Detaillierte Liste aller Dateien mit Rechten, Besitzer, Größe usw.
            </p>
          </div>
        </article>

        <article class="command-card" data-command="mkdir" data-quiz-id="mkdir">
          <div class="command-header">
            <h2 class="command-name"><code>mkdir</code></h2>
            <span class="command-tag">Dateien</span>
          </div>
          <div class="command-body">
            <p>Erstellt einen neuen Ordner.</p>
          </div>
        </article>

        <article
          class="command-card"
          data-command="mkdir -p"
          data-quiz-id="mkdir_p"
        >
          <div class="command-header">
            <h2 class="command-name"><code>mkdir -p</code></h2>
            <span class="command-tag">Dateien</span>
          </div>
          <div class="command-body">
            <p>Erstellt einen Ordner inkl. aller fehlenden Zwischenordner.</p>
          </div>
        </article>

        <article class="command-card" data-command="mv" data-quiz-id="mv">
          <div class="command-header">
            <h2 class="command-name"><code>mv</code></h2>
            <span class="command-tag">Dateien</span>
          </div>
          <div class="command-body">
            <p>Verschiebt Dateien/Ordner oder benennt sie um.</p>
          </div>
        </article>

        <article class="command-card" data-command="cp" data-quiz-id="cp">
          <div class="command-header">
            <h2 class="command-name"><code>cp</code></h2>
            <span class="command-tag">Dateien</span>
          </div>
          <div class="command-body">
            <p>Kopiert Dateien.</p>
          </div>
        </article>

        <article class="command-card" data-command="cp -r" data-quiz-id="cp_r">
          <div class="command-header">
            <h2 class="command-name"><code>cp -r</code></h2>
            <span class="command-tag">Dateien</span>
          </div>
          <div class="command-body">
            <p>Kopiert einen Ordner rekursiv mit Inhalt.</p>
          </div>
        </article>

        <article class="command-card" data-command="rm" data-quiz-id="rm">
          <div class="command-header">
            <h2 class="command-name"><code>rm</code></h2>
            <span class="command-tag">Dateien</span>
          </div>
          <div class="command-body">
            <p>Löscht Dateien.</p>
          </div>
        </article>

        <article class="command-card" data-command="rm -r" data-quiz-id="rm_r">
          <div class="command-header">
            <h2 class="command-name"><code>rm -r</code></h2>
            <span class="command-tag">Dateien</span>
          </div>
          <div class="command-body">
            <p>Löscht Ordner rekursiv inkl. aller Inhalte.</p>
          </div>
        </article>

        <article class="command-card" data-command="cat" data-quiz-id="cat">
          <div class="command-header">
            <h2 class="command-name"><code>cat</code></h2>
            <span class="command-tag">Dateien</span>
          </div>
          <div class="command-body">
            <p>Gibt den Inhalt einer Datei auf stdout aus.</p>
          </div>
        </article>

        <article class="command-card" data-command="sort" data-quiz-id="sort">
          <div class="command-header">
            <h2 class="command-name"><code>sort</code></h2>
            <span class="command-tag">Pipes</span>
          </div>
          <div class="command-body">
            <p>Sortiert Zeilen alphabetisch.</p>
          </div>
        </article>

        <article
          class="command-card"
          data-command="sort -n"
          data-quiz-id="sort_n"
        >
          <div class="command-header">
            <h2 class="command-name"><code>sort -n</code></h2>
            <span class="command-tag">Pipes</span>
          </div>
          <div class="command-body">
            <p>Sortiert Zeilen numerisch (Zahlen korrekt, nicht als Text).</p>
          </div>
        </article>

        <article class="command-card" data-command="uniq" data-quiz-id="uniq">
          <div class="command-header">
            <h2 class="command-name"><code>uniq</code></h2>
            <span class="command-tag">Pipes</span>
          </div>
          <div class="command-body">
            <p>Entfernt doppelte aufeinanderfolgende Zeilen.</p>
          </div>
        </article>

        <article
          class="command-card"
          data-command="find . -name"
          data-quiz-id="find_name"
        >
          <div class="command-header">
            <h2 class="command-name"><code>find . -name "Muster"</code></h2>
            <span class="command-tag">Suche</span>
          </div>
          <div class="command-body">
            <p>
              Sucht rekursiv nach Dateien/Ordnern mit Namen, der zum Muster
              passt.
            </p>
          </div>
        </article>

        <article
          class="command-card"
          data-command="find . -maxdepth 1 -type d"
          data-quiz-id="find_maxdepth"
        >
          <div class="command-header">
            <h2 class="command-name">
              <code>find . -maxdepth 1 -type d</code>
            </h2>
            <span class="command-tag">Suche</span>
          </div>
          <div class="command-body">
            <p>
              Listet nur Ordner im aktuellen Verzeichnis (keine Unterordner).
            </p>
          </div>
        </article>

        <article class="command-card" data-command="ls -R" data-quiz-id="ls_R">
          <div class="command-header">
            <h2 class="command-name"><code>ls -R</code></h2>
            <span class="command-tag">Auflisten</span>
          </div>
          <div class="command-body">
            <p>
              Listet den gesamten Verzeichnisbaum rekursiv (alle Ordner und
              Dateien darunter).
            </p>
          </div>
        </article>

        <article
          class="command-card"
          data-command="ls -aR"
          data-quiz-id="ls_aR"
        >
          <div class="command-header">
            <h2 class="command-name"><code>ls -aR</code></h2>
            <span class="command-tag">Auflisten</span>
          </div>
          <div class="command-body">
            <p>
              Rekursives Auflisten aller Dateien UND versteckter Dateien/Ordner.
            </p>
          </div>
        </article>

        <article class="command-card" data-command="tree" data-quiz-id="tree">
          <div class="command-header">
            <h2 class="command-name"><code>tree</code></h2>
            <span class="command-tag">Auflisten</span>
          </div>
          <div class="command-body">
            <p>Zeigt Verzeichnisstruktur in Baumform.</p>
          </div>
        </article>

        <article
          class="command-card"
          data-command="tree -d"
          data-quiz-id="tree_d"
        >
          <div class="command-header">
            <h2 class="command-name"><code>tree -d</code></h2>
            <span class="command-tag">Auflisten</span>
          </div>
          <div class="command-body">
            <p>Zeigt nur Ordner (directory-only mode).</p>
          </div>
        </article>

        <article
          class="command-card"
          data-command="tree -L"
          data-quiz-id="tree_L"
        >
          <div class="command-header">
            <h2 class="command-name"><code>tree -L</code></h2>
            <span class="command-tag">Auflisten</span>
          </div>
          <div class="command-body">
            <p>Begrenzt die Tiefe der rekursiven Baumdarstellung.</p>
          </div>
        </article>

        <article class="command-card" data-command="echo" data-quiz-id="echo">
          <div class="command-header">
            <h2 class="command-name"><code>echo</code></h2>
            <span class="command-tag">Pipes</span>
          </div>
          <div class="command-body">
            <p>Gibt Text im Terminal aus.</p>
          </div>
        </article>

        <article
          class="command-card"
          data-command=">"
          data-quiz-id="redirect_overwrite"
        >
          <div class="command-header">
            <h2 class="command-name"><code>&gt;</code></h2>
            <span class="command-tag">Umleitung</span>
          </div>
          <div class="command-body">
            <p>Leitet die Ausgabe in eine Datei um (überschreibt).</p>
          </div>
        </article>

        <article
          class="command-card"
          data-command=">>"
          data-quiz-id="redirect_append"
        >
          <div class="command-header">
            <h2 class="command-name"><code>&gt;&gt;</code></h2>
            <span class="command-tag">Umleitung</span>
          </div>
          <div class="command-body">
            <p>Hängt die Ausgabe ans Ende einer Datei an.</p>
          </div>
        </article>

        <article
          class="command-card"
          data-command="2>"
          data-quiz-id="redirect_stderr"
        >
          <div class="command-header">
            <h2 class="command-name"><code>2&gt;</code></h2>
            <span class="command-tag">Umleitung</span>
          </div>
          <div class="command-body">
            <p>Leitet die Fehlerausgabe (stderr) in eine Datei.</p>
          </div>
        </article>

        <article
          class="command-card"
          data-command="whoami"
          data-quiz-id="whoami"
        >
          <div class="command-header">
            <h2 class="command-name"><code>whoami</code></h2>
            <span class="command-tag">System</span>
          </div>
          <div class="command-body">
            <p>Zeigt den aktuellen Benutzer.</p>
          </div>
        </article>

        <article class="command-card" data-command="chmod" data-quiz-id="chmod">
          <div class="command-header">
            <h2 class="command-name"><code>chmod</code></h2>
            <span class="command-tag">Rechte</span>
          </div>
          <div class="command-body">
            <p>Ändert Dateirechte (read/write/execute).</p>
          </div>
        </article>

        <article
          class="command-card"
          data-command="chmod -R"
          data-quiz-id="chmod_R"
        >
          <div class="command-header">
            <h2 class="command-name"><code>chmod -R</code></h2>
            <span class="command-tag">Rechte</span>
          </div>
          <div class="command-body">
            <p>Ändert Rechte rekursiv für Ordner + Unterordner.</p>
          </div>
        </article>

        <article class="command-card" data-command="chown" data-quiz-id="chown">
          <div class="command-header">
            <h2 class="command-name"><code>chown</code></h2>
            <span class="command-tag">Rechte</span>
          </div>
          <div class="command-body">
            <p>Ändert den Besitzer einer Datei.</p>
          </div>
        </article>

        <article class="command-card" data-command="chgrp" data-quiz-id="chgrp">
          <div class="command-header">
            <h2 class="command-name"><code>chgrp</code></h2>
            <span class="command-tag">Rechte</span>
          </div>
          <div class="command-body">
            <p>Ändert nur die Gruppenzugehörigkeit einer Datei.</p>
          </div>
        </article>

        <article class="command-card" data-command="touch" data-quiz-id="touch">
          <div class="command-header">
            <h2 class="command-name"><code>touch</code></h2>
            <span class="command-tag">Dateien</span>
          </div>
          <div class="command-body">
            <p>
              Erstellt eine leere Datei oder aktualisiert das Änderungsdatum.
            </p>
          </div>
        </article>

        <article class="command-card" data-command="head" data-quiz-id="head">
          <div class="command-header">
            <h2 class="command-name"><code>head</code></h2>
            <span class="command-tag">Dateien</span>
          </div>
          <div class="command-body">
            <p>Zeigt die ersten Zeilen einer Datei.</p>
          </div>
        </article>

        <article class="command-card" data-command="tail" data-quiz-id="tail">
          <div class="command-header">
            <h2 class="command-name"><code>tail</code></h2>
            <span class="command-tag">Dateien</span>
          </div>
          <div class="command-body">
            <p>Zeigt die letzten Zeilen einer Datei.</p>
          </div>
        </article>

        <article class="command-card" data-command="wc -l" data-quiz-id="wc_l">
          <div class="command-header">
            <h2 class="command-name"><code>wc -l</code></h2>
            <span class="command-tag">Pipes</span>
          </div>
          <div class="command-body">
            <p>Zählt Zeilen in einer Datei oder Eingabe.</p>
          </div>
        </article>

        <article class="command-card" data-command="wc -w" data-quiz-id="wc_w">
          <div class="command-header">
            <h2 class="command-name"><code>wc -w</code></h2>
            <span class="command-tag">Pipes</span>
          </div>
          <div class="command-body">
            <p>Zählt Wörter.</p>
          </div>
        </article>

        <!-- Hotkeys & Quality of Life Kachel -->
        <article class="command-card hotkeys-card" id="hotkeys-card">
          <div class="command-header">
            <h2 class="command-name">⚡ Hotkeys & Quality of Life</h2>
            <span class="command-tag">Wissen</span>
          </div>
          <div class="command-body">
            <p>
              Tastaturkürzel, Terminal-Tools und Workflow-Verbesserungen für
              effizientes Arbeiten in der Kommandozeile.
            </p>
          </div>
        </article>

        <!-- Kali Linux Tools Kachel -->
        <article class="command-card kali-tools-card" id="kali-tools-card">
          <div class="command-header">
            <h2 class="command-name">🔐 Kali Linux Tools</h2>
            <span class="command-tag">Wissen</span>
          </div>
          <div class="command-body">
            <p>
              Übersicht über essentielle Pentesting-Tools und Setup-Schritte für
              Kali Linux – perfekt für Einsteiger.
            </p>
          </div>
        </article>

        <!-- Beginner Mistakes Kachel -->
        <article class="command-card mistakes-card" id="mistakes-card">
          <div class="command-header">
            <h2 class="command-name">🚧 Top 10 Anfängerfehler</h2>
            <span class="command-tag">Wissen</span>
          </div>
          <div class="command-body">
            <p>
              Häufige Stolpersteine mit kurzer Erklärung, korrektem Beispiel und
              direkter Verlinkung ins Command-Modal.
            </p>
          </div>
        </article>
      </section>
    </main>

    <div id="quiz-root" class="quiz-modal hidden" aria-hidden="true">
      <div class="quiz-backdrop"></div>
      <div class="quiz-modal-inner">
        <div class="quiz-header">
          <div>
            <div class="quiz-title" id="quiz-title">Quiz</div>
            <div class="quiz-level-pill" id="quiz-subtitle">
              3 Fragen: leicht · mittel · schwer
            </div>
          </div>
          <button class="quiz-close-btn" type="button" id="quiz-close-btn">
            ESC
          </button>
        </div>

        <div class="quiz-body" id="quiz-body"></div>

        <div class="quiz-footer">
          <div class="quiz-feedback" id="quiz-feedback"></div>
          <button class="quiz-submit-btn" type="button" id="quiz-submit-btn">
            Quiz auswerten
          </button>
        </div>
      </div>
    </div>

    <!-- Masterquiz-Modal -->
    <div
      id="master-quiz-root"
      class="master-quiz-modal hidden"
      aria-hidden="true"
    >
      <div class="quiz-backdrop"></div>
      <div class="master-quiz-modal-inner">
        <div class="quiz-header">
          <div>
            <div class="quiz-title" id="master-quiz-title">Masterquiz</div>
            <div class="quiz-level-pill" id="master-quiz-subtitle">
              Kombinative Masterfrage
            </div>
          </div>
          <button
            class="quiz-close-btn"
            type="button"
            id="master-quiz-close-btn"
          >
            ESC
          </button>
        </div>

        <div class="quiz-body" id="master-quiz-body"></div>

        <div class="quiz-footer">
          <div class="quiz-feedback" id="master-quiz-feedback"></div>
          <button
            class="quiz-submit-btn"
            type="button"
            id="master-quiz-submit-btn"
          >
            Antwort prüfen
          </button>
        </div>
      </div>
    </div>

    <!-- Command Detail Modal -->
    <div
      id="command-modal-root"
      class="master-quiz-modal command-modal hidden"
      aria-hidden="true"
    >
      <div class="quiz-backdrop"></div>
      <div class="master-quiz-modal-inner" role="dialog" aria-modal="true">
        <div class="quiz-header">
          <div>
            <div class="quiz-title" id="command-modal-title">
              Befehlsdetails
            </div>
            <div class="quiz-level-pill" id="command-modal-subtitle">
              Kontext &amp; Best Practices
            </div>
          </div>
          <button
            class="quiz-close-btn"
            type="button"
            id="command-modal-close-btn"
          >
            ESC
          </button>
        </div>

        <div class="quiz-body" id="command-modal-body">
          <p class="command-summary" id="command-modal-summary"></p>
          <div class="command-meta-grid">
            <div class="command-section">
              <h3>Wichtige Flags</h3>
              <div id="command-modal-flags"></div>
            </div>
            <div class="command-section">
              <h3>Typische Fehler</h3>
              <ul class="pitfalls-list" id="command-modal-pitfalls"></ul>
            </div>
          </div>
          <div class="command-section">
            <h3>Beispiele</h3>
            <div class="example-list" id="command-modal-examples"></div>
          </div>
        </div>

        <div class="quiz-footer">
          <div class="quiz-feedback" id="command-modal-feedback"></div>
          <button
            class="quiz-submit-btn"
            type="button"
            id="command-modal-quiz-btn"
          >
            Quiz zum Befehl starten
          </button>
        </div>
      </div>
    </div>

    <!-- Hotkeys-Modal -->
    <div id="hotkeys-root" class="hotkeys-modal hidden" aria-hidden="true">
      <div class="quiz-backdrop"></div>
      <div class="hotkeys-modal-inner">
        <div class="quiz-header">
          <div>
            <div class="quiz-title">⚡ Hotkeys & Quality of Life</div>
            <div class="quiz-level-pill">Terminal-Workflow Verbesserungen</div>
          </div>
          <button class="quiz-close-btn" type="button" id="hotkeys-close-btn">
            ESC
          </button>
        </div>

        <div class="quiz-body" id="hotkeys-body"></div>
      </div>
    </div>

    <!-- Kali-Tools-Modal -->
    <div
      id="kali-tools-root"
      class="kali-tools-modal hidden"
      aria-hidden="true"
    >
      <div class="quiz-backdrop"></div>
      <div class="kali-tools-modal-inner">
        <div class="quiz-header">
          <div>
            <div class="quiz-title">🔐 Kali Linux Tools</div>
            <div class="quiz-level-pill">Pentesting-Tools & Setup-Guide</div>
            <div
              class="kali-tools-badges-container"
              id="kali-tools-badges-container"
            ></div>
          </div>
          <button
            class="quiz-close-btn"
            type="button"
            id="kali-tools-close-btn"
          >
            ESC
          </button>
        </div>

        <div class="quiz-body" id="kali-tools-body"></div>
      </div>
    </div>

    <!-- Kali-Tools Example Overlay -->
    <div
      id="kali-tools-example-overlay"
      class="kali-tools-overlay hidden"
      aria-hidden="true"
    >
      <div class="quiz-backdrop"></div>
      <div
        id="kali-tools-example-overlay-inner"
        class="kali-tools-overlay-inner"
      >
        <div class="kali-tools-overlay-header">
          <div
            id="kali-tools-example-overlay-title"
            class="kali-tools-overlay-title"
          ></div>
          <button
            type="button"
            class="kali-tools-overlay-close"
            id="kali-tools-example-overlay-close"
          >
            ✕ Schließen
          </button>
        </div>
        <div
          id="kali-tools-example-overlay-content"
          class="kali-tools-overlay-content"
        ></div>
      </div>
    </div>

    <!-- Beginner-Mistakes-Modal -->
    <div id="mistakes-root" class="hotkeys-modal hidden" aria-hidden="true">
      <div class="quiz-backdrop"></div>
      <div class="hotkeys-modal-inner">
        <div class="quiz-header">
          <div>
            <div class="quiz-title">🚧 Top 10 Anfängerfehler</div>
            <div class="quiz-level-pill">
              Verstehe typische Fehltritte und springe direkt zum passenden
              Quiz.
            </div>
          </div>
          <button class="quiz-close-btn" type="button" id="mistakes-close-btn">
            ESC
          </button>
        </div>

        <div class="quiz-body" id="mistakes-body"></div>
      </div>
    </div>

    <script>
      // Suppress browser extension message channel errors (harmless but annoying)
      window.addEventListener(
        "error",
        (event) => {
          if (
            event.message &&
            typeof event.message === "string" &&
            event.message.includes("message channel closed")
          ) {
            event.preventDefault();
            event.stopPropagation();
            return false;
          }
        },
        true
      );

      window.addEventListener("unhandledrejection", (event) => {
        if (
          event.reason &&
          typeof event.reason === "object" &&
          event.reason.message
        ) {
          if (
            typeof event.reason.message === "string" &&
            event.reason.message.includes("message channel closed")
          ) {
            event.preventDefault();
            return;
          }
        } else if (
          typeof event.reason === "string" &&
          event.reason.includes("message channel closed")
        ) {
          event.preventDefault();
          return;
        }
      });

      // Quiz-Daten – geprüfte & polierte Version
      const quizData = {
        pwd: {
          title: "pwd",
          description: "Arbeite bewusst mit dem aktuellen Arbeitsverzeichnis.",
          explanation: "Zeigt das aktuelle Arbeitsverzeichnis.",
          simpleExample: "pwd → /home/user",
          detail:
            "Sehr praktisch in Kombination mit cd .., um zu überprüfen, wo du gerade „gelandet“ bist.",
          complexExample: 'echo "Aktuelles Verzeichnis: $(pwd)" >> script.log',
          complexExampleExplanation: [
            {
              line: 'echo "Aktuelles Verzeichnis: $(pwd)" >> script.log',
              explanation:
                "$(pwd) wird durch den aktuellen Pfad ersetzt, echo gibt den Text aus, >> hängt ihn an script.log an (ohne Überschreibung)",
            },
          ],
          flags: [
            {
              flag: "-P",
              description: "zeigt den physischen Pfad ohne Symlinks",
              utility: "mittel",
              risk: "niedrig (nur Anzeige)",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Was macht der Befehl `pwd`?",
              options: [
                "Er zeigt das aktuelle Verzeichnis (den absoluten Pfad) an.",
                "Er listet alle Dateien im aktuellen Verzeichnis auf.",
                "Er wechselt ins Home-Verzeichnis.",
                "Er zeigt die Berechtigungen einer Datei an.",
              ],
              correctIndex: 0,
              explanation:
                "`pwd` = print working directory – zeigt den vollständigen Pfad deines aktuellen Verzeichnisses.",
            },
            {
              level: "mittel",
              prompt:
                "Du befindest dich in `/home/user/Documents` und führst `cd /tmp && pwd` aus. Was wird angezeigt?",
              options: ["/home/user/Documents", "/tmp", "/home/user", "/"],
              correctIndex: 1,
              explanation:
                "Nach `cd /tmp` ist dein Arbeitsverzeichnis `/tmp`, also zeigt `pwd` genau diesen Pfad.",
            },
            {
              level: "schwer",
              prompt:
                "Was ist der Unterschied zwischen der Builtin-Version von `pwd` (in der Shell) und dem externen `pwd`-Befehl (`/bin/pwd`)?",
              options: [
                "Das Builtin folgt Symbolic Links, `/bin/pwd` zeigt den physikalischen Pfad (mit `-P`).",
                "Das Builtin funktioniert nur mit Root-Rechten, `/bin/pwd` nicht.",
                "Das Builtin zeigt relative Pfade, `/bin/pwd` absolute Pfade.",
                "Es gibt keinen Unterschied, beide sind identisch.",
              ],
              correctIndex: 0,
              explanation:
                "Das Shell-Builtin `pwd` kann Symbolic Links folgen, während `/bin/pwd -P` den physikalischen Pfad (ohne Links) zeigt. Standardmäßig geben beide absolute Pfade aus.",
            },
          ],
        },

        cd: {
          title: "cd",
          description: "Verzeichnisse wechseln – Grundlage jeder Navigation.",
          explanation: "Wechselt in ein anderes Verzeichnis.",
          simpleExample: "cd /home/user/Documents",
          detail:
            "Mit cd ohne Argument kehrst du in dein Home zurück: cd → /home/user",
          complexExample:
            'OLDPWD=$(pwd)\n\ncd /home/user/Downloads\n\nls > download_list.txt\n\ncd "$OLDPWD"',
          complexExampleExplanation: [
            {
              line: "OLDPWD=$(pwd)",
              explanation:
                "Speichert den aktuellen Pfad in der Variable OLDPWD für späteren Rückweg",
            },
            {
              line: "cd /home/user/Downloads",
              explanation:
                "Wechselt ins Downloads-Verzeichnis (absoluter Pfad)",
            },
            {
              line: "ls > download_list.txt",
              explanation:
                "Listet alle Dateien auf und speichert die Ausgabe in download_list.txt (überschreibt die Datei)",
            },
            {
              line: 'cd "$OLDPWD"',
              explanation:
                "Wechselt zurück zum ursprünglichen Verzeichnis (die Variable wird in Anführungszeichen gesetzt, falls Leerzeichen enthalten sind)",
            },
          ],
          flags: [
            {
              flag: "(ohne Argument)",
              description: "wechselt ins Home-Verzeichnis",
              utility: "hoch",
              risk: "niedrig",
            },
            {
              flag: "-",
              description: "wechselt ins vorherige Verzeichnis (Toggle)",
              utility: "hoch",
              risk: "niedrig",
            },
            {
              flag: "..",
              description: "Parent-Verzeichnis",
              utility: "hoch",
              risk: "niedrig",
            },
            {
              flag: "~user",
              description: "ins Home von user",
              utility: "mittel",
              risk: "niedrig (nur Navigation)",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt:
                "Welcher Befehl wechselt in das Verzeichnis `/home/user/Documents`?",
              options: [
                "open /home/user/Documents",
                "ls /home/user/Documents",
                "cd /home/user/Documents",
                "pwd /home/user/Documents",
              ],
              correctIndex: 2,
              explanation:
                "`cd` steht für change directory und wechselt das Verzeichnis.",
            },
            {
              level: "mittel",
              prompt:
                "Du bist in `/home/user` und führst `cd Documents/Projects` aus. Wo landest du?",
              options: [
                "/Documents/Projects",
                "/home/Documents/Projects",
                "/home/user/Documents/Projects",
                "/home/user/Projects",
              ],
              correctIndex: 2,
              explanation:
                "Ohne `/` am Anfang ist es ein relativer Pfad, ausgehend vom aktuellen Verzeichnis.",
            },
            {
              level: "schwer",
              prompt:
                "Welche Variante wechselt in das vorherige Verzeichnis (Toggle zwischen zwei Verzeichnissen)?",
              options: ["`cd ..`", "`cd -`", "`cd ~`", "`cd /`"],
              correctIndex: 1,
              explanation:
                "`cd -` wechselt zum vorherigen Verzeichnis (OLDPWD) und ist praktisch wie ein Zurück-Button.",
            },
          ],
        },

        cd_parent: {
          title: "cd ..",
          description: "Eine Ebene nach oben springen.",
          explanation: "Wechselt ein Verzeichnis nach oben (Parent).",
          simpleExample: "cd ..\n\nvon /home/user/Documents → /home/user",
          detail:
            "Du kannst auch cd ../.. verwenden, um zwei Ebenen hochzugehen.",
          complexExample:
            'cd "$(dirname "$0")/.."   # ein Level hoch relativ zum Script\n\npwd >> where_am_i.log',
          complexExampleExplanation: [
            {
              line: 'cd "$(dirname "$0")/.."',
              explanation:
                'dirname "$0" gibt das Verzeichnis des aktuellen Scripts zurück, /.. geht eine Ebene hoch, cd wechselt dorthin',
            },
            {
              line: "pwd >> where_am_i.log",
              explanation:
                "Zeigt den aktuellen Pfad an und hängt ihn an where_am_i.log an (für Logging/Debugging)",
            },
          ],
          additionalExamples: `
✅ <strong>1. Eine Ebene hoch gehen und dann prüfen wo du bist</strong><br>
<code>cd ..</code><br>
<code>pwd</code><br>
→ Geht eine Ebene nach oben, pwd zeigt den neuen Pfad<br><br>

✅ <strong>2. Nach oben gehen und dann den Inhalt auflisten</strong><br>
<code>cd ..</code><br>
<code>ls</code><br>
→ Wechselt ins Parent-Verzeichnis, ls zeigt was dort ist<br><br>

✅ <strong>3. Zwei Ebenen hoch gehen</strong><br>
<code>cd ../..</code><br>
<code>pwd</code><br>
→ Geht zwei Ebenen nach oben, pwd zeigt den neuen Pfad<br><br>

✅ <strong>4. In einen Ordner wechseln, dann zurück nach oben</strong><br>
<code>cd Documents</code><br>
<code>cd ..</code><br>
<code>ls</code><br>
→ Wechselt ins Documents-Verzeichnis, geht zurück nach oben, ls zeigt den Inhalt<br><br>

✅ <strong>5. Nach oben gehen und dann Dateien kopieren</strong><br>
<code>cd ..</code><br>
<code>cp file.txt backup/</code><br>
→ Geht eine Ebene hoch, kopiert dann eine Datei ins backup-Verzeichnis
          `,
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `cd ..`?",
              options: [
                "Wechselt ins Home-Verzeichnis.",
                "Wechselt ins übergeordnete Verzeichnis.",
                "Wechselt ins Wurzelverzeichnis `/`.",
                "Wechselt in ein verstecktes Verzeichnis.",
              ],
              correctIndex: 1,
              explanation:
                "`..` ist immer das Parent-Verzeichnis (eine Ebene höher).",
            },
            {
              level: "mittel",
              prompt:
                "Du bist in `/home/user/Documents` und führst zweimal `cd ..` aus. Wo bist du?",
              options: ["/home/user/Documents/..", "/home/user", "/home", "/"],
              correctIndex: 2,
              explanation: "Einmal `cd ..` → `/home/user`, zweimal → `/home`.",
            },
            {
              level: "schwer",
              prompt:
                "Von welchem Startpfad aus bringt dich `cd ../..` direkt nach `/home`?",
              options: [
                "Aus `/home/user/Documents`",
                "Aus `/home/user`",
                "Aus `/home/user/Docs`",
                "Aus `/home`",
              ],
              correctIndex: 2,
              explanation:
                "Von `/home/user/Docs` aus geht `../..` zwei Ebenen hoch: `/home/user/Docs` → `/home/user` → `/home`.",
            },
          ],
        },

        ls: {
          title: "ls",
          description: "Dateien und Ordner auflisten.",
          explanation: "Listet Dateien und Ordner im aktuellen Verzeichnis.",
          simpleExample: "ls",
          detail:
            "ls sortiert standardmäßig alphabetisch; mit ls -t nach Änderungszeit.",
          complexExample: "ls *.log 2>/dev/null | wc -l",
          complexExampleExplanation: [
            {
              line: "ls *.log 2>/dev/null | wc -l",
              explanation:
                "ls *.log listet alle .log-Dateien, 2>/dev/null versteckt Fehler (z.B. wenn keine .log-Dateien existieren), | leitet an wc -l weiter, das die Anzahl der Zeilen (also Dateien) zählt",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt:
                "Welcher Befehl listet Dateien im aktuellen Verzeichnis auf?",
              options: ["show", "ls", "pwd", "open"],
              correctIndex: 1,
              explanation:
                "`ls` ist der Standardbefehl zum Auflisten des Inhalts eines Verzeichnisses.",
            },
            {
              level: "mittel",
              prompt:
                "Welche Option zeigt dir zusätzlich versteckte Dateien (Einträge, die mit `.` beginnen)?",
              options: ["`ls -l`", "`ls -R`", "`ls -a`", "`ls -h`"],
              correctIndex: 2,
              explanation:
                "`-a` steht für „all“ und zeigt auch versteckte Einträge.",
            },
            {
              level: "schwer",
              prompt:
                "Du möchtest eine detaillierte, rekursive Liste aller Dateien (inkl. versteckter) und dabei Dateitypen unterscheiden können. Welche Kombination erfüllt alle Anforderungen?",
              options: ["`ls -lRa`", "`ls -R`", "`ls -al`", "`ls -aR`"],
              correctIndex: 0,
              explanation:
                "`-l` = Details (zeigt Dateityp mit erstem Zeichen), `-a` = versteckte Dateien, `-R` = rekursiv. Die Reihenfolge der Optionen ist egal, aber alle drei müssen vorhanden sein.",
            },
          ],
        },

        grep: {
          title: "grep",
          description: "Texte nach Mustern durchsuchen.",
          explanation: "Sucht nach Textmustern in Dateien oder Eingaben.",
          simpleExample: 'grep "Error" logfile.txt',
          detail:
            "Mit -n Zeilennummern anzeigen, mit -i Groß-/Kleinschreibung ignorieren.",
          complexExample: 'grep -n "TODO" *.sh',
          additionalExamples: `
✅ <strong>1. In einer Datei suchen (die du mit cat anzeigen könntest)</strong><br>
<code>cat log.txt</code><br>
<code>grep "Error" log.txt</code><br>
→ cat zeigt den ganzen Inhalt, grep filtert nur Zeilen mit "Error"<br><br>

✅ <strong>2. Suche und dann sortiere die Ergebnisse</strong><br>
<code>grep "user" names.txt</code><br>
<code>grep "user" names.txt | sort</code><br>
→ Findet alle Zeilen mit "user", sort sortiert sie alphabetisch<br><br>

✅ <strong>3. Suche in mehreren Dateien (die du mit find finden könntest)</strong><br>
<code>find . -name "*.log"</code><br>
<code>grep "Error" *.log</code><br>
→ find zeigt alle .log-Dateien, grep sucht "Error" in allen .log-Dateien<br><br>

✅ <strong>4. Suche und zeige nur die ersten 5 Treffer</strong><br>
<code>grep "TODO" *.txt</code><br>
<code>grep "TODO" *.txt | head -n 5</code><br>
→ Findet alle "TODO" Einträge, head zeigt nur die ersten 5 Zeilen<br><br>

✅ <strong>5. Suche, sortiere und entferne Duplikate</strong><br>
<code>grep "admin" users.txt</code><br>
<code>grep "admin" users.txt | sort | uniq</code><br>
→ Findet "admin", sort sortiert, uniq entfernt doppelte Zeilen
          `,
          complexExampleExplanation: [
            {
              line: 'grep -n "TODO" *.sh',
              explanation:
                'grep sucht nach "TODO", -n zeigt Zeilennummern an, *.sh durchsucht alle .sh-Dateien im aktuellen Verzeichnis',
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: 'Was macht `grep "Error" logfile.txt`?',
              options: [
                'Es löscht alle Zeilen mit "Error".',
                'Es zeigt alle Zeilen mit "Error" in `logfile.txt`.',
                "Es sortiert `logfile.txt` alphabetisch.",
                "Es kopiert `logfile.txt` in eine andere Datei.",
              ],
              correctIndex: 1,
              explanation:
                "`grep` filtert und zeigt nur Zeilen, die zum Suchmuster passen.",
            },
            {
              level: "mittel",
              prompt:
                'Du musst rekursiv in allen `.log`-Dateien nach "failed" suchen, aber andere Dateitypen ignorieren. Welcher Befehl ist korrekt?',
              options: [
                '`grep -r "failed" *.log`',
                '`grep -r "failed" --include="*.log" .`',
                "`grep -R \"failed\" . -name '*.log'`",
                "`grep \"failed\" $(find . -name '*.log')`",
              ],
              correctIndex: 1,
              explanation:
                "`grep -r` sucht rekursiv, `--include='*.log'` beschränkt die Suche auf `.log`-Dateien, `.` gibt das Startverzeichnis an. Die Reihenfolge ist wichtig: Optionen vor Suchmuster.",
            },
            {
              level: "schwer",
              prompt:
                "Welche Variante hebt Treffer farbig hervor (falls unterstützt)?",
              options: [
                '`grep --color=auto "pattern" file`',
                '`grep -c "pattern" file`',
                '`grep -v "pattern" file`',
                '`grep -n "pattern" file`',
              ],
              correctIndex: 0,
              explanation:
                "`--color=auto` markiert gefundene Muster farbig – ideal zum schnellen Scannen.",
            },
          ],
        },

        pipe: {
          title: "Pipe |",
          description: "Befehle zu einer Verarbeitungskette verknüpfen.",
          explanation:
            "Leitet die Ausgabe eines Befehls als Eingabe an den nächsten weiter.",
          simpleExample: "ls | sort",
          detail:
            "Pipes verbinden stdout → stdin; viele kleine Werkzeuge zusammen verwenden.",
          complexExample: "cat errors.log | sort | uniq > unique_errors.txt",
          complexExampleExplanation: [
            {
              line: "cat errors.log | sort | uniq > unique_errors.txt",
              explanation:
                "cat liest errors.log, | leitet an sort weiter (sortiert alphabetisch), | leitet an uniq weiter (entfernt Duplikate), > speichert das Ergebnis in unique_errors.txt",
            },
          ],
          additionalExamples: `
✅ <strong>1. Dateien auflisten und sortieren</strong><br>
<code>ls</code><br>
<code>ls | sort</code><br>
→ ls zeigt Dateien, sort sortiert sie alphabetisch<br><br>

✅ <strong>2. Datei anzeigen, dann nach etwas suchen</strong><br>
<code>cat log.txt</code><br>
<code>cat log.txt | grep "Error"</code><br>
→ cat zeigt den Inhalt, grep filtert nur Zeilen mit "Error"<br><br>

✅ <strong>3. Suche, sortiere und entferne Duplikate</strong><br>
<code>grep "user" names.txt</code><br>
<code>grep "user" names.txt | sort | uniq</code><br>
→ Findet "user", sort sortiert, uniq entfernt doppelte Zeilen<br><br>

✅ <strong>4. Dateien auflisten und zählen</strong><br>
<code>ls</code><br>
<code>ls | wc -l</code><br>
→ ls zeigt Dateien, wc -l zählt wie viele es sind<br><br>

✅ <strong>5. Suche, zeige nur die ersten Treffer</strong><br>
<code>grep "TODO" *.txt</code><br>
<code>grep "TODO" *.txt | head -n 10</code><br>
→ Findet alle "TODO" Einträge, head zeigt nur die ersten 10
          `,
          questions: [
            {
              level: "leicht",
              prompt: "Was macht das Pipe-Symbol `|`?",
              options: [
                "Es kommentiert eine Zeile aus.",
                "Es startet einen neuen Terminal-Tab.",
                "Es leitet die Ausgabe eines Befehls als Eingabe an den nächsten weiter.",
                "Es löscht die Ausgabe eines Befehls.",
              ],
              correctIndex: 2,
              explanation:
                "Mit `Befehl1 | Befehl2` geht `stdout` von Befehl1 als `stdin` an Befehl2.",
            },
            {
              level: "mittel",
              prompt: "Was macht `ls | sort`?",
              options: [
                "Listet Dateien und sortiert sie alphabetisch.",
                "Sortiert Dateien nach Größe.",
                "Zeigt nur versteckte Dateien.",
                "Löscht doppelte Dateinamen.",
              ],
              correctIndex: 0,
              explanation:
                "`ls` liefert die Liste, `sort` sortiert diese Liste alphabetisch.",
            },
            {
              level: "schwer",
              prompt:
                "Wie würdest du alle eindeutigen Fehlertypen aus `errors.log` extrahieren (alphabetisch, ohne Duplikate)?",
              options: [
                "`cat errors.log | uniq | sort`",
                "`cat errors.log | sort | uniq`",
                "`uniq errors.log | sort`",
                "`sort -n errors.log | uniq`",
              ],
              correctIndex: 1,
              explanation:
                "Erst sortieren, dann `uniq`, damit doppelte Zeilen direkt hintereinander liegen und zusammengefasst werden.",
            },
          ],
        },

        redirect: {
          title: "Umleitung",
          description: "stdout/stderr in Dateien umleiten.",
          explanation: "Leitet Ausgaben und Fehler in Dateien um.",
          simpleExample: "echo Hallo > out.txt",
          detail:
            "`>` überschreibt, `>>` hängt an; `2>&1` kombiniert stderr mit stdout.",
          complexExample: "command > all.log 2>&1",
          complexExampleExplanation: [
            {
              line: "command > all.log 2>&1",
              explanation:
                "command führt einen Befehl aus, > all.log leitet stdout in all.log um, 2>&1 leitet stderr (2) auf stdout (1) um, sodass beide Streams in derselben Datei landen",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `echo Hallo > out.txt`?",
              options: [
                'Hängt "Hallo" an `out.txt` an.',
                'Überschreibt `out.txt` mit "Hallo" (oder erstellt die Datei).',
                'Zeigt "Hallo" nur im Terminal an.',
                "Löscht die Datei `out.txt`.",
              ],
              correctIndex: 1,
              explanation:
                "`>` überschreibt (oder erstellt) die Datei und schreibt die Standardausgabe hinein.",
            },
            {
              level: "mittel",
              prompt:
                "Du willst Log-Ausgaben an eine Datei anhängen statt sie zu überschreiben. Welche Variante ist korrekt?",
              options: [
                "`echo Neu > log.txt`",
                "`echo Neu >> log.txt`",
                "`echo Neu 2> log.txt`",
                "`echo Neu | log.txt`",
              ],
              correctIndex: 1,
              explanation:
                "`>>` fügt Text am Ende der Datei an, ohne den bestehenden Inhalt zu löschen.",
            },
            {
              level: "schwer",
              prompt:
                "Wie leitest du sowohl stdout als auch stderr in dieselbe Datei `all.log` um?",
              options: [
                "`command > all.log 2> all.log`",
                "`command 2> all.log`",
                "`command > all.log 2>&1`",
                "`command &> all.log && 2>`",
              ],
              correctIndex: 2,
              explanation:
                "`> all.log 2>&1` lenkt stderr (2) auf den gleichen Stream wie stdout (1), der in `all.log` landet.",
            },
          ],
        },

        nano_flow: {
          title: "Nano + Script-Workflow",
          description:
            "Script schreiben, speichern, ausführbar machen, starten.",
          explanation:
            "Script schreiben, ausführbar machen und starten (Editor + Rechte).",
          simpleExample:
            "STRG+O (speichern) → chmod +x script.sh → ./script.sh",
          detail: "STRG+O speichert in nano; chmod +x setzt das Execute-Bit.",
          complexExample: "nano script.sh\n\nchmod +x script.sh\n\n./script.sh",
          complexExampleExplanation: [
            {
              line: "nano script.sh",
              explanation:
                "Öffnet den Editor nano zum Bearbeiten von script.sh (STRG+O speichern, STRG+X beenden)",
            },
            {
              line: "chmod +x script.sh",
              explanation:
                "Setzt das Ausführungsbit (x) für script.sh, damit es direkt ausgeführt werden kann",
            },
            {
              line: "./script.sh",
              explanation:
                "Führt das Script im aktuellen Verzeichnis aus (./ bedeutet aktuelles Verzeichnis)",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt:
                "Welche Tastenkombination speichert eine Datei in `nano`?",
              options: ["STRG + X", "STRG + S", "STRG + O", "STRG + Q"],
              correctIndex: 2,
              explanation:
                "In `nano` steht STRG+O (write Out) für Speichern, STRG+X beendet den Editor.",
            },
            {
              level: "mittel",
              prompt:
                "Welche zwei Befehle brauchst du minimal, um `script.sh` ausführbar zu machen und direkt zu starten?",
              options: [
                "`chmod +x script.sh` und `./script.sh`",
                "`nano script.sh` und `bash script.sh`",
                "`chown script.sh` und `run script.sh`",
                "`exec script.sh` und `run script.sh`",
              ],
              correctIndex: 0,
              explanation:
                "Mit `chmod +x` setzt du das Ausführungsbit, `./script.sh` startet das Script im aktuellen Verzeichnis.",
            },
            {
              level: "schwer",
              prompt:
                "Warum schlägt `./script.sh` typischerweise fehl, obwohl die Datei existiert? Was ist die wahrscheinlichste Ursache?",
              options: [
                "Die Datei liegt nicht im PATH.",
                "Die Datei hat keine Ausführungsrechte.",
                "Das Terminal unterstützt keine Shell.",
                "Das Script heißt eigentlich `script.bash`.",
              ],
              correctIndex: 1,
              explanation:
                "Bei `./script.sh` wird der PATH nicht benötigt – häufig fehlt einfach das Execute-Bit (`chmod +x script.sh`).",
            },
          ],
        },

        ls_a: {
          title: "ls -a",
          description:
            "Listet alle Dateien, inklusive versteckter (beginnen mit .).",
          explanation: "Zeigt auch versteckte Dateien.",
          simpleExample: "ls -a",
          detail: "Zeigt auch . (aktuelles Verzeichnis) und .. (Parent).",
          complexExample: 'cd ~\nls -a | grep "^\\."',
          complexExampleExplanation: [
            {
              line: "cd ~",
              explanation:
                "Wechselt ins Home-Verzeichnis (~ ist eine Abkürzung für $HOME)",
            },
            {
              line: 'ls -a | grep "^\\."',
              explanation:
                'ls -a zeigt alle Dateien (inkl. versteckter), | leitet an grep weiter, "^\\." filtert nur Zeilen, die mit einem Punkt beginnen (versteckte Dateien)',
            },
          ],
          additionalExamples: `
✅ <strong>1. Normale Liste vs. alle Dateien</strong><br>
<code>ls</code><br>
<code>ls -a</code><br>
→ ls zeigt nur normale Dateien, ls -a zeigt auch versteckte (mit .)<br><br>

✅ <strong>2. In ein Verzeichnis wechseln und dann alles anzeigen</strong><br>
<code>cd Documents</code><br>
<code>ls -a</code><br>
→ Wechselt ins Documents-Verzeichnis, ls -a zeigt alle Dateien dort<br><br>

✅ <strong>3. Prüfen wo du bist, dann alles auflisten</strong><br>
<code>pwd</code><br>
<code>ls -a</code><br>
→ pwd zeigt deinen Pfad, ls -a zeigt alle Dateien im aktuellen Verzeichnis<br><br>

✅ <strong>4. Liste speichern und dann anzeigen</strong><br>
<code>ls -a > alle_dateien.txt</code><br>
<code>cat alle_dateien.txt</code><br>
→ Speichert die Liste in eine Datei, cat zeigt den Inhalt<br><br>

✅ <strong>5. Versteckte Dateien finden und dann auflisten</strong><br>
<code>ls -a</code><br>
<code>ls -a | grep "^\\.bash"</code><br>
→ Zeigt alle Dateien, grep filtert nur .bash-Dateien (versteckte Config-Dateien)
          `,
          questions: [
            {
              level: "leicht",
              prompt: "Was zeigt `ls -a` zusätzlich zu normalen Dateien?",
              options: [
                "Nur Dateien mit Schreibrechten",
                "Versteckte Dateien (beginnen mit .)",
                "Nur Ordner",
                "Nur ausführbare Dateien",
              ],
              correctIndex: 1,
              explanation:
                "`-a` steht für 'all' und zeigt auch versteckte Einträge, die mit einem Punkt beginnen.",
            },
            {
              level: "mittel",
              prompt: "Welche Einträge zeigt `ls -a` immer an?",
              options: [
                "Nur . und ..",
                ". (aktuelles Verzeichnis) und .. (Parent-Verzeichnis)",
                "Nur versteckte Dateien",
                "Alle Dateien außer ..",
              ],
              correctIndex: 1,
              explanation:
                "`ls -a` zeigt immer . (aktuelles Verzeichnis) und .. (übergeordnetes Verzeichnis) zusätzlich zu allen anderen Dateien.",
            },
            {
              level: "schwer",
              prompt:
                "Wie listest du nur die versteckten Dateien im Home-Verzeichnis auf?",
              options: [
                "ls -a ~",
                "cd ~ && ls -a | grep '^\\.'",
                "ls ~ -h",
                "find ~ -name '.*'",
              ],
              correctIndex: 1,
              explanation:
                "Mit `ls -a | grep '^\\.'` filterst du nur Einträge, die mit einem Punkt beginnen.",
            },
          ],
        },

        ls_la: {
          title: "ls -la",
          description:
            "Detaillierte Liste aller Dateien mit Rechten, Besitzer, Größe usw.",
          explanation: "Details + versteckte Dateien.",
          simpleExample: "ls -la",
          detail:
            "Das erste Zeichen der Zeile zeigt den Typ: - Datei, d Verzeichnis, l Link.",
          complexExample: "ls -la | awk '{print $1, $9}'",
          complexExampleExplanation: [
            {
              line: "ls -la | awk '{print $1, $9}'",
              explanation:
                "ls -la zeigt Details aller Dateien, | leitet an awk weiter, awk extrahiert Spalte 1 (Rechte) und Spalte 9 (Dateiname) und gibt sie aus",
            },
          ],
          additionalExamples: `
✅ <strong>1. Normale Liste vs. detaillierte Liste</strong><br>
<code>ls</code><br>
<code>ls -la</code><br>
→ ls zeigt nur Namen, ls -la zeigt Details (Rechte, Besitzer, Größe, Datum)<br><br>

✅ <strong>2. Prüfen wo du bist, dann Details anzeigen</strong><br>
<code>pwd</code><br>
<code>ls -la</code><br>
→ pwd zeigt deinen Pfad, ls -la zeigt alle Dateien mit Details<br><br>

✅ <strong>3. In einen Ordner wechseln und Details anzeigen</strong><br>
<code>cd Documents</code><br>
<code>ls -la</code><br>
→ Wechselt ins Documents-Verzeichnis, zeigt alle Dateien mit Details<br><br>

✅ <strong>4. Details speichern und dann anzeigen</strong><br>
<code>ls -la > dateien_details.txt</code><br>
<code>cat dateien_details.txt</code><br>
→ Speichert die detaillierte Liste in eine Datei, cat zeigt den Inhalt<br><br>

✅ <strong>5. Details anzeigen und dann nach etwas suchen</strong><br>
<code>ls -la</code><br>
<code>ls -la | grep ".txt"</code><br>
→ Zeigt alle Details, grep filtert nur .txt-Dateien
          `,
          questions: [
            {
              level: "leicht",
              prompt: "Was zeigt `ls -la` zusätzlich zu `ls`?",
              options: [
                "Nur versteckte Dateien",
                "Details (Rechte, Besitzer, Größe) und versteckte Dateien",
                "Nur Dateigrößen",
                "Nur Besitzer",
              ],
              correctIndex: 1,
              explanation:
                "`-l` zeigt Details, `-a` zeigt versteckte Dateien. Kombiniert: alles mit Details.",
            },
            {
              level: "mittel",
              prompt:
                "Was bedeutet das erste Zeichen 'd' in der Ausgabe von `ls -la`?",
              options: [
                "Datei",
                "Verzeichnis (Directory)",
                "Link",
                "Ausführbar",
              ],
              correctIndex: 1,
              explanation:
                "Das erste Zeichen zeigt den Dateityp: 'd' = Directory (Verzeichnis), '-' = Datei, 'l' = Link.",
            },
            {
              level: "schwer",
              prompt:
                "Wie zeigst du nur Rechte und Dateinamen aus `ls -la` an?",
              options: [
                "ls -la | cut -d' ' -f1,9",
                "ls -la | awk '{print $1, $9}'",
                "ls -la | grep -o '^[^ ]* [^ ]*$'",
                "Alle oben genannten funktionieren",
              ],
              correctIndex: 3,
              explanation:
                "Es gibt mehrere Wege, aber `awk '{print $1, $9}'` ist am einfachsten: Spalte 1 = Rechte, Spalte 9 = Dateiname.",
            },
          ],
        },

        mkdir: {
          title: "mkdir",
          description: "Erstellt einen neuen Ordner.",
          explanation: "Ordner erstellen.",
          simpleExample: "mkdir Test",
          detail:
            "Fehlschlag, wenn der Ordner schon existiert (außer du nutzt -p).",
          complexExample: "mkdir Music Images Documents Scripts",
          complexExampleExplanation: [
            {
              line: "mkdir Music Images Documents Scripts",
              explanation:
                "Erstellt vier Ordner gleichzeitig: Music, Images, Documents und Scripts (mehrere Argumente werden als separate Ordner interpretiert)",
            },
          ],
          additionalExamples: `
✅ <strong>1. Ordner erstellen und dann prüfen wo du bist</strong><br>
<code>mkdir my_folder</code><br>
<code>pwd</code><br>
→ Erstellt den Ordner, pwd zeigt deinen aktuellen Pfad<br><br>

✅ <strong>2. Ordner erstellen und dann den Inhalt anzeigen</strong><br>
<code>mkdir backup</code><br>
<code>ls</code><br>
→ Erstellt backup, ls zeigt dass der neue Ordner existiert<br><br>

✅ <strong>3. Ordner erstellen, hinein wechseln, prüfen</strong><br>
<code>mkdir projects</code><br>
<code>cd projects</code><br>
<code>pwd</code><br>
→ Erstellt projects, wechselt hinein, zeigt den neuen Pfad<br><br>

✅ <strong>4. Mehrere Ordner erstellen und dann auflisten</strong><br>
<code>mkdir folder1 folder2 folder3</code><br>
<code>ls</code><br>
→ Erstellt drei Ordner auf einmal, ls zeigt alle<br><br>

✅ <strong>5. Ordner erstellen, Dateien kopieren, dann Inhalt prüfen</strong><br>
<code>mkdir archive</code><br>
<code>cp *.txt archive/</code><br>
<code>ls archive/</code><br>
→ Erstellt archive, kopiert Dateien hinein, ls zeigt den Inhalt
          `,
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `mkdir Test`?",
              options: [
                "Löscht den Ordner Test",
                "Erstellt einen neuen Ordner namens Test",
                "Zeigt den Inhalt von Test",
                "Kopiert Test",
              ],
              correctIndex: 1,
              explanation:
                "`mkdir` steht für 'make directory' und erstellt einen neuen Ordner.",
            },
            {
              level: "mittel",
              prompt:
                "Was passiert, wenn du `mkdir Test` ausführst, aber Test bereits existiert?",
              options: [
                "Der Ordner wird überschrieben",
                "Es gibt einen Fehler",
                "Der Ordner wird umbenannt",
                "Nichts passiert",
              ],
              correctIndex: 1,
              explanation:
                "Ohne `-p` gibt `mkdir` einen Fehler aus, wenn der Ordner bereits existiert.",
            },
            {
              level: "schwer",
              prompt: "Wie erstellst du mehrere Ordner auf einmal?",
              options: [
                "mkdir Ordner1 Ordner2 Ordner3",
                "mkdir -m Ordner1,Ordner2,Ordner3",
                "mkdir --multiple Ordner1 Ordner2",
                "Das geht nicht mit mkdir",
              ],
              correctIndex: 0,
              explanation:
                "`mkdir` kann mehrere Ordner auf einmal erstellen, wenn du sie als separate Argumente angibst.",
            },
          ],
        },

        mkdir_p: {
          title: "mkdir -p",
          description:
            "Erstellt einen Ordner inkl. aller fehlenden Zwischenordner.",
          explanation: "inkl. Zwischenordner erstellen.",
          simpleExample: "mkdir -p Projekte/2025/Notizen",
          detail: "Wenn der Pfad schon existiert, gibt es keinen Fehler.",
          complexExample:
            'mkdir -p /var/log/myapp\necho "Starte App..." >> /var/log/myapp/run.log',
          complexExampleExplanation: [
            {
              line: "mkdir -p /var/log/myapp",
              explanation:
                "Erstellt /var/log/myapp inklusive aller fehlenden Zwischenordner (/var, /var/log), -p verhindert Fehler wenn Verzeichnisse bereits existieren",
            },
            {
              line: 'echo "Starte App..." >> /var/log/myapp/run.log',
              explanation:
                'Gibt "Starte App..." aus und hängt es an run.log an (>> fügt am Ende hinzu, ohne Überschreibung)',
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `mkdir -p Projekte/2025/Notizen`?",
              options: [
                "Erstellt nur Notizen",
                "Erstellt Projekte, 2025 und Notizen (alle fehlenden Ordner)",
                "Löscht die Ordner",
                "Zeigt den Pfad an",
              ],
              correctIndex: 1,
              explanation:
                "`-p` erstellt alle fehlenden Zwischenordner im Pfad automatisch.",
            },
            {
              level: "mittel",
              prompt:
                "Was passiert mit `mkdir -p`, wenn der Ordner bereits existiert?",
              options: [
                "Fehler",
                "Kein Fehler, es wird nichts gemacht",
                "Der Ordner wird gelöscht und neu erstellt",
                "Der Ordner wird umbenannt",
              ],
              correctIndex: 1,
              explanation:
                "Mit `-p` gibt es keinen Fehler, wenn der Ordner bereits existiert – ideal für Scripts.",
            },
            {
              level: "schwer",
              prompt: "Warum ist `mkdir -p` in Scripts besonders nützlich?",
              options: [
                "Es ist schneller",
                "Es verhindert Fehler, wenn Ordner bereits existieren",
                "Es löscht alte Ordner",
                "Es zeigt mehr Informationen",
              ],
              correctIndex: 1,
              explanation:
                "`mkdir -p` ist idempotent – es kann mehrfach ausgeführt werden ohne Fehler, perfekt für Scripts.",
            },
          ],
        },

        mv: {
          title: "mv",
          description: "Verschiebt Dateien/Ordner oder benennt sie um.",
          explanation: "verschieben oder umbenennen.",
          simpleExample: "mv song.mp3 Music/\nmv oldname.txt newname.txt",
          detail:
            "Überschreibt still; mit mv -i fragt es vor dem Überschreiben.",
          complexExample: "mkdir -p archive\nmv *.txt archive/",
          complexExampleExplanation: [
            {
              line: "mkdir -p archive",
              explanation:
                "Erstellt den Ordner archive (oder tut nichts, falls er bereits existiert)",
            },
            {
              line: "mv *.txt archive/",
              explanation:
                "Verschiebt alle .txt-Dateien (*.txt ist ein Wildcard-Muster) in den archive-Ordner",
            },
          ],
          additionalExamples: `
✅ <strong>1. Datei verschieben und dann prüfen wo du bist</strong><br>
<code>mv file.txt backup/</code><br>
<code>pwd</code><br>
→ Verschiebt die Datei, pwd zeigt deinen aktuellen Pfad<br><br>

✅ <strong>2. Datei umbenennen und dann den Ordner auflisten</strong><br>
<code>mv old.txt new.txt</code><br>
<code>ls</code><br>
→ Benennt die Datei um, ls zeigt dass nur new.txt existiert<br><br>

✅ <strong>3. In einen Ordner wechseln, verschieben, zurückkehren</strong><br>
<code>cd Documents</code><br>
<code>mv report.txt ../archive/</code><br>
<code>cd ..</code><br>
→ Wechselt ins Documents-Verzeichnis, verschiebt eine Datei eine Ebene nach oben, kehrt zurück<br><br>

✅ <strong>4. Mehrere Dateien verschieben und dann prüfen</strong><br>
<code>mv *.log logs/</code><br>
<code>ls logs/</code><br>
→ Verschiebt alle .log-Dateien ins logs-Verzeichnis, ls zeigt den Inhalt<br><br>

✅ <strong>5. Ordner erstellen, dann Dateien hinein verschieben</strong><br>
<code>mkdir old_files</code><br>
<code>mv file1.txt file2.txt old_files/</code><br>
<code>ls old_files/</code><br>
→ Erstellt den Ordner, verschiebt Dateien hinein, prüft den Inhalt
          `,
          additionalExamples: `
✅ <strong>1. Datei verschieben und dann prüfen wo du bist</strong><br>
<code>mv file.txt backup/</code><br>
<code>pwd</code><br>
→ Verschiebt die Datei, pwd zeigt deinen aktuellen Pfad<br><br>

✅ <strong>2. Datei umbenennen und dann den Ordner auflisten</strong><br>
<code>mv old.txt new.txt</code><br>
<code>ls</code><br>
→ Benennt die Datei um, ls zeigt dass nur new.txt existiert<br><br>

✅ <strong>3. In einen Ordner wechseln, verschieben, zurückkehren</strong><br>
<code>cd Documents</code><br>
<code>mv report.txt ../archive/</code><br>
<code>cd ..</code><br>
→ Wechselt ins Documents-Verzeichnis, verschiebt eine Datei eine Ebene nach oben, kehrt zurück<br><br>

✅ <strong>4. Mehrere Dateien verschieben und dann prüfen</strong><br>
<code>mv *.log logs/</code><br>
<code>ls logs/</code><br>
→ Verschiebt alle .log-Dateien ins logs-Verzeichnis, ls zeigt den Inhalt<br><br>

✅ <strong>5. Ordner erstellen, dann Dateien hinein verschieben</strong><br>
<code>mkdir old_files</code><br>
<code>mv file1.txt file2.txt old_files/</code><br>
<code>ls old_files/</code><br>
→ Erstellt den Ordner, verschiebt Dateien hinein, prüft den Inhalt
          `,
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `mv datei.txt Ordner/`?",
              options: [
                "Kopiert die Datei",
                "Verschiebt die Datei in den Ordner",
                "Löscht die Datei",
                "Zeigt die Datei an",
              ],
              correctIndex: 1,
              explanation: "`mv` verschiebt Dateien von einem Ort zum anderen.",
            },
            {
              level: "mittel",
              prompt: "Was macht `mv alt.txt neu.txt`?",
              options: [
                "Kopiert alt.txt zu neu.txt",
                "Benennt alt.txt in neu.txt um",
                "Löscht beide Dateien",
                "Zeigt beide Dateien an",
              ],
              correctIndex: 1,
              explanation:
                "Wenn das Ziel keine existierende Datei/Ordner ist, benennt `mv` die Datei um.",
            },
            {
              level: "schwer",
              prompt:
                "Wie verhinderst du, dass `mv` eine existierende Datei überschreibt?",
              options: [
                "mv -n datei.txt ziel.txt",
                "mv -i datei.txt ziel.txt",
                "mv --safe datei.txt ziel.txt",
                "Das geht nicht",
              ],
              correctIndex: 1,
              explanation:
                "`mv -i` (interactive) fragt vor dem Überschreiben nach – sicherer für wichtige Dateien.",
            },
          ],
        },

        cp: {
          title: "cp",
          description: "Kopiert Dateien.",
          explanation: "Datei kopieren.",
          simpleExample: "cp notes.txt notes_backup.txt",
          detail:
            "Mit cp -i vor dem Überschreiben nachfragen; mit cp -u nur neuere kopieren.",
          complexExample: "cp ~/.bashrc ~/.bashrc.backup_$(date +%F)",
          complexExampleExplanation: [
            {
              line: "cp ~/.bashrc ~/.bashrc.backup_$(date +%F)",
              explanation:
                "Kopiert .bashrc aus dem Home-Verzeichnis, $(date +%F) wird durch das aktuelle Datum (YYYY-MM-DD) ersetzt, erstellt z.B. .bashrc.backup_2025-01-15",
            },
          ],
          additionalExamples: `
✅ <strong>1. Backup erstellen und dann prüfen wo du bist</strong><br>
<code>cp notes.txt notes_backup.txt</code><br>
<code>pwd</code><br>
→ Kopiert die Datei, dann zeigt pwd deinen aktuellen Pfad<br><br>

✅ <strong>2. Datei kopieren und dann den Inhalt des Ordners anzeigen</strong><br>
<code>cp datei.txt backup/</code><br>
<code>ls backup/</code><br>
→ Kopiert die Datei ins backup-Verzeichnis, ls zeigt was drin ist<br><br>

✅ <strong>3. In einen Ordner wechseln, kopieren, zurückkehren</strong><br>
<code>cd Documents</code><br>
<code>cp report.txt ../backup/</code><br>
<code>cd ..</code><br>
→ Wechselt ins Documents-Verzeichnis, kopiert eine Datei eine Ebene nach oben ins backup, kehrt zurück<br><br>

✅ <strong>4. Mehrere Dateien kopieren und dann auflisten</strong><br>
<code>cp *.txt backup/</code><br>
<code>ls -a backup/</code><br>
→ Kopiert alle .txt-Dateien ins backup-Verzeichnis, ls -a zeigt alle Dateien (inkl. versteckter)<br><br>

✅ <strong>5. Ordner erstellen, dann Datei hinein kopieren</strong><br>
<code>mkdir my_backup</code><br>
<code>cp important.txt my_backup/</code><br>
<code>ls my_backup/</code><br>
→ Erstellt zuerst den Ordner, kopiert dann die Datei hinein, prüft mit ls
          `,
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `cp datei.txt backup.txt`?",
              options: [
                "Verschiebt datei.txt",
                "Kopiert datei.txt zu backup.txt",
                "Löscht datei.txt",
                "Zeigt datei.txt an",
              ],
              correctIndex: 1,
              explanation:
                "`cp` kopiert Dateien – die Originaldatei bleibt erhalten.",
            },
            {
              level: "mittel",
              prompt: "Was macht `cp -u quelle.txt ziel.txt`?",
              options: [
                "Kopiert nur, wenn ziel.txt älter ist",
                "Kopiert nur, wenn ziel.txt neuer ist",
                "Kopiert immer",
                "Löscht ziel.txt",
              ],
              correctIndex: 0,
              explanation:
                "`-u` (update) kopiert nur, wenn die Quelldatei neuer ist als die Zieldatei.",
            },
            {
              level: "schwer",
              prompt: "Wie erstellst du ein Backup mit Datum im Dateinamen?",
              options: [
                "cp datei.txt datei.txt.backup",
                "cp datei.txt datei.txt.backup_$(date +%F)",
                "cp datei.txt datei_backup",
                "cp -d datei.txt backup/",
              ],
              correctIndex: 1,
              explanation:
                "Mit `$(date +%F)` wird das aktuelle Datum im Format YYYY-MM-DD eingefügt.",
            },
          ],
        },

        cp_r: {
          title: "cp -r",
          description: "Kopiert einen Ordner rekursiv mit Inhalt.",
          explanation: "Ordner rekursiv kopieren.",
          simpleExample: "cp -r ProjektA ProjektA_backup",
          detail:
            "-r oder besser -R ist für Verzeichnisse notwendig – sonst Fehler.",
          complexExample: "cp -r /var/www/site /var/backups/site_$(date +%F)",
          complexExampleExplanation: [
            {
              line: "cp -r /var/www/site /var/backups/site_$(date +%F)",
              explanation:
                "Kopiert rekursiv (-r) den gesamten site-Ordner inklusive aller Unterordner und Dateien, $(date +%F) fügt das Datum zum Zielnamen hinzu für ein datiertes Backup",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `cp -r Ordner1 Ordner2`?",
              options: [
                "Kopiert nur den Ordner ohne Inhalt",
                "Kopiert den Ordner rekursiv mit allen Inhalten",
                "Verschiebt den Ordner",
                "Löscht den Ordner",
              ],
              correctIndex: 1,
              explanation:
                "`-r` (recursive) kopiert den gesamten Ordner inklusive aller Unterordner und Dateien.",
            },
            {
              level: "mittel",
              prompt:
                "Was passiert, wenn du `cp Ordner1 Ordner2` ohne `-r` ausführst?",
              options: [
                "Es funktioniert normal",
                "Fehler: Ordner können nicht kopiert werden",
                "Es kopiert nur die Dateien im Ordner",
                "Es erstellt einen leeren Ordner",
              ],
              correctIndex: 1,
              explanation:
                "Ohne `-r` gibt `cp` einen Fehler aus, da Ordner nicht direkt kopiert werden können.",
            },
            {
              level: "schwer",
              prompt: "Was ist der Unterschied zwischen `cp -r` und `cp -R`?",
              options: [
                "Kein Unterschied",
                "-R ist besser für Links",
                "-r funktioniert nicht",
                "-R ist schneller",
              ],
              correctIndex: 0,
              explanation:
                "In den meisten Systemen sind `-r` und `-R` gleichwertig, beide kopieren rekursiv.",
            },
          ],
        },

        rm: {
          title: "rm",
          description: "Löscht Dateien.",
          explanation: "Datei löschen.",
          simpleExample: "rm temp.txt",
          detail: "Kein Papierkorb! Weg ist weg. Nutze rm -i für Sicherheit.",
          complexExample: "rm -i *.tmp",
          complexExampleExplanation: [
            {
              line: "rm -i *.tmp",
              explanation:
                "Löscht alle .tmp-Dateien, -i (interactive) fragt vor jedem Löschen nach Bestätigung (sicherer als ohne -i)",
            },
          ],
          additionalExamples: `
✅ <strong>1. Datei löschen und dann prüfen ob sie weg ist</strong><br>
<code>rm temp.txt</code><br>
<code>ls</code><br>
→ Löscht die Datei, ls zeigt dass sie nicht mehr existiert<br><br>

✅ <strong>2. Dateien auflisten, dann bestimmte löschen</strong><br>
<code>ls *.log</code><br>
<code>rm *.log</code><br>
→ Zeigt alle .log-Dateien, rm löscht sie alle<br><br>

✅ <strong>3. In einen Ordner wechseln, löschen, zurückkehren</strong><br>
<code>cd temp/</code><br>
<code>rm old_file.txt</code><br>
<code>cd ..</code><br>
→ Wechselt ins temp-Verzeichnis, löscht eine Datei, kehrt zurück<br><br>

✅ <strong>4. Datei kopieren, dann Original löschen</strong><br>
<code>cp important.txt backup/</code><br>
<code>rm important.txt</code><br>
→ Kopiert die Datei ins Backup, löscht dann das Original<br><br>

✅ <strong>5. Liste speichern, dann Dateien löschen</strong><br>
<code>ls > dateien_liste.txt</code><br>
<code>rm temp*.txt</code><br>
→ Speichert die Liste, löscht dann alle temp*.txt Dateien
          `,
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `rm datei.txt`?",
              options: [
                "Verschiebt datei.txt in den Papierkorb",
                "Löscht datei.txt endgültig",
                "Kopiert datei.txt",
                "Zeigt datei.txt an",
              ],
              correctIndex: 1,
              explanation:
                "`rm` löscht Dateien endgültig – es gibt keinen Papierkorb in der Shell.",
            },
            {
              level: "mittel",
              prompt:
                "Wie kannst du sicherstellen, dass `rm` vor dem Löschen fragt?",
              options: [
                "rm -f datei.txt",
                "rm -i datei.txt",
                "rm -r datei.txt",
                "rm --ask datei.txt",
              ],
              correctIndex: 1,
              explanation:
                "`rm -i` (interactive) fragt vor jedem Löschen nach – viel sicherer.",
            },
            {
              level: "schwer",
              prompt: "Was ist der Unterschied zwischen `rm -f` und `rm -i`?",
              options: [
                "Beide fragen nach",
                "-f erzwingt Löschen ohne Nachfrage, -i fragt nach",
                "-f fragt nach, -i nicht",
                "Kein Unterschied",
              ],
              correctIndex: 1,
              explanation:
                "`-f` (force) erzwingt das Löschen ohne Nachfrage, `-i` (interactive) fragt nach – genau das Gegenteil.",
            },
          ],
        },

        rm_r: {
          title: "rm -r",
          description: "Löscht Ordner rekursiv inkl. aller Inhalte.",
          explanation: "Ordner rekursiv löschen.",
          simpleExample: "rm -r Backup/",
          detail:
            "rm -rf (force) ist extrem gefährlich – löscht ohne Nachfragen, auch schreibgeschütztes.",
          complexExample: "rm -r build/ dist/ .cache/ 2>/dev/null",
          complexExampleExplanation: [
            {
              line: "rm -r build/ dist/ .cache/ 2>/dev/null",
              explanation:
                "Löscht rekursiv (-r) drei Ordner, 2>/dev/null leitet Fehler (stderr) ins Nichts um, sodass Fehlermeldungen (z.B. wenn Ordner nicht existieren) nicht angezeigt werden",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `rm -r Ordner/`?",
              options: [
                "Löscht nur den leeren Ordner",
                "Löscht den Ordner rekursiv mit allen Inhalten",
                "Kopiert den Ordner",
                "Zeigt den Ordner an",
              ],
              correctIndex: 1,
              explanation:
                "`-r` (recursive) löscht den gesamten Ordner inklusive aller Unterordner und Dateien.",
            },
            {
              level: "mittel",
              prompt: "Warum ist `rm -rf` besonders gefährlich?",
              options: [
                "Es ist langsam",
                "Es löscht ohne Nachfrage, auch schreibgeschützte Dateien",
                "Es kopiert Dateien",
                "Es zeigt zu viele Informationen",
              ],
              correctIndex: 1,
              explanation:
                "`-rf` kombiniert rekursiv + force – löscht alles ohne Nachfrage, auch schreibgeschützte Dateien. Sehr gefährlich!",
            },
            {
              level: "schwer",
              prompt: "Was macht `rm -r build/ dist/ .cache/ 2>/dev/null`?",
              options: [
                "Löscht die Ordner und zeigt Fehler",
                "Löscht die Ordner und versteckt Fehler (wenn Ordner nicht existieren)",
                "Kopiert die Ordner",
                "Zeigt die Ordner an",
              ],
              correctIndex: 1,
              explanation:
                "`2>/dev/null` leitet Fehler (stderr) um, sodass Fehlermeldungen nicht angezeigt werden, wenn Ordner nicht existieren.",
            },
          ],
        },

        cat: {
          title: "cat",
          description: "Gibt den Inhalt einer Datei auf stdout aus.",
          explanation: "Datei anzeigen.",
          simpleExample: "cat notes.txt",
          detail:
            "Mehrere Dateien werden hintereinander ausgegeben: cat a.txt b.txt.",
          complexExample: "cat header.conf main.conf footer.conf > full.conf",
          complexExampleExplanation: [
            {
              line: "cat header.conf main.conf footer.conf > full.conf",
              explanation:
                "cat liest drei Dateien nacheinander und gibt sie hintereinander aus, > leitet die kombinierte Ausgabe in full.conf um (überschreibt die Datei)",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `cat datei.txt`?",
              options: [
                "Kopiert datei.txt",
                "Zeigt den Inhalt von datei.txt an",
                "Löscht datei.txt",
                "Erstellt datei.txt",
              ],
              correctIndex: 1,
              explanation:
                "`cat` (concatenate) gibt den Inhalt einer Datei auf stdout aus.",
            },
            {
              level: "mittel",
              prompt: "Was macht `cat a.txt b.txt`?",
              options: [
                "Zeigt nur a.txt",
                "Zeigt a.txt und b.txt hintereinander",
                "Vergleicht die Dateien",
                "Löscht beide Dateien",
              ],
              correctIndex: 1,
              explanation:
                "`cat` kann mehrere Dateien verketten und gibt sie hintereinander aus.",
            },
            {
              level: "schwer",
              prompt: "Wie fügst du mehrere Config-Dateien zu einer zusammen?",
              options: [
                "cat header.conf main.conf footer.conf > full.conf",
                "cat header.conf main.conf footer.conf < full.conf",
                "cat header.conf | main.conf | footer.conf",
                "cat header.conf && main.conf && footer.conf",
              ],
              correctIndex: 0,
              explanation:
                "Mit `>` wird die Ausgabe in eine Datei umgeleitet – alle drei Dateien werden zu `full.conf` zusammengefügt.",
            },
          ],
        },

        sort: {
          title: "sort",
          description: "Sortiert Zeilen alphabetisch.",
          explanation: "alphabetisch sortieren.",
          simpleExample: "sort namen.txt",
          detail: "Mit -r wird absteigend sortiert.",
          complexExample: "sort namen.txt | uniq > namen_uniq.txt",
          complexExampleExplanation: [
            {
              line: "sort namen.txt | uniq > namen_uniq.txt",
              explanation:
                "sort sortiert die Zeilen alphabetisch, | leitet an uniq weiter (entfernt aufeinanderfolgende Duplikate), > speichert das Ergebnis in namen_uniq.txt",
            },
          ],
          additionalExamples: `
✅ <strong>1. Datei anzeigen, dann sortieren</strong><br>
<code>cat namen.txt</code><br>
<code>sort namen.txt</code><br>
→ cat zeigt den Inhalt, sort zeigt die sortierte Version<br><br>

✅ <strong>2. Nach bestimmten Zeilen suchen, dann sortieren</strong><br>
<code>grep "admin" users.txt</code><br>
<code>grep "admin" users.txt | sort</code><br>
→ grep findet alle "admin" Zeilen, sort sortiert sie alphabetisch<br><br>

✅ <strong>3. Mehrere Dateien zusammenfügen und sortieren</strong><br>
<code>cat liste1.txt liste2.txt</code><br>
<code>cat liste1.txt liste2.txt | sort</code><br>
→ cat zeigt beide Dateien zusammen, sort sortiert das kombinierte Ergebnis<br><br>

✅ <strong>4. Sortieren und nur die ersten 10 Zeilen zeigen</strong><br>
<code>sort große_liste.txt</code><br>
<code>sort große_liste.txt | head -n 10</code><br>
→ Sortiert die Liste, head zeigt nur die ersten 10 Zeilen<br><br>

✅ <strong>5. Sortieren, Duplikate entfernen, dann zählen</strong><br>
<code>sort emails.txt | uniq</code><br>
<code>sort emails.txt | uniq | wc -l</code><br>
→ Sortiert, entfernt Duplikate mit uniq, wc -l zählt die eindeutigen Zeilen
          `,
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `sort datei.txt`?",
              options: [
                "Zeigt datei.txt an",
                "Sortiert die Zeilen alphabetisch",
                "Löscht datei.txt",
                "Kopiert datei.txt",
              ],
              correctIndex: 1,
              explanation: "`sort` sortiert Zeilen alphabetisch (aufsteigend).",
            },
            {
              level: "mittel",
              prompt: "Wie sortierst du absteigend (rückwärts)?",
              options: [
                "sort -d datei.txt",
                "sort -r datei.txt",
                "sort -n datei.txt",
                "sort --reverse datei.txt",
              ],
              correctIndex: 1,
              explanation:
                "`sort -r` (reverse) sortiert absteigend – von Z nach A.",
            },
            {
              level: "schwer",
              prompt: "Was macht `sort namen.txt | uniq > namen_uniq.txt`?",
              options: [
                "Sortiert und zeigt Duplikate",
                "Sortiert, entfernt Duplikate und speichert in namen_uniq.txt",
                "Löscht namen.txt",
                "Kopiert namen.txt",
              ],
              correctIndex: 1,
              explanation:
                "Zuerst sortieren (damit Duplikate zusammen sind), dann `uniq` entfernt Duplikate, `>` speichert das Ergebnis.",
            },
          ],
        },

        sort_n: {
          title: "sort -n",
          description:
            "Sortiert Zeilen numerisch (Zahlen korrekt, nicht als Text).",
          explanation: "numerisch sortieren.",
          simpleExample: "sort -n zahlen.txt",
          detail:
            "Mit -n wird z. B. 2 vor 10 einsortiert (bei normalem sort käme 10 vor 2).",
          complexExample: "sort -n zahlen.txt | tail -n 5",
          complexExampleExplanation: [
            {
              line: "sort -n zahlen.txt | tail -n 5",
              explanation:
                "sort -n sortiert numerisch (nicht alphabetisch, damit 2 vor 10 kommt), | leitet an tail -n 5 weiter, das die letzten 5 Zeilen zeigt (also die 5 größten Zahlen)",
            },
          ],
          additionalExamples: `
✅ <strong>1. Datei anzeigen, dann numerisch sortieren</strong><br>
<code>cat zahlen.txt</code><br>
<code>sort -n zahlen.txt</code><br>
→ cat zeigt den Inhalt, sort -n sortiert Zahlen korrekt (2 vor 10)<br><br>

✅ <strong>2. Normal sortieren vs. numerisch sortieren</strong><br>
<code>sort zahlen.txt</code><br>
<code>sort -n zahlen.txt</code><br>
→ sort sortiert als Text (10 vor 2), sort -n sortiert numerisch (2 vor 10)<br><br>

✅ <strong>3. Sortieren und dann die größten Zahlen zeigen</strong><br>
<code>sort -n zahlen.txt</code><br>
<code>sort -n zahlen.txt | tail -n 5</code><br>
→ Sortiert numerisch, tail zeigt die letzten 5 (die größten)<br><br>

✅ <strong>4. Sortieren, Duplikate entfernen, dann zählen</strong><br>
<code>sort -n zahlen.txt | uniq</code><br>
<code>sort -n zahlen.txt | uniq | wc -l</code><br>
→ Sortiert numerisch, entfernt Duplikate, wc -l zählt eindeutige Zahlen<br><br>

✅ <strong>5. Mehrere Dateien kombinieren und numerisch sortieren</strong><br>
<code>cat liste1.txt liste2.txt | sort -n</code><br>
→ Kombiniert beide Dateien, sort -n sortiert alle Zahlen korrekt
          `,
          questions: [
            {
              level: "leicht",
              prompt: "Was ist der Unterschied zwischen `sort` und `sort -n`?",
              options: [
                "Kein Unterschied",
                "sort sortiert alphabetisch, sort -n numerisch",
                "sort -n ist schneller",
                "sort -n funktioniert nicht",
              ],
              correctIndex: 1,
              explanation:
                "`sort` sortiert als Text (10 kommt vor 2), `sort -n` sortiert numerisch (2 kommt vor 10).",
            },
            {
              level: "mittel",
              prompt: "Wie sortierst du eine Datei mit Zahlen numerisch?",
              options: [
                "sort zahlen.txt",
                "sort -n zahlen.txt",
                "sort --number zahlen.txt",
                "sort -r zahlen.txt",
              ],
              correctIndex: 1,
              explanation:
                "`sort -n` sortiert numerisch – wichtig für Zahlen, damit 2 vor 10 kommt.",
            },
            {
              level: "schwer",
              prompt: "Was macht `sort -n zahlen.txt | tail -n 5`?",
              options: [
                "Zeigt die ersten 5 Zahlen",
                "Zeigt die 5 größten Zahlen",
                "Löscht die letzten 5 Zeilen",
                "Kopiert die Datei",
              ],
              correctIndex: 1,
              explanation:
                "Sortiert numerisch (kleinste zuerst), dann `tail -n 5` zeigt die letzten 5 Zeilen = die 5 größten Zahlen.",
            },
          ],
        },

        uniq: {
          title: "uniq",
          description: "Entfernt doppelte aufeinanderfolgende Zeilen.",
          explanation: "entfernt aufeinanderfolgende Duplikate.",
          simpleExample: "uniq liste.txt",
          detail:
            "Oft mit sort kombiniert, weil nur direkt aufeinanderfolgende Duplikate erkannt werden.",
          complexExample: "sort namen.txt | uniq -c | sort -n",
          complexExampleExplanation: [
            {
              line: "sort namen.txt | uniq -c | sort -n",
              explanation:
                "sort sortiert alphabetisch, | leitet an uniq -c weiter (zählt Vorkommen jedes Namens), | leitet an sort -n weiter (sortiert nach Anzahl, kleinste zuerst)",
            },
          ],
          additionalExamples: `
✅ <strong>1. Datei anzeigen, dann Duplikate entfernen</strong><br>
<code>cat liste.txt</code><br>
<code>uniq liste.txt</code><br>
→ cat zeigt den Inhalt, uniq entfernt aufeinanderfolgende Duplikate<br><br>

✅ <strong>2. Erst sortieren, dann Duplikate entfernen</strong><br>
<code>sort namen.txt</code><br>
<code>sort namen.txt | uniq</code><br>
→ Sortiert die Namen, uniq entfernt dann alle Duplikate (weil sie zusammen sind)<br><br>

✅ <strong>3. Mehrere Dateien kombinieren, sortieren, Duplikate entfernen</strong><br>
<code>cat file1.txt file2.txt | sort</code><br>
<code>cat file1.txt file2.txt | sort | uniq</code><br>
→ Kombiniert beide Dateien, sort sortiert, uniq entfernt Duplikate<br><br>

✅ <strong>4. Nach etwas suchen, dann Duplikate entfernen</strong><br>
<code>grep "user" log.txt</code><br>
<code>grep "user" log.txt | sort | uniq</code><br>
→ Findet alle "user" Einträge, sort sortiert, uniq entfernt doppelte Zeilen<br><br>

✅ <strong>5. Duplikate entfernen und dann zählen</strong><br>
<code>sort emails.txt | uniq</code><br>
<code>sort emails.txt | uniq | wc -l</code><br>
→ Sortiert, entfernt Duplikate, wc -l zählt wie viele eindeutige Einträge es gibt
          `,
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `uniq datei.txt`?",
              options: [
                "Sortiert die Datei",
                "Entfernt aufeinanderfolgende doppelte Zeilen",
                "Kopiert die Datei",
                "Löscht die Datei",
              ],
              correctIndex: 1,
              explanation:
                "`uniq` entfernt nur direkt aufeinanderfolgende Duplikate – daher oft mit `sort` kombiniert.",
            },
            {
              level: "mittel",
              prompt: "Warum wird `uniq` oft mit `sort` kombiniert?",
              options: [
                "Weil sort schneller ist",
                "Weil uniq nur aufeinanderfolgende Duplikate erkennt",
                "Weil sort mehr Funktionen hat",
                "Weil uniq nicht funktioniert",
              ],
              correctIndex: 1,
              explanation:
                "`uniq` erkennt nur direkt aufeinanderfolgende Duplikate. `sort` bringt alle Duplikate zusammen, dann kann `uniq` sie entfernen.",
            },
            {
              level: "schwer",
              prompt: "Was macht `sort namen.txt | uniq -c | sort -n`?",
              options: [
                "Zeigt nur eindeutige Namen",
                "Sortiert, zählt Vorkommen jedes Namens, sortiert nach Häufigkeit",
                "Löscht Duplikate",
                "Kopiert die Datei",
              ],
              correctIndex: 1,
              explanation:
                "Sortiert → `uniq -c` zählt Vorkommen → `sort -n` sortiert nach Anzahl (häufigste zuletzt).",
            },
          ],
        },

        find_name: {
          title: "find . -name",
          description:
            "Sucht rekursiv nach Dateien/Ordnern mit Namen, der zum Muster passt.",
          explanation: "nach Name suchen.",
          simpleExample: 'find . -name "notes.txt"',
          detail: 'Muster können Wildcards enthalten: find . -name "*.log".',
          complexExample: 'find . -name "*.log" -type f -exec rm {} \\;',
          complexExampleExplanation: [
            {
              line: 'find . -name "*.log" -type f -exec rm {} \\;',
              explanation:
                "find sucht ab dem aktuellen Verzeichnis (.) nach Dateien (-type f) mit Namen *.log, -exec rm {} \\; führt rm für jede gefundene Datei aus ({} wird durch den Dateinamen ersetzt)",
            },
          ],
          additionalExamples: `
✅ <strong>1. Alle .config-Dateien im aktuellen Verzeichnis finden</strong><br>
<code>find . -name "*.config"</code><br><br>

✅ <strong>2. .config-Dateien nur im aktuellen Verzeichnis (ohne Unterordner)</strong><br>
<code>find . -maxdepth 1 -name "*.config"</code><br><br>

✅ <strong>3. Nur reguläre Dateien (keine Ordner, keine Symlinks)</strong><br>
<code>find . -type f -name "*.config"</code><br><br>

✅ <strong>4. Rekursiv und case-insensitive (.CONFIG, .Config usw.)</strong><br>
<code>find . -iname "*.config"</code><br><br>

✅ <strong>5. Alle .config-Dateien + Dateigröße anzeigen</strong><br>
<code>find . -type f -name "*.config" -exec ls -lh {} \\;</code><br><br>

✅ <strong>6. Nur die Anzahl der .config-Dateien</strong><br>
<code>find . -type f -name "*.config" | wc -l</code><br><br>

✅ <strong>7. Unterhalb eines bestimmten Verzeichnisses (z. B. /etc)</strong><br>
<code>find /etc -type f -name "*.config"</code><br><br>

🛑 <strong>Gefährliche Varianten (nur Info, nicht nutzen!)</strong><br>
<em>(Niemals löschen ohne exakt getestetes Pattern)</em><br><br>
<code>find . -name "*.config" -delete</code><br>
→ sehr riskant, löscht sofort.<br><br>

💡 <strong>Safe Default für dich:</strong><br>
Wenn du einfach alle .config-Dateien finden möchtest:<br>
<code>find . -type f -name "*.config"</code>
          `,
          questions: [
            {
              level: "leicht",
              prompt: 'Was macht `find . -name "datei.txt"`?',
              options: [
                "Erstellt datei.txt",
                "Sucht rekursiv nach datei.txt",
                "Löscht datei.txt",
                "Kopiert datei.txt",
              ],
              correctIndex: 1,
              explanation:
                "`find . -name` sucht rekursiv ab dem aktuellen Verzeichnis (.) nach Dateien/Ordnern mit diesem Namen.",
            },
            {
              level: "mittel",
              prompt: "Wie suchst du nach allen .log-Dateien?",
              options: [
                'find . -name "log"',
                'find . -name "*.log"',
                "find . -type log",
                "find . -ext log",
              ],
              correctIndex: 1,
              explanation:
                'Mit Wildcards: `find . -name "*.log"` findet alle Dateien, die mit .log enden.',
            },
            {
              level: "schwer",
              prompt:
                'Was macht `find . -name "*.log" -type f -exec rm {} \\;`?',
              options: [
                "Zeigt alle .log-Dateien",
                "Löscht alle .log-Dateien rekursiv",
                "Kopiert alle .log-Dateien",
                "Erstellt .log-Dateien",
              ],
              correctIndex: 1,
              explanation:
                "Findet alle .log-Dateien (`-type f` = nur Dateien), dann `-exec rm {} \\;` löscht jede gefundene Datei.",
            },
          ],
        },

        find_maxdepth: {
          title: "find . -maxdepth 1 -type d",
          description:
            "Listet nur Ordner im aktuellen Verzeichnis (keine Unterordner).",
          explanation: "nur Ordner im aktuellen Verzeichnis.",
          simpleExample: "find . -maxdepth 1 -type d",
          detail: 'Mit ! -name "." schließt du das aktuelle Verzeichnis aus.',
          complexExample:
            'find . -maxdepth 1 -type d ! -name "." -printf "%f\\n" > folders.txt',
          complexExampleExplanation: [
            {
              line: 'find . -maxdepth 1 -type d ! -name "." -printf "%f\\n" > folders.txt',
              explanation:
                'find sucht nur im aktuellen Verzeichnis (-maxdepth 1) nach Ordnern (-type d), ! -name "." schließt das aktuelle Verzeichnis aus, -printf "%f\\n" gibt nur den Dateinamen (ohne Pfad) aus, > speichert in folders.txt',
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `find . -maxdepth 1 -type d`?",
              options: [
                "Findet alle Ordner rekursiv",
                "Findet nur Ordner im aktuellen Verzeichnis (keine Unterordner)",
                "Findet nur Dateien",
                "Löscht Ordner",
              ],
              correctIndex: 1,
              explanation:
                "`-maxdepth 1` begrenzt die Suche auf das aktuelle Verzeichnis, `-type d` sucht nur nach Ordnern.",
            },
            {
              level: "mittel",
              prompt:
                "Wie schließt du das aktuelle Verzeichnis (.) aus der Suche aus?",
              options: [
                'find . -maxdepth 1 -type d -name "."',
                'find . -maxdepth 1 -type d ! -name "."',
                "find . -maxdepth 0 -type d",
                "Das geht nicht",
              ],
              correctIndex: 1,
              explanation:
                'Mit `! -name "."` (NOT name) schließt du das aktuelle Verzeichnis aus.',
            },
            {
              level: "schwer",
              prompt:
                'Was macht `find . -maxdepth 1 -type d ! -name "." -printf "%f\\n" > folders.txt`?',
              options: [
                "Zeigt alle Ordner",
                "Speichert nur die Ordnernamen (ohne Pfad) in folders.txt",
                "Löscht alle Ordner",
                "Kopiert alle Ordner",
              ],
              correctIndex: 1,
              explanation:
                'Findet Ordner, schließt . aus, `-printf "%f\\n"` gibt nur den Dateinamen (ohne Pfad) aus, `>` speichert in folders.txt.',
            },
          ],
        },

        ls_R: {
          title: "ls -R",
          description:
            "Listet den gesamten Verzeichnisbaum rekursiv (alle Ordner und Dateien darunter).",
          explanation:
            "Listet den gesamten Verzeichnisbaum rekursiv (alle Ordner und Dateien darunter).",
          simpleExample: "ls -R",
          detail:
            "Ohne Filter sehr unübersichtlich → wird oft mit grep kombiniert.",
          complexExample: 'ls -R | grep ":$"',
          complexExampleExplanation: [
            {
              line: 'ls -R | grep ":$"',
              explanation:
                'ls -R listet rekursiv alle Dateien und Ordner, | leitet an grep weiter, ":$" filtert nur Zeilen, die mit einem Doppelpunkt enden (Ordner werden von ls -R mit : am Ende angezeigt)',
            },
          ],
          additionalExamples: `
✅ <strong>1. Normale Liste vs. rekursive Liste</strong><br>
<code>ls</code><br>
<code>ls -R</code><br>
→ ls zeigt nur das aktuelle Verzeichnis, ls -R zeigt alles rekursiv<br><br>

✅ <strong>2. Rekursive Liste speichern und dann anzeigen</strong><br>
<code>ls -R > alle_struktur.txt</code><br>
<code>cat alle_struktur.txt</code><br>
→ Speichert die gesamte Struktur in eine Datei, cat zeigt den Inhalt<br><br>

✅ <strong>3. Nach bestimmten Dateien suchen in der rekursiven Liste</strong><br>
<code>ls -R</code><br>
<code>ls -R | grep ".txt$"</code><br>
→ Zeigt alles rekursiv, grep filtert nur .txt-Dateien<br><br>

✅ <strong>4. Nur Ordner aus der rekursiven Liste zeigen</strong><br>
<code>ls -R</code><br>
<code>ls -R | grep ":$"</code><br>
→ Zeigt alles rekursiv, grep filtert nur Ordner (endet mit :)<br><br>

✅ <strong>5. Rekursive Liste sortieren und dann begrenzen</strong><br>
<code>ls -R | sort</code><br>
<code>ls -R | sort | head -n 20</code><br>
→ Sortiert die rekursive Liste alphabetisch, head zeigt nur die ersten 20 Einträge
          `,
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `ls -R`?",
              options: [
                "Listet nur das aktuelle Verzeichnis",
                "Listet den gesamten Verzeichnisbaum rekursiv",
                "Löscht alle Dateien",
                "Kopiert alle Dateien",
              ],
              correctIndex: 1,
              explanation:
                "`-R` (recursive) listet alle Dateien und Ordner rekursiv durch alle Unterordner.",
            },
            {
              level: "mittel",
              prompt: "Warum wird `ls -R` oft mit `grep` kombiniert?",
              options: [
                "Weil es schneller ist",
                "Weil die Ausgabe ohne Filter sehr unübersichtlich ist",
                "Weil grep mehr Funktionen hat",
                "Weil ls -R nicht funktioniert",
              ],
              correctIndex: 1,
              explanation:
                "Die rekursive Ausgabe kann sehr lang sein – `grep` filtert nach bestimmten Mustern.",
            },
            {
              level: "schwer",
              prompt: "Wie zeigst du nur Ordner im gesamten Verzeichnisbaum?",
              options: [
                "ls -R | grep files",
                'ls -R | grep ":$"',
                'ls -R | grep "^d"',
                "ls -R | sort",
              ],
              correctIndex: 1,
              explanation:
                '`ls -R` zeigt Ordner mit `:` am Ende an – `grep ":$"` filtert nur diese Zeilen.',
            },
          ],
        },

        ls_aR: {
          title: "ls -aR",
          description:
            "Rekursives Auflisten aller Dateien UND versteckter Dateien/Ordner.",
          explanation:
            "Rekursives Auflisten aller Dateien UND versteckter Dateien/Ordner.",
          simpleExample: "ls -aR",
          detail: "Zeigt ., .., .git, .config, usw. in jedem Unterordner.",
          complexExample: 'ls -aR ~ | grep "^\\." | wc -l',
          complexExampleExplanation: [
            {
              line: 'ls -aR ~ | grep "^\\." | wc -l',
              explanation:
                "ls -aR listet rekursiv alle Dateien im Home-Verzeichnis (inkl. versteckter), | leitet an grep weiter (filtert nur Zeilen die mit . beginnen), | leitet an wc -l weiter (zählt die Anzahl der Zeilen/Dateien)",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Was zeigt `ls -aR` zusätzlich zu `ls -R`?",
              options: [
                "Nur größere Dateien",
                "Versteckte Dateien und Ordner (beginnen mit .)",
                "Nur ausführbare Dateien",
                "Nur Ordner",
              ],
              correctIndex: 1,
              explanation:
                "`-a` zeigt versteckte Dateien, `-R` rekursiv – kombiniert: alle versteckten Dateien in allen Unterordnern.",
            },
            {
              level: "mittel",
              prompt: "Was zeigt `ls -aR` in jedem Unterordner?",
              options: [
                "Nur .",
                "Nur ..",
                "., .., .git, .config, usw.",
                "Nur Dateien",
              ],
              correctIndex: 2,
              explanation:
                "`-aR` zeigt in jedem Unterordner auch versteckte Einträge wie `.`, `..`, `.git`, `.config` etc.",
            },
            {
              level: "schwer",
              prompt:
                "Wie zählst du alle versteckten Dateien im Home-Verzeichnis?",
              options: [
                "ls -aR ~ | wc -l",
                'ls -aR ~ | grep "^\\." | wc -l',
                'ls -R ~ | grep "^\\."',
                'find ~ -name ".*"',
              ],
              correctIndex: 1,
              explanation:
                '`ls -aR ~` listet alles rekursiv, `grep "^\\."` filtert nur versteckte Dateien (beginnen mit .), `wc -l` zählt.',
            },
          ],
        },

        tree: {
          title: "tree",
          description: "Zeigt Verzeichnisstruktur in Baumform.",
          explanation: "Zeigt Verzeichnisstruktur in Baumform.",
          simpleExample: "tree",
          detail: "Wird oft manuell installiert (sudo apt install tree).",
          complexExample: "tree -d ~/Projects",
          complexExampleExplanation: [
            {
              line: "tree -d ~/Projects",
              explanation:
                "Zeigt die Verzeichnisstruktur von ~/Projects in Baumform, -d zeigt nur Ordner (directories), keine Dateien",
            },
          ],
          additionalExamples: `
✅ <strong>1. Normale Liste vs. Baumstruktur</strong><br>
<code>ls</code><br>
<code>tree</code><br>
→ ls zeigt flache Liste, tree zeigt hierarchische Struktur<br><br>

✅ <strong>2. Baumstruktur speichern und dann anzeigen</strong><br>
<code>tree > struktur.txt</code><br>
<code>cat struktur.txt</code><br>
→ Speichert die Baumstruktur in eine Datei, cat zeigt den Inhalt<br><br>

✅ <strong>3. In einen Ordner wechseln und Baumstruktur zeigen</strong><br>
<code>cd projects</code><br>
<code>tree</code><br>
→ Wechselt ins projects-Verzeichnis, zeigt die Struktur dort<br><br>

✅ <strong>4. Baumstruktur begrenzen und dann speichern</strong><br>
<code>tree -L 2</code><br>
<code>tree -L 2 > struktur_2_ebenen.txt</code><br>
→ Zeigt nur 2 Ebenen, speichert das Ergebnis<br><br>

✅ <strong>5. Baumstruktur anzeigen und dann nach etwas suchen</strong><br>
<code>tree</code><br>
<code>tree | grep "config"</code><br>
→ Zeigt die Struktur, grep filtert nur Zeilen mit "config"
          `,
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `tree`?",
              options: [
                "Löscht Bäume",
                "Zeigt Verzeichnisstruktur in Baumform",
                "Kopiert Verzeichnisse",
                "Sortiert Dateien",
              ],
              correctIndex: 1,
              explanation:
                "`tree` zeigt die Verzeichnisstruktur als visuellen Baum – sehr übersichtlich.",
            },
            {
              level: "mittel",
              prompt: "Was musst du tun, wenn `tree` nicht verfügbar ist?",
              options: [
                "Nichts, es ist immer installiert",
                "Manuell installieren: sudo apt install tree",
                "Es gibt keinen Ersatz",
                "Es funktioniert automatisch",
              ],
              correctIndex: 1,
              explanation:
                "`tree` ist nicht standardmäßig installiert – muss mit `sudo apt install tree` (oder ähnlich) installiert werden.",
            },
            {
              level: "schwer",
              prompt: "Wie zeigst du nur Ordner in der Baumstruktur?",
              options: ["tree -f", "tree -d", "tree -a", "tree -l"],
              correctIndex: 1,
              explanation:
                "`tree -d` (directory-only) zeigt nur Ordner, keine Dateien – perfekt für Strukturübersicht.",
            },
          ],
        },

        tree_d: {
          title: "tree -d",
          description: "Zeigt nur Ordner (directory-only mode).",
          explanation: "Zeigt nur Ordner (directory-only mode).",
          simpleExample: "tree -d",
          detail: "Perfekt, um reinen Ordneraufbau zu sehen.",
          complexExample: "tree -d -L 2",
          complexExampleExplanation: [
            {
              line: "tree -d -L 2",
              explanation:
                "Zeigt nur Ordner (-d) in Baumform, -L 2 begrenzt die Tiefe auf 2 Ebenen (nur direkt sichtbare Ordner und deren Unterordner)",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `tree -d`?",
              options: [
                "Zeigt nur Dateien",
                "Zeigt nur Ordner",
                "Zeigt alles",
                "Löscht Ordner",
              ],
              correctIndex: 1,
              explanation:
                "`-d` steht für 'directory-only' – zeigt nur Ordner, keine Dateien.",
            },
            {
              level: "mittel",
              prompt: "Wann ist `tree -d` besonders nützlich?",
              options: [
                "Wenn man Dateien sehen will",
                "Wenn man nur den reinen Ordneraufbau sehen will",
                "Wenn man Dateien löschen will",
                "Wenn man Dateien kopieren will",
              ],
              correctIndex: 1,
              explanation:
                "`tree -d` ist perfekt, um die reine Verzeichnisstruktur ohne Dateien zu überblicken.",
            },
            {
              level: "schwer",
              prompt: "Wie begrenzt du die Tiefe auf 2 Ebenen?",
              options: [
                "tree -d -L 2",
                "tree -d -d 2",
                "tree -d -max 2",
                "tree -d 2",
              ],
              correctIndex: 0,
              explanation:
                "`-L 2` begrenzt die Tiefe auf 2 Ebenen – kombiniert mit `-d` nur Ordner bis Ebene 2.",
            },
          ],
        },

        tree_L: {
          title: "tree -L",
          description: "Begrenzt die Tiefe der rekursiven Baumdarstellung.",
          explanation: "Begrenzt die Tiefe der rekursiven Baumdarstellung.",
          simpleExample: "tree -L 1",
          detail: "Hilft, tiefe Strukturen übersichtlich zu halten.",
          complexExample: "sudo tree -L 3 /",
          complexExampleExplanation: [
            {
              line: "sudo tree -L 3 /",
              explanation:
                "sudo gibt Root-Rechte, tree zeigt die Verzeichnisstruktur des Wurzelverzeichnisses (/), -L 3 begrenzt die Tiefe auf 3 Ebenen (benötigt sudo für Systemverzeichnisse)",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `tree -L 1`?",
              options: [
                "Zeigt nur die erste Ebene",
                "Zeigt alle Ebenen",
                "Löscht die erste Ebene",
                "Kopiert die erste Ebene",
              ],
              correctIndex: 0,
              explanation:
                "`-L 1` begrenzt die Ausgabe auf die erste Ebene – nur direkt sichtbare Ordner/Dateien.",
            },
            {
              level: "mittel",
              prompt: "Warum ist `tree -L` nützlich?",
              options: [
                "Weil es schneller ist",
                "Weil es tiefe Strukturen übersichtlich hält",
                "Weil es mehr zeigt",
                "Weil es Dateien löscht",
              ],
              correctIndex: 1,
              explanation:
                "Bei sehr tiefen Verzeichnisstrukturen hilft `-L`, die Ausgabe übersichtlich zu begrenzen.",
            },
            {
              level: "schwer",
              prompt: "Wie zeigst du die obersten drei Ebenen des Systems?",
              options: [
                "tree -L 3 /",
                "tree -d 3 /",
                "tree -a 3 /",
                "tree 3 /",
              ],
              correctIndex: 0,
              explanation:
                "`sudo tree -L 3 /` zeigt die obersten 3 Ebenen des Wurzelverzeichnisses (benötigt sudo für Systemverzeichnisse).",
            },
          ],
        },

        echo: {
          title: "echo",
          description: "Gibt Text im Terminal aus.",
          explanation: "Gibt Text im Terminal aus.",
          simpleExample: 'echo "Hallo Welt"',
          detail: "Mit >> nützlich zum Schreiben in Logdateien.",
          complexExample: 'echo "Starte Backup am $(date)" >> backup.log',
          complexExampleExplanation: [
            {
              line: 'echo "Starte Backup am $(date)" >> backup.log',
              explanation:
                "echo gibt Text aus, $(date) wird durch das aktuelle Datum und die Uhrzeit ersetzt, >> hängt den Text an backup.log an (ohne Überschreibung)",
            },
          ],
          additionalExamples: `
✅ <strong>1. Text ausgeben und dann in eine Datei schreiben</strong><br>
<code>echo "Hallo"</code><br>
<code>echo "Hallo" > greeting.txt</code><br>
→ Erst zeigt echo den Text, dann schreibt > ihn in eine Datei<br><br>

✅ <strong>2. Text an eine Datei anhängen (statt überschreiben)</strong><br>
<code>echo "Zeile 1" > log.txt</code><br>
<code>echo "Zeile 2" >> log.txt</code><br>
→ > überschreibt, >> hängt an (beide Zeilen bleiben erhalten)<br><br>

✅ <strong>3. Mehrere Zeilen schreiben und dann anzeigen</strong><br>
<code>echo "Start" > status.txt</code><br>
<code>echo "Läuft" >> status.txt</code><br>
<code>cat status.txt</code><br>
→ Schreibt zwei Zeilen, cat zeigt den Inhalt<br><br>

✅ <strong>4. Text in Datei schreiben und dann den Ordner auflisten</strong><br>
<code>echo "Test" > test.txt</code><br>
<code>ls</code><br>
→ Erstellt eine Datei mit echo, ls zeigt dass sie existiert<br><br>

✅ <strong>5. Fehlerausgabe umleiten (statt normale Ausgabe)</strong><br>
<code>echo "Fehler!"</code><br>
<code>echo "Fehler!" > output.txt</code><br>
<code>echo "Fehler!" 2> error.txt</code><br>
→ > schreibt normale Ausgabe, 2> schreibt Fehlerausgabe
          `,
          questions: [
            {
              level: "leicht",
              prompt: 'Was macht `echo "Hallo"`?',
              options: [
                "Löscht Hallo",
                "Gibt 'Hallo' im Terminal aus",
                "Kopiert Hallo",
                "Erstellt eine Datei Hallo",
              ],
              correctIndex: 1,
              explanation:
                "`echo` gibt Text auf stdout aus – im Terminal sichtbar.",
            },
            {
              level: "mittel",
              prompt: "Wie schreibst du Text in eine Logdatei?",
              options: [
                'echo "Text" > log.txt',
                'echo "Text" >> log.txt',
                'echo "Text" | log.txt',
                'echo "Text" log.txt',
              ],
              correctIndex: 1,
              explanation:
                "Mit `>>` wird Text an die Datei angehängt – ideal für Logdateien, die wachsen sollen.",
            },
            {
              level: "schwer",
              prompt:
                'Was macht `echo "Starte Backup am $(date)" >> backup.log`?',
              options: [
                "Zeigt nur das Datum",
                "Schreibt 'Starte Backup am [aktuelles Datum]' in backup.log",
                "Löscht backup.log",
                "Kopiert backup.log",
              ],
              correctIndex: 1,
              explanation:
                "`$(date)` wird durch das aktuelle Datum ersetzt, dann wird der gesamte Text an backup.log angehängt.",
            },
          ],
        },

        redirect_overwrite: {
          title: ">",
          description: "Leitet die Ausgabe in eine Datei um (überschreibt).",
          explanation: "Leitet die Ausgabe in eine Datei um (überschreibt).",
          simpleExample: 'echo "Hallo" > info.txt',
          detail: "Achtung: überschreibt komplett ohne Warnung.",
          complexExample: "ls /etc > etc_contents.txt",
          complexExampleExplanation: [
            {
              line: "ls /etc > etc_contents.txt",
              explanation:
                "ls listet den Inhalt von /etc auf, > leitet die Ausgabe in etc_contents.txt um (überschreibt die Datei komplett, falls sie existiert)",
            },
          ],
          additionalExamples: `
✅ <strong>1. Text ausgeben vs. in Datei speichern</strong><br>
<code>echo "Hallo"</code><br>
<code>echo "Hallo" > greeting.txt</code><br>
→ Erst zeigt echo den Text, dann speichert > ihn in eine Datei<br><br>

✅ <strong>2. Dateiliste speichern und dann anzeigen</strong><br>
<code>ls</code><br>
<code>ls > dateien.txt</code><br>
<code>cat dateien.txt</code><br>
→ ls zeigt Dateien, > speichert die Liste, cat zeigt den Inhalt<br><br>

✅ <strong>3. Dateiinhalt kopieren in neue Datei</strong><br>
<code>cat original.txt</code><br>
<code>cat original.txt > backup.txt</code><br>
→ Zeigt den Inhalt, dann speichert > ihn in backup.txt<br><br>

✅ <strong>4. Nach etwas suchen und Ergebnisse speichern</strong><br>
<code>grep "Error" log.txt</code><br>
<code>grep "Error" log.txt > fehler.txt</code><br>
→ Findet Fehler, > speichert alle Treffer in fehler.txt<br><br>

✅ <strong>5. Mehrere Dateien kombinieren und speichern</strong><br>
<code>cat file1.txt file2.txt</code><br>
<code>cat file1.txt file2.txt > kombiniert.txt</code><br>
→ Zeigt beide Dateien zusammen, > speichert das kombinierte Ergebnis
          `,
          questions: [
            {
              level: "leicht",
              prompt: 'Was macht `echo "Text" > datei.txt`?',
              options: [
                "Hängt Text an datei.txt an",
                "Überschreibt datei.txt mit Text (oder erstellt die Datei)",
                "Zeigt Text nur im Terminal",
                "Löscht datei.txt",
              ],
              correctIndex: 1,
              explanation:
                "`>` überschreibt die Datei komplett oder erstellt sie, wenn sie nicht existiert.",
            },
            {
              level: "mittel",
              prompt: "Was passiert, wenn die Datei bereits existiert?",
              options: [
                "Es wird nachgefragt",
                "Die Datei wird komplett überschrieben ohne Warnung",
                "Die Datei wird gelöscht",
                "Nichts passiert",
              ],
              correctIndex: 1,
              explanation:
                "`>` überschreibt ohne Warnung – Vorsicht! Alle bisherigen Inhalte gehen verloren.",
            },
            {
              level: "schwer",
              prompt: "Was macht `ls /etc > etc_contents.txt`?",
              options: [
                "Zeigt /etc im Terminal",
                "Speichert die Liste von /etc in etc_contents.txt",
                "Löscht /etc",
                "Kopiert /etc",
              ],
              correctIndex: 1,
              explanation:
                "Die Ausgabe von `ls /etc` wird in die Datei etc_contents.txt umgeleitet (überschreibt sie).",
            },
          ],
        },

        redirect_append: {
          title: ">>",
          description: "Hängt die Ausgabe ans Ende einer Datei an.",
          explanation: "Hängt die Ausgabe ans Ende einer Datei an.",
          simpleExample: 'echo "Neue Zeile" >> log.txt',
          detail: "Datei wird nicht gelöscht wie bei >.",
          complexExample: 'echo "$(date): Prozess gestartet" >> system.log',
          complexExampleExplanation: [
            {
              line: 'echo "$(date): Prozess gestartet" >> system.log',
              explanation:
                "echo gibt Text aus, $(date) wird durch Datum/Uhrzeit ersetzt, >> hängt den Text am Ende von system.log an (bisheriger Inhalt bleibt erhalten)",
            },
          ],
          additionalExamples: `
✅ <strong>1. Überschreiben vs. Anhängen</strong><br>
<code>echo "Zeile 1" > log.txt</code><br>
<code>echo "Zeile 2" >> log.txt</code><br>
→ > überschreibt, >> hängt an (beide Zeilen bleiben erhalten)<br><br>

✅ <strong>2. Text anhängen und dann anzeigen</strong><br>
<code>echo "Neu" >> status.txt</code><br>
<code>cat status.txt</code><br>
→ Hängt Text an die Datei, cat zeigt den gesamten Inhalt<br><br>

✅ <strong>3. Liste speichern, dann weitere Einträge anhängen</strong><br>
<code>ls > dateien.txt</code><br>
<code>ls -a >> dateien.txt</code><br>
→ Speichert normale Liste, >> hängt versteckte Dateien an<br><br>

✅ <strong>4. Mehrere Zeilen nacheinander anhängen</strong><br>
<code>echo "Start" >> log.txt</code><br>
<code>echo "Mitte" >> log.txt</code><br>
<code>echo "Ende" >> log.txt</code><br>
→ Hängt drei Zeilen nacheinander an, alle bleiben erhalten<br><br>

✅ <strong>5. Suche-Ergebnisse anhängen statt überschreiben</strong><br>
<code>grep "Error" log1.txt > fehler.txt</code><br>
<code>grep "Error" log2.txt >> fehler.txt</code><br>
→ Speichert erste Suche, >> hängt zweite Suche an (kombiniert beide)
          `,
          questions: [
            {
              level: "leicht",
              prompt: "Was ist der Unterschied zwischen `>` und `>>`?",
              options: [
                "Kein Unterschied",
                "`>` überschreibt, `>>` hängt an",
                "`>>` ist schneller",
                "`>` funktioniert nicht",
              ],
              correctIndex: 1,
              explanation:
                "`>` überschreibt die Datei komplett, `>>` hängt neuen Inhalt am Ende an.",
            },
            {
              level: "mittel",
              prompt: "Was passiert mit dem bisherigen Inhalt bei `>>`?",
              options: [
                "Er wird gelöscht",
                "Er bleibt erhalten, neuer Inhalt wird angehängt",
                "Er wird überschrieben",
                "Nichts passiert",
              ],
              correctIndex: 1,
              explanation:
                "Bei `>>` bleibt der bisherige Inhalt erhalten – neuer Inhalt wird einfach angehängt.",
            },
            {
              level: "schwer",
              prompt:
                'Was macht `echo "$(date): Prozess gestartet" >> system.log`?',
              options: [
                "Überschreibt system.log",
                "Hängt '[Datum]: Prozess gestartet' an system.log an",
                "Löscht system.log",
                "Zeigt nur das Datum",
              ],
              correctIndex: 1,
              explanation:
                "Das aktuelle Datum wird eingefügt, dann wird der Text an system.log angehängt (ideal für Logs).",
            },
          ],
        },

        redirect_stderr: {
          title: "2>",
          description: "Leitet die Fehlerausgabe (stderr) in eine Datei.",
          explanation: "Leitet die Fehlerausgabe (stderr) in eine Datei.",
          simpleExample: "command 2> fehler.txt",
          detail: "Sehr nützlich, um Fehlermeldungen zu isolieren.",
          complexExample: 'find / -name "*.conf" 2> /tmp/find_errors.log',
          complexExampleExplanation: [
            {
              line: 'find / -name "*.conf" 2> /tmp/find_errors.log',
              explanation:
                "find sucht ab dem Wurzelverzeichnis (/) rekursiv nach .conf-Dateien, 2> leitet Fehler (stderr) in /tmp/find_errors.log um (normale Ausgabe bleibt im Terminal)",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `command 2> fehler.txt`?",
              options: [
                "Leitet stdout in fehler.txt",
                "Leitet stderr (Fehlerausgabe) in fehler.txt",
                "Löscht fehler.txt",
                "Kopiert fehler.txt",
              ],
              correctIndex: 1,
              explanation:
                "`2>` leitet stderr (Stream 2 = Fehlerausgabe) in die Datei um.",
            },
            {
              level: "mittel",
              prompt: "Warum ist `2>` nützlich?",
              options: [
                "Weil es schneller ist",
                "Weil es Fehlermeldungen isoliert und von normaler Ausgabe trennt",
                "Weil es mehr zeigt",
                "Weil es Dateien löscht",
              ],
              correctIndex: 1,
              explanation:
                "Fehlermeldungen werden isoliert – normale Ausgabe bleibt im Terminal, Fehler landen in der Datei.",
            },
            {
              level: "schwer",
              prompt:
                'Was macht `find / -name "*.conf" 2> /tmp/find_errors.log`?',
              options: [
                "Zeigt alle Fehler im Terminal",
                "Sucht nach .conf-Dateien, Fehler landen in /tmp/find_errors.log",
                "Löscht alle .conf-Dateien",
                "Kopiert alle .conf-Dateien",
              ],
              correctIndex: 1,
              explanation:
                "Sucht rekursiv nach .conf-Dateien, normale Ausgabe bleibt im Terminal, Fehler (z.B. Berechtigungsfehler) landen in der Logdatei.",
            },
          ],
        },

        whoami: {
          title: "whoami",
          description: "Zeigt den aktuellen Benutzer.",
          explanation: "Zeigt den aktuellen Benutzer.",
          simpleExample: "whoami → user",
          detail: "Wird oft in Scripts verwendet, um Berechtigungen zu prüfen.",
          complexExample:
            'echo "Dieses Script läuft als: $(whoami)" >> script.log',
          complexExampleExplanation: [
            {
              line: 'echo "Dieses Script läuft als: $(whoami)" >> script.log',
              explanation:
                "echo gibt Text aus, $(whoami) wird durch den aktuellen Benutzernamen ersetzt, >> hängt den Text an script.log an (für Logging/Debugging)",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `whoami`?",
              options: [
                "Zeigt alle Benutzer",
                "Zeigt den aktuellen Benutzer",
                "Löscht Benutzer",
                "Erstellt Benutzer",
              ],
              correctIndex: 1,
              explanation:
                "`whoami` zeigt den Namen des aktuell angemeldeten Benutzers.",
            },
            {
              level: "mittel",
              prompt: "Wofür wird `whoami` oft in Scripts verwendet?",
              options: [
                "Um Dateien zu löschen",
                "Um Berechtigungen zu prüfen",
                "Um Dateien zu kopieren",
                "Um Dateien zu sortieren",
              ],
              correctIndex: 1,
              explanation:
                "Scripts prüfen oft mit `whoami`, ob sie mit den richtigen Berechtigungen laufen.",
            },
            {
              level: "schwer",
              prompt:
                'Was macht `echo "Dieses Script läuft als: $(whoami)" >> script.log`?',
              options: [
                "Zeigt nur whoami",
                "Schreibt 'Dieses Script läuft als: [Benutzername]' in script.log",
                "Löscht script.log",
                "Kopiert script.log",
              ],
              correctIndex: 1,
              explanation:
                "`$(whoami)` wird durch den Benutzernamen ersetzt, dann wird der Text in script.log geschrieben.",
            },
          ],
        },

        chmod: {
          title: "chmod",
          description: "Ändert Dateirechte (read/write/execute).",
          explanation: "Ändert Dateirechte (read/write/execute).",
          simpleExample: "chmod +x script.sh",
          detail:
            "chmod 755 wird häufig für webserver-readable Scripts genutzt.",
          complexExample: "chmod u=rwx,go=rx meinprogramm",
          complexExampleExplanation: [
            {
              line: "chmod u=rwx,go=rx meinprogramm",
              explanation:
                "Setzt Rechte mit symbolischer Notation: u (user/Besitzer) = rwx (read/write/execute), go (group/others) = rx (read/execute), sehr präzise Kontrolle über Dateirechte",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `chmod +x script.sh`?",
              options: [
                "Löscht script.sh",
                "Macht script.sh ausführbar",
                "Kopiert script.sh",
                "Zeigt script.sh an",
              ],
              correctIndex: 1,
              explanation:
                "`+x` fügt Ausführungsrechte hinzu – die Datei kann dann mit `./script.sh` ausgeführt werden.",
            },
            {
              level: "mittel",
              prompt: "Was bedeutet `chmod 755`?",
              options: [
                "Nur lesen",
                "Besitzer: rwx, Gruppe/Andere: rx (häufig für webserver-readable Scripts)",
                "Nur schreiben",
                "Keine Rechte",
              ],
              correctIndex: 1,
              explanation:
                "755 = Besitzer: read/write/execute (7), Gruppe/Andere: read/execute (5) – Standard für ausführbare Scripts.",
            },
            {
              level: "schwer",
              prompt: "Was macht `chmod u=rwx,go=rx meinprogramm`?",
              options: [
                "Setzt Rechte für alle gleich",
                "Setzt Besitzer (u): rwx, Gruppe/Andere (go): rx",
                "Löscht alle Rechte",
                "Kopiert die Datei",
              ],
              correctIndex: 1,
              explanation:
                "Symbolische Notation: u (user) = rwx, go (group/others) = rx – sehr präzise Kontrolle.",
            },
          ],
        },

        chmod_R: {
          title: "chmod -R",
          description: "Ändert Rechte rekursiv für Ordner + Unterordner.",
          explanation: "Ändert Rechte rekursiv für Ordner + Unterordner.",
          simpleExample: "chmod -R 755 public/",
          detail: "Schnell sehr gefährlich, wenn im falschen Pfad ausgeführt.",
          complexExample: "chmod -R 700 ~/.ssh",
          complexExampleExplanation: [
            {
              line: "chmod -R 700 ~/.ssh",
              explanation:
                "Ändert Rechte rekursiv (-R) für .ssh und alle Inhalte, 700 bedeutet nur Besitzer hat alle Rechte (rwx), niemand sonst - perfekt für sensible Verzeichnisse wie SSH-Keys",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `chmod -R 755 public/`?",
              options: [
                "Ändert Rechte nur für public/",
                "Ändert Rechte rekursiv für public/ und alle Unterordner/Dateien",
                "Löscht public/",
                "Kopiert public/",
              ],
              correctIndex: 1,
              explanation:
                "`-R` (recursive) wendet die Rechteänderung auf den gesamten Verzeichnisbaum an.",
            },
            {
              level: "mittel",
              prompt: "Warum ist `chmod -R` gefährlich?",
              options: [
                "Weil es langsam ist",
                "Weil es schnell sehr gefährlich ist, wenn im falschen Pfad ausgeführt",
                "Weil es nichts macht",
                "Weil es Dateien kopiert",
              ],
              correctIndex: 1,
              explanation:
                "Im falschen Pfad (z.B. `/` statt `./`) werden Rechte systemweit geändert – sehr gefährlich!",
            },
            {
              level: "schwer",
              prompt: "Was macht `chmod -R 700 ~/.ssh`?",
              options: [
                "Macht .ssh für alle lesbar",
                "Setzt .ssh und alle Inhalte auf 700 (nur Besitzer: rwx)",
                "Löscht .ssh",
                "Kopiert .ssh",
              ],
              correctIndex: 1,
              explanation:
                "700 = nur Besitzer hat alle Rechte (rwx), niemand sonst – perfekt für sensible Verzeichnisse wie .ssh.",
            },
          ],
        },

        chown: {
          title: "chown",
          description: "Ändert den Besitzer einer Datei.",
          explanation: "Ändert den Besitzer einer Datei.",
          simpleExample: "sudo chown user file.txt",
          detail:
            "Die Kombination chown user:group file ändert Besitzer + Gruppe.",
          complexExample: "sudo chown www-data:www-data -R /var/www/site",
          complexExampleExplanation: [
            {
              line: "sudo chown www-data:www-data -R /var/www/site",
              explanation:
                "sudo gibt Root-Rechte, chown ändert Besitzer und Gruppe, www-data:www-data setzt beide auf www-data, -R rekursiv für den gesamten /var/www/site Baum (Standard für Web-Server)",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `sudo chown user file.txt`?",
              options: [
                "Ändert die Rechte",
                "Ändert den Besitzer von file.txt zu 'user'",
                "Löscht file.txt",
                "Kopiert file.txt",
              ],
              correctIndex: 1,
              explanation:
                "`chown` ändert den Besitzer – benötigt meist `sudo`, da man normalerweise nicht Besitzer anderer Dateien ändern kann.",
            },
            {
              level: "mittel",
              prompt: "Wie änderst du Besitzer UND Gruppe?",
              options: [
                "chown user file",
                "chown user:group file",
                "chown user,group file",
                "chown user.group file",
              ],
              correctIndex: 1,
              explanation:
                "Mit `user:group` werden beide auf einmal geändert – z.B. `chown www-data:www-data file`.",
            },
            {
              level: "schwer",
              prompt:
                "Was macht `sudo chown www-data:www-data -R /var/www/site`?",
              options: [
                "Ändert nur die Rechte",
                "Ändert Besitzer und Gruppe rekursiv auf www-data für den gesamten /var/www/site Baum",
                "Löscht /var/www/site",
                "Kopiert /var/www/site",
              ],
              correctIndex: 1,
              explanation:
                "Rekursiv (`-R`) wird Besitzer und Gruppe auf www-data gesetzt – Standard für Web-Server-Verzeichnisse.",
            },
          ],
        },

        chgrp: {
          title: "chgrp",
          description: "Ändert nur die Gruppenzugehörigkeit einer Datei.",
          explanation: "Ändert nur die Gruppenzugehörigkeit einer Datei.",
          simpleExample: "sudo chgrp staff file.txt",
          detail: "Wird oft verwendet, wenn mehrere User Zugriff benötigen.",
          complexExample: "sudo chgrp developers -R project/",
          complexExampleExplanation: [
            {
              line: "sudo chgrp developers -R project/",
              explanation:
                "sudo gibt Root-Rechte, chgrp ändert nur die Gruppe (nicht den Besitzer), developers ist der Gruppenname, -R rekursiv für den gesamten project/ Baum (alle Entwickler in dieser Gruppe haben Zugriff)",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `sudo chgrp staff file.txt`?",
              options: [
                "Ändert den Besitzer",
                "Ändert nur die Gruppe von file.txt zu 'staff'",
                "Löscht file.txt",
                "Kopiert file.txt",
              ],
              correctIndex: 1,
              explanation:
                "`chgrp` ändert nur die Gruppe, nicht den Besitzer – nützlich für Gruppen-Zugriff.",
            },
            {
              level: "mittel",
              prompt: "Wann wird `chgrp` oft verwendet?",
              options: [
                "Wenn man Dateien löschen will",
                "Wenn mehrere User Zugriff benötigen",
                "Wenn man Dateien kopieren will",
                "Wenn man Dateien sortieren will",
              ],
              correctIndex: 1,
              explanation:
                "Wenn mehrere Benutzer Zugriff auf Dateien brauchen, setzt man sie in eine gemeinsame Gruppe.",
            },
            {
              level: "schwer",
              prompt: "Was macht `sudo chgrp developers -R project/`?",
              options: [
                "Ändert nur den Besitzer",
                "Ändert die Gruppe rekursiv auf 'developers' für den gesamten project/ Baum",
                "Löscht project/",
                "Kopiert project/",
              ],
              correctIndex: 1,
              explanation:
                "Rekursiv (`-R`) wird die Gruppe auf 'developers' gesetzt – alle Entwickler in dieser Gruppe haben dann Zugriff.",
            },
          ],
        },

        touch: {
          title: "touch",
          description:
            "Erstellt eine leere Datei oder aktualisiert das Änderungsdatum.",
          explanation:
            "Erstellt eine leere Datei oder aktualisiert das Änderungsdatum.",
          simpleExample: "touch notes.txt",
          detail: "Wird oft genutzt, um Testdateien zu erzeugen.",
          complexExample: "touch $(date +backup_%F.txt)",
          complexExampleExplanation: [
            {
              line: "touch $(date +backup_%F.txt)",
              explanation:
                "touch erstellt eine leere Datei, $(date +backup_%F.txt) wird durch das aktuelle Datum im Format backup_YYYY-MM-DD.txt ersetzt (z.B. backup_2025-01-15.txt)",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `touch notes.txt`?",
              options: [
                "Löscht notes.txt",
                "Erstellt eine leere Datei notes.txt (oder aktualisiert das Datum, wenn sie existiert)",
                "Kopiert notes.txt",
                "Zeigt notes.txt an",
              ],
              correctIndex: 1,
              explanation:
                "`touch` erstellt eine leere Datei, wenn sie nicht existiert, oder aktualisiert das Änderungsdatum.",
            },
            {
              level: "mittel",
              prompt: "Wofür wird `touch` oft verwendet?",
              options: [
                "Um Dateien zu löschen",
                "Um Testdateien zu erzeugen",
                "Um Dateien zu kopieren",
                "Um Dateien zu sortieren",
              ],
              correctIndex: 1,
              explanation:
                "Schnell eine leere Datei erstellen – ideal für Tests oder als Platzhalter.",
            },
            {
              level: "schwer",
              prompt: "Was macht `touch $(date +backup_%F.txt)`?",
              options: [
                "Erstellt eine Datei mit dem aktuellen Datum im Namen",
                "Löscht alle Backup-Dateien",
                "Kopiert alle Backup-Dateien",
                "Zeigt alle Backup-Dateien",
              ],
              correctIndex: 0,
              explanation:
                "`$(date +%F)` wird durch das Datum (YYYY-MM-DD) ersetzt, dann wird eine Datei wie `backup_2025-01-15.txt` erstellt.",
            },
          ],
        },

        head: {
          title: "head",
          description: "Zeigt die ersten Zeilen einer Datei.",
          explanation: "Zeigt die ersten Zeilen einer Datei.",
          simpleExample: "head file.txt",
          detail: "Immer 10 Zeilen, außer man nutzt -n.",
          complexExample: "head -n 3 error.log",
          complexExampleExplanation: [
            {
              line: "head -n 3 error.log",
              explanation:
                "head zeigt die ersten Zeilen einer Datei, -n 3 begrenzt die Ausgabe auf die ersten 3 Zeilen (nützlich um schnell den Anfang einer Logdatei zu sehen)",
            },
          ],
          additionalExamples: `
✅ <strong>1. Ganze Datei anzeigen vs. nur Anfang</strong><br>
<code>cat große_datei.txt</code><br>
<code>head große_datei.txt</code><br>
→ cat zeigt alles, head zeigt nur die ersten 10 Zeilen<br><br>

✅ <strong>2. Nach etwas suchen, dann nur die ersten Treffer zeigen</strong><br>
<code>grep "Error" log.txt</code><br>
<code>grep "Error" log.txt | head -n 5</code><br>
→ grep findet alle Fehler, head zeigt nur die ersten 5<br><br>

✅ <strong>3. Datei sortieren und dann nur den Anfang zeigen</strong><br>
<code>sort namen.txt</code><br>
<code>sort namen.txt | head -n 10</code><br>
→ Sortiert die Namen, head zeigt nur die ersten 10 (alphabetisch erste)<br><br>

✅ <strong>4. Erste Zeilen zeigen und dann zählen</strong><br>
<code>head -n 20 data.txt</code><br>
<code>head -n 20 data.txt | wc -l</code><br>
→ Zeigt die ersten 20 Zeilen, wc -l zählt dass es genau 20 sind<br><br>

✅ <strong>5. Mehrere Dateien zusammenfügen und nur Anfang zeigen</strong><br>
<code>cat file1.txt file2.txt</code><br>
<code>cat file1.txt file2.txt | head -n 15</code><br>
→ cat kombiniert beide Dateien, head zeigt nur die ersten 15 Zeilen
          `,
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `head file.txt`?",
              options: [
                "Zeigt die letzten Zeilen",
                "Zeigt die ersten 10 Zeilen",
                "Löscht die ersten Zeilen",
                "Kopiert die ersten Zeilen",
              ],
              correctIndex: 1,
              explanation:
                "`head` zeigt standardmäßig die ersten 10 Zeilen einer Datei.",
            },
            {
              level: "mittel",
              prompt: "Wie zeigst du nur die ersten 3 Zeilen?",
              options: [
                "head -3 file.txt",
                "head -n 3 file.txt",
                "head --lines 3 file.txt",
                "Alle oben genannten funktionieren",
              ],
              correctIndex: 3,
              explanation:
                "Alle Varianten funktionieren: `-n 3`, `-3`, `--lines 3` – alle zeigen die ersten 3 Zeilen.",
            },
            {
              level: "schwer",
              prompt: "Was macht `head -n 3 error.log`?",
              options: [
                "Zeigt die letzten 3 Zeilen",
                "Zeigt die ersten 3 Zeilen von error.log",
                "Löscht die ersten 3 Zeilen",
                "Kopiert error.log",
              ],
              correctIndex: 1,
              explanation:
                "Zeigt nur die ersten 3 Zeilen – nützlich, um schnell den Anfang einer Logdatei zu sehen.",
            },
          ],
        },

        tail: {
          title: "tail",
          description: "Zeigt die letzten Zeilen einer Datei.",
          explanation: "Zeigt die letzten Zeilen einer Datei.",
          simpleExample: "tail file.txt",
          detail: "Mit -f live-Logausgabe: extrem wichtig für Monitoring.",
          complexExample: "tail -f /var/log/syslog",
          complexExampleExplanation: [
            {
              line: "tail -f /var/log/syslog",
              explanation:
                "tail zeigt die letzten Zeilen, -f (follow) überwacht die Datei live und zeigt neue Zeilen automatisch an, sobald sie hinzugefügt werden (perfekt für Live-Log-Monitoring)",
            },
          ],
          additionalExamples: `
✅ <strong>1. Ganze Datei vs. nur Ende anzeigen</strong><br>
<code>cat log.txt</code><br>
<code>tail log.txt</code><br>
→ cat zeigt alles, tail zeigt nur die letzten 10 Zeilen<br><br>

✅ <strong>2. Nach Fehlern suchen, dann nur die letzten Treffer zeigen</strong><br>
<code>grep "Error" log.txt</code><br>
<code>grep "Error" log.txt | tail -n 5</code><br>
→ grep findet alle Fehler, tail zeigt nur die letzten 5<br><br>

✅ <strong>3. Datei sortieren und dann das Ende zeigen</strong><br>
<code>sort namen.txt</code><br>
<code>sort namen.txt | tail -n 10</code><br>
→ Sortiert die Namen, tail zeigt die letzten 10 (alphabetisch letzte)<br><br>

✅ <strong>4. Letzte Zeilen zeigen und dann zählen</strong><br>
<code>tail -n 20 data.txt</code><br>
<code>tail -n 20 data.txt | wc -l</code><br>
→ Zeigt die letzten 20 Zeilen, wc -l zählt dass es genau 20 sind<br><br>

✅ <strong>5. Mehrere Dateien zusammenfügen und nur Ende zeigen</strong><br>
<code>cat file1.txt file2.txt</code><br>
<code>cat file1.txt file2.txt | tail -n 15</code><br>
→ cat kombiniert beide Dateien, tail zeigt nur die letzten 15 Zeilen
          `,
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `tail file.txt`?",
              options: [
                "Zeigt die ersten Zeilen",
                "Zeigt die letzten 10 Zeilen",
                "Löscht die letzten Zeilen",
                "Kopiert die letzten Zeilen",
              ],
              correctIndex: 1,
              explanation:
                "`tail` zeigt standardmäßig die letzten 10 Zeilen einer Datei.",
            },
            {
              level: "mittel",
              prompt: "Was ist besonders wichtig an `tail -f`?",
              options: [
                "Es ist schneller",
                "Live-Logausgabe: zeigt neue Zeilen in Echtzeit (extrem wichtig für Monitoring)",
                "Es zeigt mehr Zeilen",
                "Es löscht Dateien",
              ],
              correctIndex: 1,
              explanation:
                "`-f` (follow) zeigt neue Zeilen live an, sobald sie zur Datei hinzugefügt werden – essentiell für Log-Monitoring.",
            },
            {
              level: "schwer",
              prompt: "Was macht `tail -f /var/log/syslog`?",
              options: [
                "Zeigt nur die letzten 10 Zeilen",
                "Zeigt die Logdatei live und aktualisiert sich automatisch bei neuen Einträgen",
                "Löscht die Logdatei",
                "Kopiert die Logdatei",
              ],
              correctIndex: 1,
              explanation:
                "Live-Monitoring: neue Log-Einträge erscheinen automatisch im Terminal – perfekt zum Debuggen.",
            },
          ],
        },

        wc_l: {
          title: "wc -l",
          description: "Zählt Zeilen in einer Datei oder Eingabe.",
          explanation: "Zählt Zeilen in einer Datei oder Eingabe.",
          simpleExample: "wc -l file.txt",
          detail: "Mit Piping mächtig: zählt Ergebnisse nach Filtern.",
          complexExample: "ls | wc -l",
          complexExampleExplanation: [
            {
              line: "ls | wc -l",
              explanation:
                "ls listet Dateien im aktuellen Verzeichnis auf, | leitet die Ausgabe an wc -l weiter, das die Anzahl der Zeilen (also Dateien/Ordner) zählt",
            },
          ],
          additionalExamples: `
✅ <strong>1. Datei anzeigen und dann Zeilen zählen</strong><br>
<code>cat log.txt</code><br>
<code>wc -l log.txt</code><br>
→ cat zeigt den Inhalt, wc -l zählt wie viele Zeilen es sind<br><br>

✅ <strong>2. Dateien auflisten und dann zählen</strong><br>
<code>ls</code><br>
<code>ls | wc -l</code><br>
→ ls zeigt Dateien, wc -l zählt wie viele Dateien/Ordner es sind<br><br>

✅ <strong>3. Nach etwas suchen und Treffer zählen</strong><br>
<code>grep "Error" log.txt</code><br>
<code>grep "Error" log.txt | wc -l</code><br>
→ Findet alle Fehler, wc -l zählt wie viele Treffer es gibt<br><br>

✅ <strong>4. Erste Zeilen zeigen und dann zählen</strong><br>
<code>head -n 20 data.txt</code><br>
<code>head -n 20 data.txt | wc -l</code><br>
→ Zeigt die ersten 20 Zeilen, wc -l bestätigt dass es genau 20 sind<br><br>

✅ <strong>5. Sortieren, Duplikate entfernen, dann zählen</strong><br>
<code>sort namen.txt | uniq</code><br>
<code>sort namen.txt | uniq | wc -l</code><br>
→ Sortiert und entfernt Duplikate, wc -l zählt wie viele eindeutige Namen es gibt
          `,
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `wc -l file.txt`?",
              options: [
                "Zählt Wörter",
                "Zählt Zeilen",
                "Zählt Zeichen",
                "Löscht Zeilen",
              ],
              correctIndex: 1,
              explanation:
                "`wc -l` zählt die Anzahl der Zeilen in einer Datei.",
            },
            {
              level: "mittel",
              prompt: "Warum ist `wc -l` mit Piping mächtig?",
              options: [
                "Weil es schneller ist",
                "Weil es Ergebnisse nach Filtern zählen kann",
                "Weil es mehr zeigt",
                "Weil es Dateien löscht",
              ],
              correctIndex: 1,
              explanation:
                "Nach Filtern (z.B. `grep`, `find`) kann man mit `wc -l` schnell zählen, wie viele Treffer es gibt.",
            },
            {
              level: "schwer",
              prompt: "Was macht `ls | wc -l`?",
              options: [
                "Zeigt alle Dateien",
                "Zählt die Anzahl der Dateien/Ordner im aktuellen Verzeichnis",
                "Löscht alle Dateien",
                "Kopiert alle Dateien",
              ],
              correctIndex: 1,
              explanation:
                "`ls` listet Dateien, `|` leitet an `wc -l` weiter, das die Anzahl der Zeilen (also Dateien) zählt.",
            },
          ],
        },

        wc_w: {
          title: "wc -w",
          description: "Zählt Wörter.",
          explanation: "Zählt Wörter.",
          simpleExample: "wc -w text.txt",
          detail: "Oft zusammen mit head/tail verwendet.",
          complexExample: "ifconfig | head -n 7 | wc -w",
          complexExampleExplanation: [
            {
              line: "ifconfig | head -n 7 | wc -w",
              explanation:
                "ifconfig zeigt Netzwerkinformationen, | leitet an head -n 7 weiter (zeigt nur die ersten 7 Zeilen), | leitet an wc -w weiter (zählt die Anzahl der Wörter in diesen Zeilen)",
            },
          ],
          additionalExamples: `
✅ <strong>1. Datei anzeigen und dann Wörter zählen</strong><br>
<code>cat text.txt</code><br>
<code>wc -w text.txt</code><br>
→ cat zeigt den Inhalt, wc -w zählt wie viele Wörter es sind<br><br>

✅ <strong>2. Erste Zeilen zeigen und dann Wörter zählen</strong><br>
<code>head -n 10 log.txt</code><br>
<code>head -n 10 log.txt | wc -w</code><br>
→ Zeigt die ersten 10 Zeilen, wc -w zählt die Wörter darin<br><br>

✅ <strong>3. Nach etwas suchen und dann Wörter zählen</strong><br>
<code>grep "Error" log.txt</code><br>
<code>grep "Error" log.txt | wc -w</code><br>
→ Findet alle Fehler-Zeilen, wc -w zählt die Wörter in den Treffern<br><br>

✅ <strong>4. Letzte Zeilen zeigen und dann Wörter zählen</strong><br>
<code>tail -n 5 status.txt</code><br>
<code>tail -n 5 status.txt | wc -w</code><br>
→ Zeigt die letzten 5 Zeilen, wc -w zählt die Wörter<br><br>

✅ <strong>5. Mehrere Dateien kombinieren und Wörter zählen</strong><br>
<code>cat file1.txt file2.txt</code><br>
<code>cat file1.txt file2.txt | wc -w</code><br>
→ Kombiniert beide Dateien, wc -w zählt alle Wörter zusammen
          `,
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `wc -w text.txt`?",
              options: [
                "Zählt Zeilen",
                "Zählt Wörter",
                "Zählt Zeichen",
                "Löscht Wörter",
              ],
              correctIndex: 1,
              explanation:
                "`wc -w` zählt die Anzahl der Wörter in einer Datei.",
            },
            {
              level: "mittel",
              prompt: "Womit wird `wc -w` oft kombiniert?",
              options: ["Mit rm", "Mit head/tail", "Mit cp", "Mit mv"],
              correctIndex: 1,
              explanation:
                "Oft kombiniert mit `head` oder `tail`, um nur einen Teil der Datei zu analysieren.",
            },
            {
              level: "schwer",
              prompt: "Was macht `ifconfig | head -n 7 | wc -w`?",
              options: [
                "Zeigt ifconfig",
                "Zählt die Wörter in den ersten 7 Zeilen von ifconfig",
                "Löscht ifconfig",
                "Kopiert ifconfig",
              ],
              correctIndex: 1,
              explanation:
                "`ifconfig` Ausgabe → erste 7 Zeilen (`head -n 7`) → Wörter zählen (`wc -w`) – nützlich für schnelle Analyse.",
            },
          ],
        },
      };

      const commandMeta = {
        ls: {
          title: "ls",
          summary:
            "Listet Dateien und Verzeichnisse – nutze passende Flags für Details oder versteckte Einträge.",
          flags: [
            {
              flag: "-l",
              description: "lange Ausgabe mit Rechten und Besitzer",
            },
            { flag: "-a", description: "zeigt versteckte Dateien und ./." },
            { flag: "-h", description: "menschlich lesbare Größen (mit -l)" },
          ],
          pitfalls: [
            "Falscher Pfad (z. B. ls log statt ls logs) führt zu 'No such file or directory'.",
            "Versteckte Dateien fehlen ohne -a (wichtig bei .env, .git, .ssh).",
          ],
          examples: [
            {
              command: "ls -lah /var/log",
              note: "Alle Logfiles mit Rechten und Größen – ideal für Fehlersuche.",
            },
            {
              command: "ls -lt ~/Downloads | head",
              note: "Neueste Downloads zuerst anzeigen (Zeitstempel).",
            },
          ],
          quizId: "ls",
        },
        cd: {
          title: "cd",
          summary:
            "Wechselt das Arbeitsverzeichnis sicher, inkl. Rücksprung mit OLDPWD.",
          flags: [
            { flag: "-", description: "springt ins vorherige Verzeichnis" },
          ],
          pitfalls: [
            "Leerzeichen im Pfad ohne Anführungszeichen verursachen 'No such file or directory'.",
            "Relativer Pfad aus falschem Startverzeichnis führt an unerwartete Orte.",
          ],
          examples: [
            {
              command: 'cd "/var/www/html" && ls',
              note: "Sichere Navigation in Webroot mit Anführungszeichen.",
            },
            {
              command: 'OLDPWD=$(pwd); cd /tmp && do-something; cd "$OLDPWD"',
              note: "Zurückspringen nach temporärer Aktion.",
            },
          ],
          quizId: "cd",
        },
        grep: {
          title: "grep",
          summary:
            "Filtert Text nach Mustern – ideal mit Zeilennummern und rekursiver Suche.",
          flags: [
            { flag: "-n", description: "zeigt Zeilennummern" },
            { flag: "-i", description: "Groß-/Kleinschreibung ignorieren" },
            { flag: "-r", description: "rekursiv in Verzeichnissen suchen" },
          ],
          pitfalls: [
            "Shell interpretiert Sonderzeichen (z. B. *) ohne Anführungszeichen.",
            "Ohne --include kann rekursive Suche viel Rauschen produzieren.",
          ],
          examples: [
            {
              command: 'grep -n "ERROR" /var/log/syslog',
              note: "Zeigt Fehlerzeilen mit Position – schnell für Troubleshooting.",
            },
            {
              command: 'grep -ri --include="*.conf" "Listen" /etc/apache2',
              note: "Nur relevante Config-Dateien durchsuchen.",
            },
          ],
          quizId: "grep",
        },
        find: {
          title: "find",
          summary:
            "Durchsucht Verzeichnisse rekursiv nach Namen, Typen oder Größe.",
          flags: [
            {
              flag: "-name",
              description: "Pfad-Pattern (mit Anführungszeichen)",
            },
            {
              flag: "-type f",
              description: "nur Dateien (d für Verzeichnisse)",
            },
            {
              flag: "-maxdepth",
              description: "Tiefe begrenzen, um Rauschen zu vermeiden",
            },
          ],
          pitfalls: [
            "-name ohne Anführungszeichen lässt die Shell das Pattern expandieren.",
            '-exec ohne "{}" oder fehlendes ";" führt zu Fehlern.',
          ],
          examples: [
            {
              command: 'find . -maxdepth 2 -type f -name "*.log"',
              note: "Nur Logfiles in den ersten zwei Ebenen finden.",
            },
            {
              command:
                'find /var/www -type f -name "*.php" -exec ls -lh {} \\;',
              note: "Gefundene Dateien direkt inspizieren.",
            },
          ],
          quizId: "find_name",
        },
        chmod: {
          title: "chmod",
          summary:
            "Setzt Rechte numerisch oder symbolisch – mit Bedacht auf Sicherheit.",
          flags: [
            { flag: "-R", description: "rekursiv auf Unterordner anwenden" },
            { flag: "+x", description: "Ausführungsbit setzen (symbolisch)" },
          ],
          pitfalls: [
            "777 unüberlegt gesetzt macht Dateien weltweit beschreibbar.",
            "Rechte rekursiv (-R) auf sensible Verzeichnisse kann Services brechen.",
          ],
          examples: [
            {
              command: "chmod 644 ~/.ssh/config",
              note: "Lesbare, aber nicht ausführbare Config.",
            },
            {
              command: "chmod -R 755 /var/www/html",
              note: "Standard-Webrechte für Ordner & Dateien (Owner behält Schreiben).",
            },
          ],
          quizId: "chmod",
        },
        chown: {
          title: "chown",
          summary: "Ändert Besitzer und Gruppe – oft mit sudo nötig.",
          flags: [
            {
              flag: "user:group",
              description: "Besitzer und Gruppe in einem Schritt",
            },
            { flag: "-R", description: "rekursiv anwenden" },
          ],
          pitfalls: [
            "Ohne sudo: Operation not permitted.",
            "Rekursive Änderungen auf /etc oder /usr können Systeme unbrauchbar machen.",
          ],
          examples: [
            {
              command: "sudo chown -R www-data:www-data /var/www/html",
              note: "Webserver-Besitz sicher auf Inhalte anwenden.",
            },
            {
              command: "sudo chown $USER:$USER ~/Downloads/report.txt",
              note: "Dateien nach Kopie mit Root-Rechten zurücksetzen.",
            },
          ],
          quizId: "chown",
        },
        touch: {
          title: "touch",
          summary: "Erstellt leere Dateien oder aktualisiert Zeitstempel.",
          flags: [
            { flag: "-t", description: "Zeitstempel manuell setzen" },
            {
              flag: "-a/-m",
              description: "nur Access oder Modified Time ändern",
            },
          ],
          pitfalls: [
            "Pfadverzeichnisse müssen existieren (vorher mkdir -p).",
            "Ruft Fehlermeldung auf read-only Filesystemen hervor.",
          ],
          examples: [
            { command: "touch notes.txt", note: "Schnell eine Datei anlegen." },
            {
              command: "touch -t 202401011200 backup.tar",
              note: "Zeitstempel für Dokumentation setzen.",
            },
          ],
          quizId: "touch",
        },
        head: {
          title: "head",
          summary:
            "Zeigt die ersten Zeilen einer Datei – ideal für Log-Quickchecks.",
          flags: [{ flag: "-n", description: "Anzahl Zeilen steuern" }],
          pitfalls: [
            "Ohne -n zu wenig/zu viele Zeilen, besonders bei großen Dateien.",
            "Berechtigungen verhindern Zugriff auf Systemlogs (sudo nutzen).",
          ],
          examples: [
            {
              command: "head -n 20 /var/log/auth.log",
              note: "Schneller Blick in Login-Events.",
            },
            {
              command: "grep -n ERROR app.log | head -n 5",
              note: "Die ersten fünf Fehlerstellen herausfiltern.",
            },
          ],
          quizId: "head",
        },
        tail: {
          title: "tail",
          summary:
            "Zeigt das Ende einer Datei, mit -f perfekt fürs Live-Monitoring.",
          flags: [
            { flag: "-f", description: "Folgt neuen Zeilen (follow)" },
            { flag: "-n", description: "Startzeilen vom Ende definieren" },
          ],
          pitfalls: [
            "Ohne sudo bei root-Logs Zugriff verweigert.",
            "Bei rotierenden Logs (logrotate) springt -f ggf. auf alte Datei, -F nutzen.",
          ],
          examples: [
            {
              command: "sudo tail -f /var/log/syslog",
              note: "Live-Ansicht der Systemmeldungen.",
            },
            {
              command: "tail -n 50 application.log | grep -i error",
              note: "Letzte Fehler in Applogs filtern.",
            },
          ],
          quizId: "tail",
        },
        "wc -l": {
          title: "wc -l",
          summary: "Zählt Zeilen – ideal kombiniert mit Pipes oder find.",
          flags: [
            {
              flag: "--files0-from",
              description: "Dateiliste Null-terminiert verarbeiten",
            },
          ],
          pitfalls: [
            "Leerzeichen in Dateinamen ohne korrekte Quoting führen zu falschen Zählungen.",
            "Mit cat *.log | wc -l wird auch der Dateiname gezählt, wenn cat Fehler meldet.",
          ],
          examples: [
            {
              command: "find . -type f -name '*.log' | wc -l",
              note: "Anzahl der Logdateien ermitteln.",
            },
            {
              command: "grep -r 'ERROR' *.log | wc -l",
              note: "Fehlerzeilen über mehrere Dateien zählen.",
            },
          ],
          quizId: "wc_l",
        },
      };

      const baseCheatSheetCategories = {
        fileHandling: {
          id: "fileHandling",
          name: "Datei-Handling",
          icon: "📂",
          colorClass: "badge-operator",
          matchers: [
            "ls",
            "cp",
            "mv",
            "rm",
            "mkdir",
            "touch",
            "cat",
            "grep",
            "sort",
            "uniq",
            "find",
            "tree",
            "head",
            "tail",
            "wc",
            "redirect",
            "nano",
          ],
          quizIds: [],
        },
        processManagement: {
          id: "processManagement",
          name: "Prozess-Management",
          icon: "🧠",
          colorClass: "badge-connoisseur",
          matchers: [
            "ps",
            "top",
            "kill",
            "jobs",
            "fg",
            "bg",
            "chmod",
            "chown",
            "chgrp",
            "whoami",
          ],
          quizIds: [],
        },
        networking: {
          id: "networking",
          name: "Netzwerk",
          icon: "🌐",
          colorClass: "badge-navigator",
          matchers: ["ssh", "wget", "curl", "netcat", "nc", "ping", "hydra"],
          quizIds: [],
        },
        systemInfo: {
          id: "systemInfo",
          name: "System & Monitoring",
          icon: "🖥️",
          colorClass: "badge-voyer",
          matchers: ["pwd", "cd", "history", "whoami", "df", "du", "pipe"],
          quizIds: [],
        },
        misc: {
          id: "misc",
          name: "Allgemein",
          icon: "✨",
          colorClass: "badge-morelinux",
          matchers: [],
          quizIds: [],
        },
      };

      // Haupt-Badge-Konfiguration (5 zentrale Kompetenz-Badges)
      const mainBadges = [
        {
          id: "badge-file",
          categoryKey: "fileHandling",
          segmentFilters: ["segment2", "segment3", "segment5"],
        },
        {
          id: "badge-process",
          categoryKey: "processManagement",
          segmentFilters: ["segment4"],
        },
        {
          id: "badge-network",
          categoryKey: "networking",
          segmentFilters: [],
        },
        {
          id: "badge-system",
          categoryKey: "systemInfo",
          segmentFilters: ["segment1"],
        },
        {
          id: "badge-misc",
          categoryKey: "misc",
          segmentFilters: [],
        },
      ].map((badge, index) => ({
        ...badge,
        name: baseCheatSheetCategories[badge.categoryKey].name,
        icon: baseCheatSheetCategories[badge.categoryKey].icon,
        colorClass:
          baseCheatSheetCategories[badge.categoryKey].colorClass ||
          [
            "badge-voyer",
            "badge-operator",
            "badge-connoisseur",
            "badge-navigator",
            "badge-morelinux",
          ][index],
      }));

      // Legacy mainBadges mit segments für Kompatibilität
      const legacyMainBadges = [
        {
          id: "linux_voyer",
          name: "Linux Voyer",
          icon: "👁️",
          colorClass: "badge-voyer",
          subSegments: ["segment4", "segment5"], // System & Rechte + Erweiterte Techniken
          segments: [
            {
              id: "segment4",
              name: "System & Rechte",
              icon: "🔐",
              colorClass: "segment-4",
              quizIds: [
                "whoami",
                "chmod",
                "chmod_R",
                "chown",
                "chgrp",
                "touch",
                "head",
                "tail",
                "wc_l",
                "wc_w",
              ],
            },
            {
              id: "segment5",
              name: "Erweiterte Techniken",
              icon: "⚙️",
              colorClass: "segment-5",
              quizIds: ["redirect", "nano_flow"],
            },
          ],
        },
        {
          id: "linux_operator",
          name: "Linux Operator",
          icon: "⚙️",
          colorClass: "badge-operator",
          subSegments: ["segment2"], // Dateioperationen & Suche
          segments: [
            {
              id: "segment2",
              name: "Dateioperationen & Suche",
              icon: "🔍",
              colorClass: "segment-2",
              quizIds: [
                "cp_r",
                "rm",
                "rm_r",
                "cat",
                "grep",
                "sort",
                "sort_n",
                "uniq",
                "find_name",
                "find_maxdepth",
              ],
            },
          ],
        },
        {
          id: "cli_connoisseur",
          name: "CLI-Konnoisseur",
          icon: "🎯",
          colorClass: "badge-connoisseur",
          subSegments: ["segment3"], // Auflistung & Umleitung
          segments: [
            {
              id: "segment3",
              name: "Auflistung & Umleitung",
              icon: "📋",
              colorClass: "segment-3",
              quizIds: [
                "ls_R",
                "ls_aR",
                "tree",
                "tree_d",
                "tree_L",
                "echo",
                "redirect_overwrite",
                "redirect_append",
                "redirect_stderr",
                "pipe",
              ],
            },
          ],
        },
        {
          id: "linux_navigator",
          name: "Linux Navigator",
          icon: "🧭",
          colorClass: "badge-navigator",
          subSegments: ["segment1"], // Navigation & Grundlagen
          segments: [
            {
              id: "segment1",
              name: "Navigation & Grundlagen",
              icon: "🧭",
              colorClass: "segment-1",
              quizIds: [
                "pwd",
                "cd",
                "cd_parent",
                "ls",
                "ls_a",
                "ls_la",
                "mkdir",
                "mkdir_p",
                "mv",
                "cp",
              ],
            },
          ],
        },
        {
          id: "morelinux",
          name: "MoreLinux",
          icon: "👑",
          colorClass: "badge-morelinux",
          subSegments: [], // Bisheriges Linux Master
          segments: [],
        },
      ];

      // Legacy badgeSegments für Kompatibilität (wird später entfernt)
      const badgeSegments = [
        {
          id: "segment1",
          name: "Navigation & Grundlagen",
          icon: "🧭",
          colorClass: "segment-1",
          quizIds: [
            "pwd",
            "cd",
            "cd_parent",
            "ls",
            "ls_a",
            "ls_la",
            "mkdir",
            "mkdir_p",
            "mv",
            "cp",
          ],
        },
        {
          id: "segment2",
          name: "Dateioperationen & Suche",
          icon: "🔍",
          colorClass: "segment-2",
          quizIds: [
            "cp_r",
            "rm",
            "rm_r",
            "cat",
            "grep",
            "sort",
            "sort_n",
            "uniq",
            "find_name",
            "find_maxdepth",
          ],
        },
        {
          id: "segment3",
          name: "Auflistung & Umleitung",
          icon: "📋",
          colorClass: "segment-3",
          quizIds: [
            "ls_R",
            "ls_aR",
            "tree",
            "tree_d",
            "tree_L",
            "echo",
            "redirect_overwrite",
            "redirect_append",
            "redirect_stderr",
            "pipe",
          ],
        },
        {
          id: "segment4",
          name: "System & Rechte",
          icon: "🔐",
          colorClass: "segment-4",
          quizIds: [
            "whoami",
            "chmod",
            "chmod_R",
            "chown",
            "chgrp",
            "touch",
            "head",
            "tail",
            "wc_l",
            "wc_w",
          ],
        },
        {
          id: "segment5",
          name: "Erweiterte Techniken",
          icon: "⚙️",
          colorClass: "segment-5",
          quizIds: ["redirect", "nano_flow"],
        },
        {
          id: "segment6",
          name: "Fortgeschrittene Workflows",
          icon: "🚀",
          colorClass: "segment-6",
          quizIds: [],
        },
      ];

      // Masterquiz-Daten
      const masterQuizData = {
        segment1: {
          title: "Masterquiz: Navigation & Grundlagen",
          scenario:
            "Du bist Systemadministrator und musst ein Backup-System für tägliche Dokumente einrichten. Das Backup-Verzeichnis soll mit dem aktuellen Datum benannt werden, und alle wichtigen Dateien sollen automatisch gesichert werden.",
          question:
            "Du musst ein tägliches Backup-System erstellen. Welche Befehlssequenz erstellt ein Backup-Verzeichnis mit dem aktuellen Datum, kopiert alle `.txt`-Dateien dorthin, wechselt in das Backup-Verzeichnis und zeigt den aktuellen Pfad an?",
          options: [
            "mkdir backups/$(date +%Y-%m-%d) && cp *.txt backups/$(date +%Y-%m-%d)/ && cd backups/$(date +%Y-%m-%d) && pwd",
            "cd backups && mkdir $(date +%Y-%m-%d) && cp *.txt",
            "mkdir -p backups && cp *.txt backups/ && pwd",
            "ls -la backups/$(date +%Y-%m-%d)",
          ],
          correctIndex: 0,
          explanation:
            "Die Sequenz nutzt `mkdir` für das Verzeichnis (mit Datum), kopiert alle `.txt`-Dateien, wechselt ins Backup-Verzeichnis und zeigt den Pfad mit `pwd`. Die Kombination aus `mkdir`, `cp`, `cd` und `pwd` ist essentiell.",
        },
        segment2: {
          title: "Masterquiz: Dateioperationen & Suche",
          scenario:
            "Du musst eine Log-Analyse durchführen: Finde alle `.log`-Dateien im aktuellen Verzeichnisbaum, filtere nach Fehler-Einträgen, entferne Duplikate und erstelle eine sortierte Zusammenfassung.",
          question:
            'Du musst alle Fehlermeldungen aus Log-Dateien extrahieren. Welche Befehlssequenz findet alle `.log`-Dateien, sucht nach "ERROR", sortiert die Ergebnisse, entfernt Duplikate und zählt die eindeutigen Treffer?',
          options: [
            'find . -name "*.log" | grep "ERROR" | sort | uniq | wc -l',
            'find . -name "*.log" -type f -exec grep "ERROR" {} \\; | sort | uniq | wc -l',
            'grep -r "ERROR" *.log | sort | uniq',
            'cat *.log | grep "ERROR" | sort',
          ],
          correctIndex: 1,
          explanation:
            "`find` sucht rekursiv nach `.log`-Dateien, `-exec grep` durchsucht jede gefundene Datei, `sort` sortiert die Ergebnisse, `uniq` entfernt Duplikate, und `wc -l` zählt die Zeilen. Die Kombination aus `find`, `grep`, `sort` und `uniq` ist typisch für Log-Analysen.",
        },
        segment3: {
          title: "Masterquiz: Auflistung & Umleitung",
          scenario:
            "Du richtest ein Logging-System für eine Anwendung ein. Die Anwendung soll ihre Ausgaben in eine Logdatei schreiben, Fehler sollen separat gespeichert werden, und du musst die Verzeichnisstruktur dokumentieren.",
          question:
            "Du richtest ein Logging-System ein. Welche Befehlssequenz erstellt die Verzeichnisstruktur `logs/app`, schreibt eine Startnachricht mit Datum in die Logdatei, und dokumentiert die Verzeichnisstruktur (Fehler sollen in eine separate Datei)?",
          options: [
            'mkdir logs/app && echo "$(date)" >> logs/app/application.log && tree -L 2 logs/ > structure.txt 2> errors.log',
            'mkdir -p logs/app && echo "$(date): Started" >> logs/app/application.log && tree -L 2 logs/ > logs/app/structure.txt 2> logs/app/errors.log',
            'cd logs && mkdir app && echo "Started" > application.log',
            'tree logs/ > structure.txt && echo "Started" >> application.log',
          ],
          correctIndex: 1,
          explanation:
            "`mkdir -p` erstellt die Struktur, `echo` mit `>>` hängt an (ideal für Logs), `tree -L 2` zeigt die Struktur begrenzt, und `2>` leitet Fehler separat um. Die Kombination aus `echo`, `>>`, `2>`, und `tree` ist typisch für Logging-Setups.",
        },
        segment4: {
          title: "Masterquiz: System & Rechte",
          scenario:
            "Du installierst ein Web-Server-Script und musst sicherstellen, dass es mit den richtigen Berechtigungen läuft. Das Script muss ausführbar sein, und du musst prüfen, wer es ausführt.",
          question:
            "Du installierst ein Web-Server-Script. Welche Sequenz erstellt das Script, setzt die Rechte auf 755 (Besitzer: rwx, Gruppe/Andere: rx), ändert Besitzer und Gruppe auf www-data, und prüft, wer es ausführen würde?",
          options: [
            "touch deploy.sh && chmod 755 deploy.sh && sudo chown www-data:www-data deploy.sh && whoami",
            "chmod +x deploy.sh && chown www-data deploy.sh",
            "touch deploy.sh && chmod 777 deploy.sh && whoami",
            "mkdir deploy.sh && chmod 755 deploy.sh",
          ],
          correctIndex: 0,
          explanation:
            "`touch` erstellt die Datei, `chmod 755` setzt die Standard-Web-Server-Rechte, `chown user:group` ändert Besitzer und Gruppe, und `whoami` prüft den aktuellen Benutzer. Die Kombination aus `touch`, `chmod`, `chown` und `whoami` ist essentiell für sichere Script-Installationen.",
        },
      };

      const commandCards = Array.from(
        document.querySelectorAll(".command-card")
      );
      // Map visible category text to normalized category keys and add category classes
      (function assignCategoryClasses() {
        const categoryMap = {
          Navigation: "navigation",
          Auflisten: "listing",
          Suche: "search",
          Pipes: "pipes",
          Umleitung: "redirect",
          Workflow: "workflow",
          Dateien: "files",
          System: "system",
          Rechte: "permissions",
        };
        commandCards.forEach((card) => {
          const tagEl = card.querySelector(".command-tag");
          if (!tagEl) return;
          const raw = tagEl.textContent.trim();
          const key =
            categoryMap[raw] || raw.toLowerCase().replace(/\s+/g, "-");
          card.classList.add("category-" + key);
        });
      })();

      const quizRoot = document.getElementById("quiz-root");
      const quizBodyEl = document.getElementById("quiz-body");
      const quizTitleEl = document.getElementById("quiz-title");
      const quizSubtitleEl = document.getElementById("quiz-subtitle");
      const quizFeedbackEl = document.getElementById("quiz-feedback");
      const quizSubmitBtn = document.getElementById("quiz-submit-btn");
      const quizCloseBtn = document.getElementById("quiz-close-btn");

      const commandModalRoot = document.getElementById("command-modal-root");
      const commandModalTitle = document.getElementById("command-modal-title");
      const commandModalSubtitle = document.getElementById(
        "command-modal-subtitle"
      );
      const commandModalSummary = document.getElementById(
        "command-modal-summary"
      );
      const commandModalFlags = document.getElementById("command-modal-flags");
      const commandModalPitfalls = document.getElementById(
        "command-modal-pitfalls"
      );
      const commandModalExamples = document.getElementById(
        "command-modal-examples"
      );
      const commandModalCloseBtn = document.getElementById(
        "command-modal-close-btn"
      );
      const commandModalFeedback = document.getElementById(
        "command-modal-feedback"
      );
      const commandModalQuizBtn = document.getElementById(
        "command-modal-quiz-btn"
      );

      let currentQuizId = null;
      let activeFocusTrap = null;
      let activeFilterSegment = null; // Aktives Filter-Segment (null = kein Filter)
      let activeFilterAchievement = null; // Aktives Achievement-Filter (null = kein Filter)

      // Achievement System
      const achievements = [
        { threshold: 10, name: "Linux Voyeur", icon: "👁️", class: "badge-10" },
        {
          threshold: 20,
          name: "Linux Operator",
          icon: "⚙️",
          class: "badge-20",
        },
        {
          threshold: 30,
          name: "CLI Connoisseur",
          icon: "🎯",
          class: "badge-30",
        },
        {
          threshold: 40,
          name: "Linux Navigator",
          icon: "🧭",
          class: "badge-40",
        },
        { threshold: 50, name: "Linux Master", icon: "👑", class: "badge-50" },
        {
          threshold: 60,
          name: 'Linux Basics "it\'s something"',
          icon: "🏆",
          class: "badge-60",
        },
      ];

      function getTotalCorrectAnswers() {
        const stored = localStorage.getItem("quizResults");
        if (!stored) return 0;
        try {
          const results = JSON.parse(stored);
          return Object.values(results).reduce((sum, count) => sum + count, 0);
        } catch {
          return 0;
        }
      }

      function isQuizCompleted(quizId) {
        const stored = localStorage.getItem("quizResults");
        if (!stored) return false;

        try {
          const results = JSON.parse(stored);
          return results[quizId] === 3;
        } catch {
          return false;
        }
      }

      function activateFocusTrap(modal) {
        const focusableSelectors =
          'a[href], button, textarea, input, select, [tabindex]:not([tabindex="-1"])';
        const focusables = Array.from(
          modal.querySelectorAll(focusableSelectors)
        ).filter((el) => !el.hasAttribute("disabled"));
        if (focusables.length === 0) return;

        const first = focusables[0];
        const last = focusables[focusables.length - 1];
        const previous = document.activeElement;

        function handleKeydown(event) {
          if (event.key === "Tab") {
            if (focusables.length === 1) {
              event.preventDefault();
              first.focus();
              return;
            }
            if (event.shiftKey && document.activeElement === first) {
              event.preventDefault();
              last.focus();
            } else if (!event.shiftKey && document.activeElement === last) {
              event.preventDefault();
              first.focus();
            }
          } else if (event.key === "Escape" && commandModalRoot) {
            closeCommandModal();
          }
        }

        modal.addEventListener("keydown", handleKeydown);
        first.focus();
        activeFocusTrap = { modal, handleKeydown, previous };
      }

      function releaseFocusTrap() {
        if (!activeFocusTrap) return;
        const { modal, handleKeydown, previous } = activeFocusTrap;
        modal.removeEventListener("keydown", handleKeydown);
        if (previous && typeof previous.focus === "function") {
          previous.focus();
        }
        activeFocusTrap = null;
      }

      function saveQuizResult(quizId, correctCount) {
        const stored = localStorage.getItem("quizResults");
        let results = {};
        if (stored) {
          try {
            results = JSON.parse(stored);
          } catch {
            results = {};
          }
        }
        // Nur speichern, wenn alle Fragen richtig waren (3/3) und noch nicht gespeichert
        if (correctCount === 3 && !results[quizId]) {
          results[quizId] = correctCount;
          localStorage.setItem("quizResults", JSON.stringify(results));

          // Update badge progress
          updateBadgeProgress();

          return true; // New completion
        }
        return false; // Already completed or not all correct
      }

      // Migration: Convert quizResults to badgeProgress
      function migrateToBadgeProgress() {
        const stored = localStorage.getItem("badgeProgress");
        if (stored) return; // Already migrated

        const quizResults = localStorage.getItem("quizResults");
        if (!quizResults) {
          localStorage.setItem("badgeProgress", JSON.stringify({}));
          return;
        }

        try {
          const results = JSON.parse(quizResults);
          const badgeProgress = {};

          badgeSegments.forEach((segment) => {
            let count = 0;
            segment.quizIds.forEach((id) => {
              if (results[id] === 3) count++;
            });
            badgeProgress[segment.id] = count;
          });

          localStorage.setItem("badgeProgress", JSON.stringify(badgeProgress));
        } catch (e) {
          console.error("Migration error:", e);
          localStorage.setItem("badgeProgress", JSON.stringify({}));
        }
      }

      // Get badge progress from localStorage
      function getBadgeProgress() {
        const stored = localStorage.getItem("badgeProgress");
        if (!stored) {
          migrateToBadgeProgress();
          return getBadgeProgress();
        }
        try {
          return JSON.parse(stored);
        } catch {
          return {};
        }
      }

      // Update badge progress based on quizResults
      function updateBadgeProgress() {
        const quizResults = localStorage.getItem("quizResults");
        if (!quizResults) return;

        try {
          const results = JSON.parse(quizResults);
          const badgeProgress = {};

          badgeSegments.forEach((segment) => {
            let count = 0;
            segment.quizIds.forEach((id) => {
              if (results[id] === 3) count++;
            });
            badgeProgress[segment.id] = count;
          });

          localStorage.setItem("badgeProgress", JSON.stringify(badgeProgress));
        } catch (e) {
          console.error("Update badge progress error:", e);
        }
      }

      // Get segment progress
      function getSegmentProgress(segmentId) {
        const progress = getBadgeProgress();
        return progress[segmentId] || 0;
      }

      // Check if master quiz is completed
      function isMasterQuizCompleted(segmentId) {
        const stored = localStorage.getItem("masterQuizCompleted");
        if (!stored) return false;
        try {
          const completed = JSON.parse(stored);
          return completed[segmentId] === true;
        } catch {
          return false;
        }
      }

      // Mark master quiz as completed
      function setMasterQuizCompleted(segmentId) {
        const stored = localStorage.getItem("masterQuizCompleted");
        let completed = {};
        if (stored) {
          try {
            completed = JSON.parse(stored);
          } catch {
            completed = {};
          }
        }
        completed[segmentId] = true;
        localStorage.setItem("masterQuizCompleted", JSON.stringify(completed));
      }

      // Check if achievement master quiz is completed
      function isAchievementMasterCompleted(threshold) {
        const stored = localStorage.getItem("achievementMasterCompleted");
        if (!stored) return false;
        try {
          const completed = JSON.parse(stored);
          return completed[threshold] === true;
        } catch {
          return false;
        }
      }

      // Mark achievement master quiz as completed
      function setAchievementMasterCompleted(threshold) {
        const stored = localStorage.getItem("achievementMasterCompleted");
        let completed = {};
        if (stored) {
          try {
            completed = JSON.parse(stored);
          } catch {
            completed = {};
          }
        }
        completed[threshold] = true;
        localStorage.setItem(
          "achievementMasterCompleted",
          JSON.stringify(completed)
        );
      }

      // Get segment ID from achievement threshold
      function getSegmentIdFromThreshold(threshold) {
        const mapping = {
          10: "segment1",
          20: "segment2",
          30: "segment3",
          40: "segment4",
          50: "segment5",
          60: "segment6",
        };
        return mapping[threshold] || null;
      }

      // Get achievement threshold from segment ID
      function getAchievementThresholdFromSegment(segmentId) {
        const mapping = {
          segment1: 10,
          segment2: 20,
          segment3: 30,
          segment4: 40,
          segment5: 50,
          segment6: 60,
        };
        return mapping[segmentId] || null;
      }

      // Get all quiz IDs for an achievement threshold
      function getQuizIdsForAchievement(threshold) {
        const segmentMapping = {
          10: "segment1", // Linux Voyeur - Navigation & Grundlagen
          20: "segment2", // Linux Operator - Dateioperationen & Suche
          30: "segment3", // CLI Connoisseur - Auflistung & Umleitung
          40: "segment4", // Linux Navigator - System & Rechte
          50: "segment5", // Linux Master - Erweiterte Techniken
          60: "segment6", // Linux Basics - Fortgeschrittene Workflows
        };

        const segmentId = segmentMapping[threshold];
        if (segmentId) {
          const segment = badgeSegments.find((s) => s.id === segmentId);
          if (segment) {
            return [...segment.quizIds]; // Return copy of quiz IDs for this segment
          }
        }

        // Fallback: return empty array
        return [];
      }

      // Check if all quizzes for an achievement are completed
      function areAllAchievementQuizzesCompleted(threshold) {
        const quizIds = getQuizIdsForAchievement(threshold);
        const stored = localStorage.getItem("quizResults");
        if (!stored) return false;

        try {
          const results = JSON.parse(stored);
          return quizIds.every((quizId) => results[quizId] === 3);
        } catch {
          return false;
        }
      }

      // Filter cards by achievement quiz IDs
      function filterCardsByAchievement(threshold) {
        if (threshold === null) {
          // Filter entfernen - alle Karten anzeigen (außer die durch Suche versteckten)
          const searchInput = document.getElementById("search-input");
          if (searchInput && searchInput.value.trim()) {
            // Suche ist aktiv, wird separat behandelt
            return;
          }
          commandCards.forEach((card) => {
            card.classList.remove("hidden");
          });
          // Segment-Filter auch zurücksetzen
          activeFilterSegment = null;
          updateBadgeDisplay();
          return;
        }

        const quizIds = getQuizIdsForAchievement(threshold);

        // Segment-Filter zurücksetzen wenn Achievement-Filter aktiv
        activeFilterSegment = null;
        updateBadgeDisplay();

        // Alle Karten durchgehen und entsprechend filtern
        commandCards.forEach((card) => {
          const quizId = card.dataset.quizId;
          if (!quizId) return; // Skip cards without quiz ID

          const belongsToAchievement = quizIds.includes(quizId);
          // Wenn Karte zu Achievement gehört, anzeigen, sonst verstecken
          if (belongsToAchievement) {
            card.classList.remove("hidden");
          } else {
            card.classList.add("hidden");
          }
        });
      }

      function updateAchievements() {
        const totalCorrect = getTotalCorrectAnswers();
        const container = document.getElementById("achievements-container");
        const progressEl = document.getElementById("achievement-progress");

        if (!container || !progressEl) return;

        container.innerHTML = "";
        achievements.forEach((achievement) => {
          const isUnlocked = totalCorrect >= achievement.threshold;
          const isMasterCompleted = isAchievementMasterCompleted(
            achievement.threshold
          );
          const segmentId = getSegmentIdFromThreshold(achievement.threshold);

          const badge = document.createElement("div");
          let badgeClasses = `achievement-badge ${achievement.class} ${
            isUnlocked ? "unlocked" : "locked"
          }`;

          if (isMasterCompleted) {
            badgeClasses += " golden";
          }

          badge.className = badgeClasses;
          badge.innerHTML = `<span class="achievement-icon">${achievement.icon}</span><span>${achievement.name}</span>`;

          // Click-Handler für alle Badges (auch gesperrte)
          badge.style.cursor = "pointer";
          const allQuizzesCompleted = isUnlocked
            ? areAllAchievementQuizzesCompleted(achievement.threshold)
            : false;

          if (isMasterCompleted) {
            badge.title = "Master-Quiz abgeschlossen! 🏆";
          } else if (allQuizzesCompleted) {
            badge.title = "Alle Quiz abgeschlossen! Klicken für Master-Quiz";
          } else if (isUnlocked) {
            badge.title = "Klicken um zugehörige Quiz anzuzeigen";
          } else {
            badge.title = `Noch gesperrt. Klicken um benötigte Quiz anzuzeigen (${achievement.threshold} Fragen nötig)`;
          }

          badge.addEventListener("click", () => {
            // Toggle Filter
            if (activeFilterAchievement === achievement.threshold) {
              // Filter entfernen
              activeFilterAchievement = null;
              filterCardsByAchievement(null);
            } else {
              // Filter setzen
              activeFilterAchievement = achievement.threshold;
              filterCardsByAchievement(achievement.threshold);

              // Wenn alle Quiz abgeschlossen sind, Master-Quiz anbieten
              if (isUnlocked && allQuizzesCompleted && segmentId) {
                setTimeout(() => {
                  if (
                    confirm(
                      `Alle Quiz für "${achievement.name}" sind abgeschlossen! Möchtest du das Master-Quiz starten?`
                    )
                  ) {
                    openMasterQuiz(segmentId);
                  }
                }, 100);
              }
            }

            // Segment-Filter zurücksetzen wenn Achievement-Filter aktiv
            if (activeFilterAchievement) {
              activeFilterSegment = null;
              updateBadgeDisplay();
            }
          });

          container.appendChild(badge);
        });

        progressEl.textContent = `Fortschritt: ${totalCorrect}/60 Fragen richtig beantwortet`;
      }

      let cheatSheetMap = null;

      function findCategoryKeyForQuiz(quizId) {
        const normalized = quizId.toLowerCase();
        const matchKey = Object.keys(baseCheatSheetCategories).find((key) => {
          const category = baseCheatSheetCategories[key];
          return (category.matchers || []).some((token) =>
            normalized.includes(token.toLowerCase())
          );
        });

        return matchKey || "misc";
      }

      function buildCheatSheetMap() {
        const categories = JSON.parse(JSON.stringify(baseCheatSheetCategories));
        Object.values(categories).forEach((category) => {
          category.quizIds = [];
        });

        const quizIds = new Set([
          ...Object.keys(quizData),
          ...commandCards.map((card) => card.dataset.quizId).filter(Boolean),
        ]);

        const quizToCategory = {};

        quizIds.forEach((quizId) => {
          const categoryKey = findCategoryKeyForQuiz(quizId);
          quizToCategory[quizId] = categoryKey;
          categories[categoryKey].quizIds.push(quizId);
        });

        commandCards.forEach((card) => {
          const quizId = card.dataset.quizId;
          if (!quizId) return;
          const categoryKey = quizToCategory[quizId] || "misc";
          card.dataset.cheatCategory = categoryKey;
        });

        cheatSheetMap = { categories, quizToCategory };
      }

      function getCategoryProgress(categoryKey) {
        if (!cheatSheetMap) buildCheatSheetMap();
        const category = cheatSheetMap.categories[categoryKey];
        if (!category) {
          return { completed: 0, total: 0, percentage: 0 };
        }

        const quizResults = localStorage.getItem("quizResults");
        let completed = 0;
        if (quizResults) {
          try {
            const results = JSON.parse(quizResults);
            category.quizIds.forEach((quizId) => {
              if (results[quizId] === 3) {
                completed++;
              }
            });
          } catch (e) {
            console.error(
              "Kategorie-Fortschritt konnte nicht berechnet werden:",
              e
            );
          }
        }

        const total = category.quizIds.length;
        const percentage =
          total > 0 ? Math.round((completed / total) * 100) : 0;

        return { completed, total, percentage };
      }

      // Berechne Fortschritt für ein Haupt-Badge basierend auf Cheat-Sheet-Kategorien
      function getMainBadgeProgress(mainBadge) {
        const categoryProgress = getCategoryProgress(mainBadge.categoryKey);
        if (categoryProgress.total > 0) {
          return {
            completed: categoryProgress.completed,
            total: categoryProgress.total,
            percentage: categoryProgress.percentage,
          };
        }

        // Legacy-Fallback über Segment-Definitionen
        const allQuizIds = [];
        (mainBadge.segments || []).forEach((segment) => {
          allQuizIds.push(...segment.quizIds);
        });

        if (allQuizIds.length === 0) {
          return {
            completed: 0,
            total: 0,
            percentage: 0,
          };
        }

        const quizResults = localStorage.getItem("quizResults");
        let totalCompleted = 0;
        if (quizResults) {
          try {
            const results = JSON.parse(quizResults);
            allQuizIds.forEach((quizId) => {
              if (results[quizId] === 3) {
                totalCompleted++;
              }
            });
          } catch (e) {
            console.error("Fallback-Badge-Fortschritt fehlgeschlagen:", e);
          }
        }

        return {
          completed: totalCompleted,
          total: allQuizIds.length,
          percentage:
            allQuizIds.length > 0
              ? Math.round((totalCompleted / allQuizIds.length) * 100)
              : 0,
        };
      }

      // Update Badge Display für neue Struktur
      function updateBadgeDisplay() {
        const container = document.getElementById("badges-header");
        if (!container) return;

        container.innerHTML = "";

        // Initialisiere Migration beim ersten Laden
        migrateToBadgeProgress();

        // Haupt-Badge Reihe
        const mainRow = document.createElement("div");
        mainRow.className = "main-badges-row";

        // Sub-Badges Reihe
        const subRow = document.createElement("div");
        subRow.className = "sub-badges-row";

        mainBadges.forEach((mainBadge) => {
          const progress = getMainBadgeProgress(mainBadge);

          const badge = document.createElement("div");
          badge.className = `main-badge ${mainBadge.colorClass}`;

          // Markiere aktives Badge
          if (
            activeFilterSegment &&
            mainBadge.segmentFilters.includes(activeFilterSegment)
          ) {
            badge.classList.add("active");
          }

          // Click-Handler für Filter-Funktion
          badge.addEventListener("click", () => {
            // Wenn bereits aktiv, Filter entfernen
            if (
              activeFilterSegment &&
              mainBadge.segmentFilters.includes(activeFilterSegment)
            ) {
              activeFilterSegment = null;
            } else {
              // Filter auf erstes Sub-Segment setzen
              if (mainBadge.segmentFilters.length > 0) {
                activeFilterSegment = mainBadge.segmentFilters[0];
              }
              activeFilterAchievement = null;
            }
            filterCardsBySegment();
            updateBadgeDisplay();
          });

          // Doppelklick-Handler für Master-Quiz (wenn alle Quiz abgeschlossen)
          if (
            progress.total > 0 &&
            progress.percentage === 100 &&
            mainBadge.segmentFilters.length > 0
          ) {
            badge.style.cursor = "pointer";
            badge.title = "Doppelklick für Master-Quiz";
            badge.addEventListener("dblclick", (e) => {
              e.stopPropagation();
              // Öffne Master-Quiz für erstes Sub-Segment
              if (mainBadge.segmentFilters.length > 0) {
                openMasterQuiz(mainBadge.segmentFilters[0]);
              }
            });
          } else {
            badge.title = `${mainBadge.name}: ${progress.completed}/${
              progress.total || "0"
            } Quiz abgeschlossen (${progress.percentage}%)`;
          }

          badge.innerHTML = `
            <div class="main-badge-header">
              <span class="main-badge-icon">${mainBadge.icon}</span>
              <span class="main-badge-name">${mainBadge.name}</span>
            </div>
            <div class="main-badge-progress-container">
              <div class="main-badge-progress-bar">
                <div class="main-badge-progress-fill" style="width: ${
                  progress.percentage
                }%"></div>
              </div>
              <div class="main-badge-progress-text">${progress.completed}/${
            progress.total || 0
          }</div>
            </div>
          `;

          mainRow.appendChild(badge);

          // Sub-Badge Container für dieses Haupt-Badge
          const subBadgeGroup = document.createElement("div");
          subBadgeGroup.className = "badge-group";
          const subBadgeContainer = document.createElement("div");
          subBadgeContainer.className = "sub-badge-container";

          // Füge Sub-Badges basierend auf segmentFilters hinzu
          if (mainBadge.segmentFilters && mainBadge.segmentFilters.length > 0) {
            mainBadge.segmentFilters.forEach((segmentId) => {
              const segment = badgeSegments.find((s) => s.id === segmentId);
              if (segment) {
                const subBadge = document.createElement("div");
                subBadge.className = `sub-badge ${segment.colorClass}`;
                subBadge.innerHTML = `
                  <span>${segment.icon}</span>
                  <span>${segment.name}</span>
                `;
                subBadgeContainer.appendChild(subBadge);
              }
            });
          }

          subBadgeGroup.appendChild(subBadgeContainer);
          subRow.appendChild(subBadgeGroup);
        });

        container.appendChild(mainRow);
        container.appendChild(subRow);
      }

      // Filtere Kacheln nach Segment
      function filterCardsBySegment() {
        // Wenn Achievement-Filter aktiv ist, Segment-Filter ignorieren
        if (activeFilterAchievement) {
          return;
        }

        if (!activeFilterSegment) {
          // Kein Filter aktiv - alle Kacheln anzeigen (außer die, die durch Suche versteckt sind)
          commandCards.forEach((card) => {
            // Nur hidden entfernen, wenn es durch Segment-Filter gesetzt wurde
            // Die Suche wird separat behandelt
            const searchInput = document.getElementById("search-input");
            if (searchInput && searchInput.value.trim()) {
              // Wenn Suche aktiv ist, wird die Karte durch die Suchfunktion gefiltert
              return;
            }
            card.classList.remove("hidden");
          });
          return;
        }

        // Finde das aktive Segment
        const segment = badgeSegments.find((s) => s.id === activeFilterSegment);
        if (!segment) return;

        // Zeige nur Kacheln, die zu diesem Segment gehören
        commandCards.forEach((card) => {
          const quizId = card.dataset.quizId;
          const belongsToSegment = segment.quizIds.includes(quizId);
          card.classList.toggle("hidden", !belongsToSegment);
        });
      }

      // Assign badges to cards
      function assignBadgeToCards() {
        badgeSegments.forEach((segment) => {
          segment.quizIds.forEach((quizId) => {
            const card = commandCards.find((c) => c.dataset.quizId === quizId);
            if (card) {
              const header = card.querySelector(".command-header");
              if (header && !header.querySelector(".badge-mini")) {
                const miniBadge = document.createElement("span");
                miniBadge.className = `badge-mini ${segment.colorClass}`;
                miniBadge.textContent = segment.icon;
                miniBadge.title = segment.name;
                header.insertBefore(miniBadge, header.firstChild);
              }
            }
          });
        });
      }

      // Open Master Quiz
      function openMasterQuiz(segmentId) {
        const masterQuiz = masterQuizData[segmentId];
        if (!masterQuiz) {
          console.warn("Kein Masterquiz für Segment:", segmentId);
          return;
        }

        const modal = document.getElementById("master-quiz-root");
        const titleEl = document.getElementById("master-quiz-title");
        const bodyEl = document.getElementById("master-quiz-body");
        const feedbackEl = document.getElementById("master-quiz-feedback");

        if (!modal || !titleEl || !bodyEl) return;

        titleEl.textContent = masterQuiz.title;
        feedbackEl.textContent = "";
        bodyEl.innerHTML = "";

        // Scenario
        const scenarioDiv = document.createElement("div");
        scenarioDiv.className = "master-quiz-scenario";
        scenarioDiv.textContent = masterQuiz.scenario;
        bodyEl.appendChild(scenarioDiv);

        // Question
        const questionDiv = document.createElement("div");
        questionDiv.className = "quiz-question";
        const optionsHTML = masterQuiz.options
          .map(
            (opt, idx) => `
              <label class="quiz-option" data-option-index="${idx}">
                <input type="radio" name="master-quiz-option" value="${idx}" />
                <span><code>${opt}</code></span>
              </label>
            `
          )
          .join("");
        questionDiv.innerHTML = `
          <div class="quiz-question-title">${masterQuiz.question}</div>
          <div class="quiz-options">
            ${optionsHTML}
          </div>
        `;
        // Chicken-Button für Master-Quiz hinzufügen
        const chickenBtn = document.createElement("button");
        chickenBtn.type = "button";
        chickenBtn.className = "quiz-chicken-btn";
        chickenBtn.textContent = "🐔 Lösung zeigen";
        chickenBtn.dataset.correctIndex = masterQuiz.correctIndex;
        chickenBtn.addEventListener("click", function () {
          const correctIdx = parseInt(this.dataset.correctIndex);
          const optionsDiv = questionDiv.querySelector(".quiz-options");
          const allLabels = optionsDiv.querySelectorAll("label");
          allLabels.forEach((label, labelIdx) => {
            if (labelIdx === correctIdx) {
              label.classList.add("highlight-correct");
              const radio = label.querySelector("input[type=radio]");
              if (radio) radio.checked = true;
            } else {
              label.classList.remove("highlight-correct");
            }
          });
          this.disabled = true;
          this.style.opacity = "0.5";
          this.style.cursor = "not-allowed";
        });
        questionDiv.appendChild(chickenBtn);
        bodyEl.appendChild(questionDiv);

        modal.classList.remove("hidden");
        modal.setAttribute("aria-hidden", "false");
        currentMasterQuizSegment = segmentId;
      }

      // Close Master Quiz
      function closeMasterQuiz() {
        const modal = document.getElementById("master-quiz-root");
        if (modal) {
          modal.classList.add("hidden");
          modal.setAttribute("aria-hidden", "true");
        }
        currentMasterQuizSegment = null;
      }

      // Parse Hotkeys Content
      function parseHotkeysContent() {
        return [
          {
            title: "Navigation & Bewegung",
            items: [
              {
                shortcut: "H, J, K, L",
                description: "Cursor/Navigation (vim-Style)",
              },
              {
                shortcut: "↑ / ↓ / ← / →",
                description: "Klassische Navigation",
              },
              {
                shortcut: "Ctrl + U / Ctrl + D",
                description: "Halbseite hoch/runter",
              },
              {
                shortcut: "Ctrl + B / Ctrl + F",
                description: "Ganze Seite hoch/runter",
              },
            ],
          },
          {
            title: "Dateien & Verzeichnisse",
            items: [
              { shortcut: "Tab", description: "Autocomplete" },
              {
                shortcut: "Ctrl + R",
                description: "Reverse Search (vergangene Befehle finden)",
              },
              {
                shortcut: "Ctrl + A",
                description: "Cursor an den Anfang der Zeile",
              },
              {
                shortcut: "Ctrl + E",
                description: "Cursor ans Ende der Zeile",
              },
              { shortcut: "Ctrl + W", description: "Vorheriges Wort löschen" },
              {
                shortcut: "Ctrl + K",
                description: "Alles rechts vom Cursor löschen",
              },
              { shortcut: "Ctrl + C", description: "Prozess abbrechen" },
              { shortcut: "Ctrl + Z", description: "Prozess pausieren" },
              { shortcut: "fg / bg", description: "Prozesse fortsetzen" },
            ],
          },
          {
            title: "Quality-of-Life-Improvements",
            items: [
              {
                shortcut: "alias",
                description: "Alias erstellen (z. B. alias ll='ls -la')",
              },
              {
                shortcut: "history",
                description: "History mit Zeitstempeln aktivieren",
              },
              {
                shortcut: "less",
                description: "Statt cat für lange Dateien nutzen",
              },
              {
                shortcut: "fzf",
                description: "Fuzzy Suche in Dateien + History",
              },
              {
                shortcut: "ripgrep (rg)",
                description: "Statt grep benutzen – deutlich schneller",
              },
            ],
          },
          {
            title: "Dateien & Navigation",
            items: [
              {
                shortcut: "nnn / ranger",
                description: "Visuelle Terminal-Dateimanager",
              },
              {
                shortcut: "zoxide",
                description: "Ultraschnelles Wechseln zwischen Verzeichnissen",
              },
              {
                shortcut: "bat",
                description: "Moderne cat-Alternative mit Syntax-Highlighting",
              },
              {
                shortcut: "fd",
                description: "Moderne, intuitive Alternative zu find",
              },
            ],
          },
          {
            title: "Skript-Workflow",
            items: [
              { shortcut: "#!/bin/bash", description: "Shell-Skripte starten" },
              { shortcut: "set -e", description: "Script stoppt bei Fehlern" },
              {
                shortcut: "chmod +x",
                description: "Skripte ausführbar machen",
              },
            ],
          },
          {
            title: "Produktivität",
            items: [
              {
                shortcut: "tmux",
                description: "Terminal in Sessions splitten",
              },
              { shortcut: "SSH-Keys", description: "Statt Passwort" },
              {
                shortcut: ".bashrc /.zshrc",
                description: "Custom prompts – schnelleres visuelles Feedback",
              },
            ],
          },
          {
            title: "Fehler vermeiden",
            items: [
              {
                shortcut: "--dry-run",
                description: "Optionen nutzen (wo verfügbar)",
              },
              {
                shortcut: "mv -i / cp -i / rm -i",
                description: "Interaktive Rückfrage aktivieren",
              },
              {
                shortcut: "Trash-CLI",
                description: "Statt sofortigem Löschen",
              },
            ],
          },
        ];
      }

      const beginnerMistakes = [
        {
          quizId: "rm_r",
          title: "Unbedachtes Löschen mit rm -r",
          description:
            "Ohne Pfad-Check oder Backup gelöschte Verzeichnisse sind weg. Nutze interaktive Abfragen in kritischen Pfaden.",
          example: "rm -r --interactive=once ~/Downloads/tmp",
          tip: "Vorher pwd && ls; bei produktiven Pfaden lieber Trash-CLI nutzen.",
          segmentClass: "segment-4",
        },
        {
          quizId: "mkdir_p",
          title: "Verzeichnistiefe ohne -p anlegen",
          description:
            "Ohne -p bricht mkdir bei fehlenden Elternverzeichnissen ab oder überschreibt nichts sichtbar.",
          example: "mkdir -p projects/demo/src",
          tip: "-p erstellt fehlende Ebenen sicher und ist idempotent.",
          segmentClass: "segment-1",
        },
        {
          quizId: "cp_r",
          title: "cp für Ordner ohne -r",
          description:
            "cp bricht bei Verzeichnissen ab, wenn -r fehlt – Ergebnis ist ein halbfertiger Kopiervorgang.",
          example: "cp -r site/ backup/site",
          tip: "Immer -r (oder -a für Rechte/Links) bei Ordnern setzen.",
          segmentClass: "segment-2",
        },
        {
          quizId: "mv",
          title: "mv mit falschem Zielpfad",
          description:
            "Ohne eindeutigen Zielpfad landen Dateien schnell im Arbeitsverzeichnis oder überschreiben Namen.",
          example: "mv notes.txt docs/notes.txt",
          tip: "Mit Tab-Completion prüfen, ob das Ziel existiert, und -i für Rückfragen nutzen.",
          segmentClass: "segment-3",
        },
        {
          quizId: "redirect_append",
          title: "Logs versehentlich überschrieben",
          description:
            "Ein einzelnes > leert Dateien sofort. Für Log- oder Messdaten immer >> verwenden.",
          example: 'echo "INFO: Start" >> logs/app.log',
          tip: "Vor dem Redirect Datei-Rechte prüfen und lieber append als overwrite.",
          segmentClass: "segment-5",
        },
        {
          quizId: "find_name",
          title: "find ohne Maskierung",
          description:
            "Ungequotete Patterns wie *.log expandieren durch die Shell und liefern falsche Treffer.",
          example: 'find . -name "*.log"',
          tip: "Muster immer in Anführungszeichen setzen und maxdepth nutzen, wenn nötig.",
          segmentClass: "segment-2",
        },
        {
          quizId: "grep",
          title: "grep nur auf einer Datei",
          description:
            "Ohne -R oder -n übersiehst du kontext und verschachtelte Treffer in Projekten.",
          example: 'grep -R "error" .',
          tip: "Mit -n Zeilennummern anzeigen und --color=auto für schnelle Sichtbarkeit.",
          segmentClass: "segment-1",
        },
        {
          quizId: "chmod_R",
          title: "chmod 777 als Allzwecklösung",
          description:
            "Zu breite Rechte öffnen Angriffsflächen. Setze nur benötigte Bits rekursiv und gezielt.",
          example: "chmod -R 640 secrets/",
          tip: "Vorher Besitzer prüfen und Rechte minimal halten (Principle of Least Privilege).",
          segmentClass: "segment-4",
        },
        {
          quizId: "chown",
          title: "Falscher Besitzer nach Deploy",
          description:
            "Dateien im falschen Account führen zu Permission-Denied oder Sicherheitslücken.",
          example: "sudo chown deploy:www-data /var/www/html -R",
          tip: "User:Gruppe immer explizit setzen und mit ls -l verifizieren.",
          segmentClass: "segment-3",
        },
        {
          quizId: "sort_n",
          title: "Lexikografisch statt numerisch sortiert",
          description:
            "Standard-sort ordnet Zahlen wie Strings (2 > 10). Für Metriken brauchst du -n/-k.",
          example: "sort -n -k2 metrics.txt",
          tip: "Mit -r für absteigend kombinieren und Spalten mit -k angeben.",
          segmentClass: "segment-6",
        },
      ];

      // Parse FAQ Data (Agent 1)
      function parseFaqData() {
        // Kategorien-Mapping
        const categoryMap = {
          "Navigieren im Dateisystem": {
            id: "navigation",
            name: "Navigieren im Dateisystem",
            icon: "🧭",
          },
          "Dateiverwaltung (Dateien und Ordner)": {
            id: "fileManagement",
            name: "Dateiverwaltung",
            icon: "📂",
          },
          "Paketmanagement (Software installieren/aktualisieren)": {
            id: "packageManagement",
            name: "Paketmanagement",
            icon: "📦",
          },
          Netzwerkgrundlagen: {
            id: "networking",
            name: "Netzwerkgrundlagen",
            icon: "🌐",
          },
          "Rechte und Berechtigungen": {
            id: "permissions",
            name: "Rechte & Berechtigungen",
            icon: "🔐",
          },
          "Grundlagen der Shell (Bash & nützliche Hilfen)": {
            id: "shell",
            name: "Shell-Grundlagen",
            icon: "💻",
          },
          "Fehlermeldungen und ihre Behebung": {
            id: "troubleshooting",
            name: "Fehlermeldungen",
            icon: "🔧",
          },
          "Systeminformationen und -überwachung": {
            id: "systemInfo",
            name: "Systeminformationen",
            icon: "🖥️",
          },
          "Nützliche Tools und Befehle": {
            id: "tools",
            name: "Tools & Befehle",
            icon: "🛠️",
          },
        };

        // FAQ-Rohdaten (manuell strukturiert aus der TXT-Datei)
        const faqRawData = [
          {
            category: "Navigieren im Dateisystem",
            questions: [
              {
                question: "Wie wechsle ich in ein anderes Verzeichnis?",
                answer:
                  'Mit dem Befehl cd ("change directory") kann man in ein gewünschtes Verzeichnis wechseln. Beispiel: cd Videos wechselt in den Unterordner Videos. Alternativ kann man auch den absoluten Pfad angeben, z. B. cd /home/kali/Documents/Videos.',
                commands: ["cd"],
              },
              {
                question: "Wie gelange ich in mein Home-Verzeichnis?",
                answer:
                  "Gibt man cd ohne Pfad an, wechselt man automatisch ins eigene Home-Verzeichnis. Dasselbe erreicht man mit cd ~ (Tilde steht für das Home-Verzeichnis).",
                commands: ["cd"],
              },
              {
                question: "Wie wechsle ich ins Root-Verzeichnis (/)?",
                answer:
                  "Verwende cd /, um ins Wurzelverzeichnis des Dateisystems zu gelangen. Der Schrägstrich / steht in Linux für das Root-Verzeichnis (oberste Ebene des Dateisystems).",
                commands: ["cd"],
              },
              {
                question: "Wie gehe ich eine Verzeichnisebene nach oben?",
                answer:
                  "Mit cd .. wechselt man in das übergeordnete Verzeichnis (ein Ordner nach oben). Die zwei Punkte .. stehen in Pfadangaben immer für das Parent-Verzeichnis.",
                commands: ["cd"],
              },
              {
                question: "Wie komme ich in das vorherige Verzeichnis zurück?",
                answer:
                  "Mit cd - wechselt man in das zuletzt besuchte Verzeichnis zurück. Dies ist praktisch, um schnell zwischen zwei Verzeichnissen hin- und herzuspringen.",
                commands: ["cd"],
              },
              {
                question:
                  "Wie kann ich mir mein aktuelles Verzeichnis anzeigen lassen?",
                answer:
                  "Der Befehl pwd (print working directory) zeigt den vollständigen Pfad des Verzeichnisses, in dem man sich befindet, an. Beispiel: Befindet sich der Benutzer kali im Ordner /home/kali/Desktop, dann zeigt pwd genau diesen Pfad an.",
                commands: ["pwd"],
              },
              {
                question: "Wie liste ich den Inhalt eines Verzeichnisses auf?",
                answer:
                  "Mit ls werden Dateien und Unterordner im aktuellen Verzeichnis aufgelistet. Ohne Optionen zeigt ls die Namen der Inhalte. Beispielsweise listet ls /etc den Inhalt des /etc-Verzeichnisses auf.",
                commands: ["ls"],
              },
              {
                question: "Wie kann ich auch versteckte Dateien anzeigen?",
                answer:
                  "Versteckte Dateien (deren Namen mit . beginnen) zeigt man mit ls -a an. Oft nutzt man ls -la für eine detaillierte Liste inklusive versteckter Dateien, da -l die lange Liste mit Rechten, Besitzer, Größe und Datum anzeigt.",
                commands: ["ls"],
              },
              {
                question:
                  "Wie erhalte ich detaillierte Infos (Größe, Datum, Rechte) zu Dateien in einem Verzeichnis?",
                answer:
                  "Mit ls -l erhält man eine ausführliche Auflistung aller Dateien/Ordner mit Details wie Berechtigungen, Besitzer, Dateigröße und Änderungsdatum. Zusätzliche Optionen wie -h (human-readable) stellen Größen in lesbare Form (z. B. KiB/MiB) dar, also z. B. ls -lh.",
                commands: ["ls"],
              },
              {
                question: "Was bedeuten . und .. in Pfadangaben?",
                answer:
                  ". steht für das aktuelle Verzeichnis, .. für das übergeordnete Verzeichnis. Beispiel: cd . bleibt im aktuellen Ordner, und cd .. wechselt eine Ebene höher.",
                commands: ["cd"],
              },
              {
                question:
                  "Wie navigiere ich in Pfaden mit Leerzeichen im Namen?",
                answer:
                  'Pfadnamen mit Leerzeichen müssen in Anführungszeichen gesetzt werden oder das Leerzeichen mit \\ maskiert werden. Beispiel: cd "Mein Ordner" oder cd Mein\\ Ordner wechselt in ein Verzeichnis namens "Mein Ordner".',
                commands: ["cd"],
              },
              {
                question: "Gibt es eine Autovervollständigung für Dateinamen?",
                answer:
                  "Ja, durch Drücken der Tab-Taste während der Eingabe vervollständigt die Shell automatisch Dateinamen oder Befehle, sofern eindeutig. Dadurch muss man oft nur den Anfang eines Namens tippen und kann Tippfehler vermeiden (Tab-Autocompletion).",
                commands: [],
              },
            ],
          },
          {
            category: "Dateiverwaltung (Dateien und Ordner)",
            questions: [
              {
                question: "Wie erstelle ich ein neues Verzeichnis?",
                answer:
                  "Mit mkdir <ordnername> erstellt man ein neues Verzeichnis. Beispiel: mkdir Projekte legt einen Ordner namens Projekte im aktuellen Verzeichnis an. Mit mkdir -p pfad/unterordner können auch verschachtelte Unterordner in einem Schritt erzeugt werden.",
                commands: ["mkdir"],
              },
              {
                question: "Wie lösche ich einen Ordner?",
                answer:
                  "Leere Verzeichnisse können mit rmdir <ordnername> gelöscht werden. Enthält der Ordner Dateien oder Unterordner, verwendet man rm -r <ordnername> für rekursives Löschen. Vorsicht: Mit rm -r werden auch alle enthaltenen Dateien gelöscht. Für unwiederbringliches Löschen ohne Nachfragen kann zusätzlich -f (force) verwendet werden, z. B. rm -rf <ordner>.",
                commands: ["rm", "rmdir"],
              },
              {
                question: "Wie lege ich eine neue (leere) Datei an?",
                answer:
                  "Der einfachste Weg ist touch <dateiname>. Wenn die angegebene Datei noch nicht existiert, wird durch touch eine leere Datei erstellt. Beispiel: touch notiz.txt erzeugt eine leere Datei notiz.txt.",
                commands: ["touch"],
              },
              {
                question: "Wie lösche ich eine Datei?",
                answer:
                  "Mit dem Befehl rm <datei> löscht man Dateien. Beispiel: rm test.txt löscht die Datei test.txt. Ohne weitere Optionen fragt rm in der Standardeinstellung nicht nach und entfernt die Datei endgültig.",
                commands: ["rm"],
              },
              {
                question: "Wie kopiere ich eine Datei?",
                answer:
                  "Mit cp <quelle> <ziel> kopiert man eine Datei. Beispiel: cp original.txt kopie.txt erstellt eine Kopie von original.txt unter dem Namen kopie.txt im gleichen Verzeichnis. Um an einen anderen Ort zu kopieren, gibt man den Pfad zum Ziel an (z. B. cp datei.txt /tmp/).",
                commands: ["cp"],
              },
              {
                question: "Wie kopiere ich einen ganzen Ordner mit Inhalt?",
                answer:
                  "Mit dem Parameter -r kopiert cp auch Verzeichnisse rekursiv. Beispiel: cp -r bilder fotos_backup kopiert den gesamten Ordner bilder (mit allen Unterdateien/-ordnern) ins Verzeichnis fotos_backup.",
                commands: ["cp"],
              },
              {
                question:
                  "Wie verschiebe oder benenne ich eine Datei/einen Ordner um?",
                answer:
                  "Das Verschieben erledigt man mit mv <quelle> <ziel>. Zum Umbenennen kann man mv im selben Verzeichnis nutzen: mv altername.txt neuername.txt ändert den Dateinamen. Verschieben in einen anderen Ordner funktioniert analog: mv datei.txt /pfad/zum/zielordner/.",
                commands: ["mv"],
              },
              {
                question:
                  "Wie zeige ich den Inhalt einer Textdatei im Terminal an?",
                answer:
                  "Mit cat <datei> wird der gesamte Dateinhalt auf einmal angezeigt. Beispiel: cat info.txt druckt den Text der Datei info.txt auf die Konsole. Für lange Dateien ist less <datei> praktischer – damit kann man seitenweise blättern.",
                commands: ["cat"],
              },
              {
                question:
                  "Wie bearbeite ich eine Textdatei direkt im Terminal?",
                answer:
                  "Dazu nutzt man einen Terminal-Texteditor wie nano oder vim. Für Einsteiger empfiehlt sich nano: nano <datei> öffnet die Datei im Nano-Editor. Unten werden die wichtigsten Steuerungstasten angezeigt (z. B. zum Speichern STRG+O, zum Beenden STRG+X). Alternativ kann man vi <datei> bzw. vim <datei> nutzen – Vim ist aber deutlich anspruchsvoller.",
                commands: ["nano", "vim"],
              },
              {
                question: "Wie kann ich nach einer Datei suchen?",
                answer:
                  'Mit dem Befehl find lässt sich das Dateisystem durchsuchen. Beispiel: find / -name "*.conf" sucht unter / (dem Root-Verzeichnis) nach allen Dateien, die auf *.conf enden. Für eine schnelle Suche kann Kali auch locate <name> nutzen – dieses greift auf eine indexierte Datenbank zurück (vorher mit updatedb aktualisieren).',
                commands: ["find"],
              },
              {
                question: "Wie finde ich einen bestimmten Text in Dateien?",
                answer:
                  'Mit grep kann man in Dateien nach Textmustern suchen. Beispiel: grep "ERROR" /var/log/syslog sucht im System-Log nach Vorkommen von "ERROR". Standardmäßig gibt grep alle Zeilen aus, die den gesuchten Text enthalten.',
                commands: ["grep"],
              },
              {
                question:
                  "Wie erfahre ich den Dateityp oder Details einer Datei?",
                answer:
                  "Der Befehl file <datei> zeigt an, um welchen Dateityp es sich handelt (z. B. ASCII-Text, ELF-Binary etc.). Für ausführlichere Informationen, wie Größe, letztes Änderungsdatum, Berechtigungen, nutzt man stat <datei>, was alle Dateieigenschaften auflistet.",
                commands: ["file", "stat"],
              },
            ],
          },
          {
            category: "Paketmanagement (Software installieren/aktualisieren)",
            questions: [
              {
                question:
                  "Wie aktualisiere ich die Paketliste (Repository-Index)?",
                answer:
                  "Mit sudo apt update fragt man alle in /etc/apt/sources.list eingetragenen Paketquellen ab und lädt die neuesten Paketinformationen herunter. Dies sollte man regelmäßig tun, insbesondere bevor man neue Pakete installiert, damit die Paketdatenbank aktuell ist.",
                commands: ["apt"],
              },
              {
                question:
                  "Wie aktualisiere ich installierte Pakete auf die neueste Version?",
                answer:
                  "Nach apt update kann man mit sudo apt upgrade alle installierten Pakete upgraden. Dieser Befehl spielt verfügbare Updates ein, ohne Pakete zu entfernen. (Hinweis: apt upgrade aktualisiert nur, was ohne Konflikte möglich ist. Mit apt full-upgrade würden auch Paketabhängigkeiten geändert, was bei Kali allerdings mit Vorsicht zu verwenden ist.)",
                commands: ["apt"],
              },
              {
                question: "Wie installiere ich ein neues Programm/Paket?",
                answer:
                  "Mit sudo apt install <paketname>. Beispiel: sudo apt install nmap installiert das Paket nmap aus den Paketquellen. Man kann auch mehrere Pakete gleichzeitig installieren, indem man die Namen hintereinander angibt (getrennt durch Leerzeichen).",
                commands: ["apt"],
              },
              {
                question: "Wie entferne ich ein installiertes Paket?",
                answer:
                  "Mit sudo apt remove <paketname> deinstalliert man ein Paket. Die Konfigurationsdateien bleiben dabei erhalten. Soll auch diese bereinigt werden, verwendet man sudo apt purge <paketname>, um das Paket komplett (inkl. Konfigurationsresten) zu entfernen.",
                commands: ["apt"],
              },
              {
                question: "Wie räume ich nicht mehr benötigte Pakete auf?",
                answer:
                  "Nach vielen Installationen bleiben manchmal ungenutzte Abhängigkeits-Pakete zurück. Mit sudo apt autoremove werden solche automatisch installierten, aber nicht mehr benötigten Pakete entfernt, um Speicherplatz freizugeben.",
                commands: ["apt"],
              },
              {
                question: "Wie suche ich nach Paketen?",
                answer:
                  'Mit apt search <schlüsselwort> kann man die Paketdatenbank nach Namen und Beschreibungen durchsuchen. Beispiel: apt search editor listet alle Pakete auf, die im Namen oder in der Beschreibung "editor" enthalten. Ähnlich liefert apt-cache search <wort> das Ergebnis über das ältere apt-cache-Werkzeug.',
                commands: ["apt"],
              },
              {
                question:
                  "Wie sehe ich, welche Pakete bereits installiert sind?",
                answer:
                  "Mit apt list --installed erhält man eine Liste aller installierten Pakete. Alternativ zeigt dpkg -l ebenfalls alle installierten Pakete als Liste an. Man kann diese Ausgabe mit grep filtern, um ein bestimmtes Paket zu finden (z. B. dpkg -l | grep <name>).",
                commands: ["apt", "dpkg"],
              },
              {
                question:
                  "Wie installiere ich eine .deb-Datei (lokales Debian-Paket)?",
                answer:
                  "Mit dem Programm dpkg (Debian Package Manager). Verwende sudo dpkg -i <paketdatei.deb>, um ein heruntergeladenes *.deb-Paket zu installieren. Schlägt die Installation wegen fehlender Abhängigkeiten fehl, führt man anschließend sudo apt -f install aus, um diese aufzulösen.",
                commands: ["dpkg", "apt"],
              },
              {
                question: "Was ist der Unterschied zwischen apt und apt-get?",
                answer:
                  "apt ist ein etwas neueres Kommando, das viele häufig genutzte Funktionen von apt-get und apt-cache in einem Tool vereint. So entspricht z. B. apt install dem klassischen apt-get install. Für die meisten Anwendungsfälle kann man apt benutzen – es ist benutzerfreundlicher (z. B. Fortschrittsbalken) – während apt-get und apt-cache aus Kompatibilitätsgründen weiterhin verfügbar sind. Kurz gesagt: apt ist eine komfortablere Weiterentwicklung von apt-get.",
                commands: ["apt"],
              },
              {
                question:
                  'Wie behebe ich den Fehler "E: Unable to locate package", wenn ein Paket nicht gefunden wird?',
                answer:
                  "Dieser Fehler bedeutet, dass das genannte Paket in den Paketquellen nicht gefunden wurde. Zunächst sollte man prüfen, ob der Paketname korrekt ist und apt update ausgeführt wurde. Wenn der Fehler weiterhin besteht, liegt oft ein Problem mit den Paketquellen vor. In Kali sollten in /etc/apt/sources.list die offiziellen kali-rolling-Quellen eingetragen sein. Man kann die Datei überprüfen und ggf. die Standard-Kali-Repository-URLs eintragen. Anschließend erneut apt update ausführen und die Installation wiederholen.",
                commands: ["apt"],
              },
            ],
          },
          {
            category: "Netzwerkgrundlagen",
            questions: [
              {
                question:
                  "Wie finde ich meine IP-Adresse oder Netzwerk-Schnittstellen heraus?",
                answer:
                  "Der Befehl ifconfig (aus dem Paket net-tools) zeigt die konfigurierten Netzwerkinterfaces mit ihren IP-Adressen an. Unter neueren Linux-Systemen verwendet man bevorzugt ip a (oder ip addr), das ähnliche Informationen ausgibt. Beispiel: ip a listet alle Interfaces (eth0, wlan0, lo etc.) mit IP, Netzmaske und Status auf.",
                commands: ["ifconfig", "ip"],
              },
              {
                question:
                  "Wie teste ich die Erreichbarkeit eines anderen Hosts (Ping)?",
                answer:
                  "Mit ping <ziel> sendet man ICMP-Pakete an einen Host, um die Verbindung zu prüfen. Beispiel: ping google.com sendet kontinuierlich Pings an google.com. Eine erfolgreiche Antwort zeigt, dass Netzwerkverbindung besteht und gibt die Round-Trip-Zeit aus. Mit Ctrl+C bricht man den Vorgang ab. (Standardmäßig pingt Linux endlos, mit -c 4 kann man z. B. 4 Pakete schicken lassen.)",
                commands: ["ping"],
              },
              {
                question:
                  "Wie zeige ich alle offenen Ports bzw. aktuellen Netzwerkverbindungen an?",
                answer:
                  "Früher nutzte man dafür netstat -tuln (tcp/udp, listening, numeric). In neueren Systemen ist ss -tuln der empfohlene Befehl (ss = socket statistics), der ähnliche Ausgaben liefert. Beide zeigen z. B. an, welche Dienste auf welchen Ports lauschen (LISTEN). Will man sämtliche bestehenden Verbindungen sehen, kann man netstat -tpna verwenden (zeigt auch die zugehörigen Programme/PIDs).",
                commands: ["netstat", "ss"],
              },
              {
                question:
                  "Wie überprüfe ich die Routing-Tabelle oder den Weg eines Pakets?",
                answer:
                  "Die Routing-Tabelle (Weg der Pakete ins Netzwerk) sieht man mit route -n oder ip route. Um den Pfad zu einem bestimmten Ziel zu verfolgen, nutzt man traceroute <ziel>. Beispiel: traceroute heise.de listet die einzelnen Zwischenstationen (Router), die ein Paket durchläuft, um heise.de zu erreichen.",
                commands: ["route", "traceroute"],
              },
              {
                question:
                  "Wie kann ich DNS-Informationen zu einer Domain abfragen (Nameserver lookup)?",
                answer:
                  "Mit nslookup <domain> kann man den DNS-Server nach der IP-Adresse einer Domain fragen. Beispiel: nslookup kali.org gibt die IP-Adresse(s) der Domain kali.org zurück. Für ausführlichere DNS-Abfragen kann man dig <domain> verwenden, das z. B. auch MX-Records, NS-Records etc. abfragen kann.",
                commands: ["nslookup", "dig"],
              },
              {
                question:
                  "Wie scanne ich einen Rechner oder ein Netzwerk nach offenen Ports (mit Nmap)?",
                answer:
                  "Nmap ist ein Port-Scanner. Ein einfacher Scan erfolgt mit nmap <IP-Adresse>. Beispielsweise führt nmap 192.168.0.5 einen Standard-Portscan der gängigsten 1000 Ports auf dem Host 192.168.0.5 durch und listet offene Ports samt Dienstnamen. Mit Optionen kann man das Scanning anpassen, z. B. -p 1-65535 für alle Ports oder -sV für Service- und Versionserkennung. (Hinweis: Nmap bietet sehr viele Optionen für unterschiedliche Scan-Methoden.)",
                commands: ["nmap"],
              },
              {
                question:
                  "Wie ermittle ich den Inhaber einer Domain oder weitere Infos (WHOIS)?",
                answer:
                  "Mit dem Kommando whois <domain> kann man einen WHOIS-Lookup durchführen. Die Ausgabe enthält je nach Domain u. a. Registrierungsinformationen, Name des Domain-Inhabers (bei privaten Personen ggf. anonymisiert), Registrar, Erstellungs- und Ablaufdaten usw.",
                commands: ["whois"],
              },
              {
                question:
                  "Wie kann ich den Quelltext einer Webseite oder eine HTTP-Anfrage abrufen?",
                answer:
                  "Mit curl kann man über URLs Daten abrufen oder senden. Beispiel: curl http://example.com holt den HTML-Code der angegebenen Webseite. Möchte man die Ausgabe in eine Datei speichern, kann man curl -o output.html http://example.com nutzen. Für einfache Downloads bietet sich auch wget an.",
                commands: ["curl"],
              },
              {
                question:
                  "Wie lade ich eine Datei per Kommandozeile aus dem Internet herunter?",
                answer:
                  "Einfache Methode: wget <URL>. Beispiel: wget https://kali.org/sample.iso lädt die Datei sample.iso aus dem Internet in das aktuelle Verzeichnis herunter. Alternativ kann curl -O <URL> verwendet werden, das den Inhalt unter dem ursprünglichen Dateinamen speichert. Unterschied: wget ist primär zum Download gedacht (und kann z. B. rekursiv Webseiten herunterladen), während curl vielfältiger für Webanfragen/API-Aufrufe eingesetzt wird.",
                commands: ["wget", "curl"],
              },
            ],
          },
          {
            category: "Rechte und Berechtigungen",
            questions: [
              {
                question:
                  "Wie ändere ich Dateiberechtigungen (Lese/Schreib/Execute-Rechte)?",
                answer:
                  "Mit dem Befehl chmod kann man Unix-Dateirechte ändern. Man kann die Rechte entweder symbolisch (mit Buchstaben) oder numerisch (mit Oktalzahlen) angeben. Beispiel symbolisch: chmod u+rwx,g+rx,o-r file.txt würde dem Besitzer alle Rechte geben (rwx), der Gruppe nur Lese/Execute, und anderen Benutzern die Leserechte entziehen. Häufig nutzt man die numerische Notation: z. B. chmod 755 script.sh setzt die Rechte auf rwxr-xr-x (Besitzer darf lesen/schreiben/ausführen =7, Gruppe und andere nur lesen/ausführen =5 und 5). Eine häufige Aufgabe ist es, Skripte ausführbar zu machen: Dafür kann man auch kurz chmod +x datei.sh verwenden.",
                commands: ["chmod"],
              },
              {
                question: "Wie mache ich eine Datei ausführbar?",
                answer:
                  "Mit chmod +x <datei> fügt man das Ausführungsrecht (execute) für die Datei hinzu. Danach kann die Datei (z. B. ein Skript) direkt gestartet werden, etwa mit ./script.sh. Beachte: Für Skripte muss in der ersten Zeile häufig ein Shebang (#!/usr/bin/env bash o. Ä.) gesetzt sein, damit das System weiß, welcher Interpreter genutzt werden soll.",
                commands: ["chmod"],
              },
              {
                question:
                  "Wie ändere ich den Besitzer einer Datei oder eines Ordners?",
                answer:
                  "Mit chown <benutzer>:<gruppe> <datei> ändert man den Eigentümer (Besitzer) und optional die Gruppe einer Datei. Beispiel: sudo chown kali:kali datei.txt ändert Besitzer und Gruppe von datei.txt auf den Benutzer kali. Oft reicht sudo chown <user> <datei> – dabei bleibt die Gruppenzugehörigkeit unverändert.",
                commands: ["chown"],
              },
              {
                question: "Wie ändere ich die Gruppe einer Datei?",
                answer:
                  "Mit chgrp <gruppe> <datei> kann man die Gruppenzugehörigkeit ändern (statt über chown). Beispiel: sudo chgrp sudo config.cfg würde die Datei config.cfg der Gruppe sudo zuordnen. (Hinweis: chown <user>:<gruppe> kann beides in einem Schritt ändern.)",
                commands: ["chgrp", "chown"],
              },
              {
                question: "Wozu dient sudo und wie verwende ich es?",
                answer:
                  'sudo ("substitute user do") erlaubt es, Befehle mit administrativen Rechten (als root) auszuführen. In Kali ist der Standarduser häufig schon root; existiert ein normaler Benutzer, muss man sudo voranstellen, um Systembefehle auszuführen, die erhöhte Rechte brauchen. Beispiel: sudo apt update aktualisiert die Paketliste mit Root-Rechten. Beim ersten Einsatz in einer Session fragt sudo nach dem Passwort des Benutzers. Wichtig: Nur Nutzer, die in der Datei /etc/sudoers oder in der sudo-Gruppe eingetragen sind, dürfen sudo benutzen.',
                commands: ["sudo"],
              },
              {
                question:
                  'Was bedeutet die Fehlermeldung "Permission denied" und wie behebe ich sie?',
                answer:
                  '"Permission denied" heißt, dass die aktuellen Berechtigungen nicht ausreichen, um die gewünschte Aktion durchzuführen. Dies tritt z. B. auf, wenn man auf eine Datei/Ordner ohne ausreichende Rechte zugreifen will, oder einen Befehl ausführt, der Root-Rechte erfordert. Lösung: Entweder als root ausführen (Befehl mit sudo voranstellen) oder die Dateirechte anpassen. Beispiel 1: cat /etc/shadow ergibt Permission denied, weil die Datei nur von root gelesen werden darf – hier würde sudo cat /etc/shadow funktionieren (sofern berechtigt). Beispiel 2: ./script.sh ergibt Permission denied, weil das Skript nicht ausführbar ist – hier hilft chmod +x script.sh, um die Ausführung zu erlauben. Beispiel 3: cd ordner schlägt fehl mit Permission denied, wenn man keine Suchrechte auf den Ordner hat – hier müsste man dem Ordner das x-Recht geben (chmod +x ordner).',
                commands: ["sudo", "chmod"],
              },
            ],
          },
          {
            category: "Grundlagen der Shell (Bash & nützliche Hilfen)",
            questions: [
              {
                question:
                  "Welche Shell wird in Kali Linux verwendet und wie finde ich das heraus?",
                answer:
                  "Kali Linux nutzt standardmäßig Bash (Bourne Again SHell) als Kommandozeileninterpreter. Man kann die aktuelle Shell herausfinden, indem man echo $SHELL eingibt – das liefert z. B. /bin/bash. Alternativ zeigt echo $0 bei interaktiver Nutzung ebenfalls den Shell-Namen (bei Login-Shells).",
                commands: [],
              },
              {
                question:
                  "Wie kann ich mir meine bisherigen Befehle anzeigen lassen (Befehls-Historie)?",
                answer:
                  'Mit dem Befehl history werden alle zuletzt eingegebenen Befehle der aktuellen Shell-Sitzung aufgelistet. Jeder Eintrag hat eine Nummer, und mit !<Nummer> kann man einen bestimmten Befehl erneut ausführen. Praktische Kürzel: !! wiederholt den letzten Befehl, !ls würde z. B. den letzten Befehl, der mit "ls" begann, erneut ausführen.',
                commands: ["history"],
              },
              {
                question: "Wie definiere ich eigene Kurzbefehle (Aliases)?",
                answer:
                  'Mit alias kann man ein Kürzel für einen längeren Befehl definieren. Syntax: alias kurz="langer Befehl mit Optionen". Beispiel: alias ll="ls -l --color=auto" definiert ll als Alias, der farbig und im Langformat listet. Nach Eingabe von ll führt die Shell dann ls -l --color=auto aus. Bestehende Aliase listet man mit alias ohne Argumente auf.',
                commands: ["alias"],
              },
              {
                question: "Wie entferne ich einen definierten Alias wieder?",
                answer:
                  "Mit unalias <name> kann man einen Alias löschen. Beispiel: unalias ll würde den zuvor gesetzten Alias ll entfernen, sodass der Name wieder frei ist bzw. ein eventuell vorhandenes Systemalias aktiv würde.",
                commands: ["unalias"],
              },
              {
                question:
                  "Wie kann ich Umgebungsvariablen setzen und anzeigen?",
                answer:
                  'Umweltvariablen werden in der Form NAME=Wert gesetzt. Dies gilt zunächst nur für die laufende Shell. Mit export NAME=Wert macht man die Variable auch für Subprozesse verfügbar. Anzeigen kann man einzelne Variablen mit echo $NAME. Alle aktuell definierten Variablen zeigt printenv oder env an. Beispiel: export PATH="$PATH:/opt/meinprogramm/bin" hängt /opt/meinprogramm/bin an die PATH-Variable an (erweitert den Suchpfad für Befehle).',
                commands: ["export", "env"],
              },
              {
                question: "Wie führe ich ein Shell-Skript aus?",
                answer:
                  "Angenommen, man hat ein Skript script.sh erstellt: Zunächst muss es ausführbar sein (chmod +x script.sh). Starten kann man es dann mit ./script.sh (wenn sich das Skript im aktuellen Verzeichnis befindet). Alternativ kann man es einem Interpreter übergeben, z. B. bash script.sh. Wichtig: In der ersten Zeile eines Skripts steht oft ein Shebang (z. B. #!/bin/bash), um festzulegen, welche Shell/Interpreter das Skript ausführen soll.",
                commands: ["chmod"],
              },
              {
                question:
                  "Wie kann ich einen gerade laufenden Befehl abbrechen?",
                answer:
                  "Durch Drücken von Strg + C (Control + C) im Terminal wird das aktuelle Vordergrund-Programm sofort beendet. Dies sendet das SIGINT-Signal an den Prozess. Beispiel: Wenn ping endlos läuft, beendet Strg+C den Vorgang und gibt eine Zusammenfassung aus.",
                commands: [],
              },
              {
                question:
                  "Wie halte ich einen laufenden Prozess an und lasse ihn im Hintergrund weiterlaufen?",
                answer:
                  "Mit Strg + Z kann man einen laufenden Prozess anhalten (pausieren). Die Shell gibt dann eine Job-Nummer aus. Mit dem Befehl bg schickt man diesen angehaltenen Job in den Hintergrund (Background), sodass er weiterläuft, aber die Shell wieder bereit ist. Den Status aller Jobs sieht man mit jobs. Um einen Hintergrundjob wieder in den Vordergrund zu holen, verwendet man fg %Jobnummer (z. B. fg %1).",
                commands: ["bg", "fg", "jobs"],
              },
              {
                question:
                  "Wie verlasse ich die Shell bzw. schließe das Terminal?",
                answer:
                  "Mit dem Befehl exit beendet man die aktuelle Shell-Sitzung. Falls es die letzte Shell in dem Terminalfenster war, schließt sich dadurch das Terminal. Alternativ kann man auch Strg + D drücken (EOF senden), was ebenfalls die Shell beendet.",
                commands: ["exit"],
              },
            ],
          },
          {
            category: "Fehlermeldungen und ihre Behebung",
            questions: [
              {
                question:
                  'Fehlermeldung: "command not found" – was bedeutet das und was kann ich tun?',
                answer:
                  '"Command not found" bedeutet, dass die Shell den eingegebenen Befehl nicht finden konnte. Häufige Ursachen: Tippfehler im Befehlsnamen oder das Programm ist nicht installiert bzw. nicht im PATH. Zuerst sollte man prüfen, ob man sich nicht vertippt hat. Ist der Name korrekt, überprüft man mit which befehl, ob das Programm im Suchpfad liegt (gibt z. B. /usr/bin/befehl zurück). Falls which nichts ausgibt, muss das Programm ggf. installiert werden (z. B. via sudo apt install <paket>). Bei Shell-internen Befehlen (wie cd) kann die Meldung erscheinen, wenn man sie in falschem Kontext nutzt. In seltenen Fällen ist die PATH-Variable beschädigt oder leer, sodass selbst grundlegende Befehle nicht gefunden werden. Dann sollte man echo $PATH prüfen und gegebenenfalls die Standard-Pfade (/usr/bin, /bin, etc.) wiederherstellen. Zusammengefasst: "command not found" = entweder Tippfehler, Programm fehlt oder PATH-Problem.',
                commands: ["which"],
              },
              {
                question:
                  'Fehlermeldung: "Permission denied" – warum tritt sie auf und wie löse ich das?',
                answer:
                  "Diese Meldung erscheint, wenn die Berechtigungen nicht ausreichen, um eine Aktion durchzuführen. Man löst es, indem man entweder die notwendigen Rechte erlangt oder die Datei-Berechtigungen ändert. Beispiele: Beim Öffnen einer Datei Permission denied – entweder sudo verwenden (wenn Administratorrechte nötig sind) oder chmod nutzen, um die Datei für den eigenen Benutzer zugänglich zu machen. Oder man versucht, in ein Verzeichnis zu wechseln, hat aber keine Ausführungsrechte auf den Ordner – dann muss man chmod +x auf das Verzeichnis anwenden. Generell: Permission denied kann durch sudo umgangen werden, wenn es um Root-Rechte geht (aber vorsicht, nur bei vertrauenswürdigen Befehlen nutzen), oder durch Anpassen der Dateirechte mit chmod bzw. Eigentümerwechsel mit chown, falls man Zugriff benötigt.",
                commands: ["sudo", "chmod", "chown"],
              },
              {
                question:
                  'Fehlermeldung: "No such file or directory" – was läuft falsch?',
                answer:
                  "Diese Meldung bedeutet, dass eine angegebene Datei oder Pfad nicht existiert. Entweder wurde der Pfad falsch eingegeben (Tippfehler, Groß-/Kleinschreibung beachten, da Linux case-sensitiv ist) oder das Objekt ist tatsächlich nicht vorhanden. Lösung: Pfadangabe überprüfen (ls im betreffenden Verzeichnis ausführen, Tab-Autocomplete nutzen) und ggf. korrigieren. Bei ausführbaren Programmen kann es auch bedeuten, dass das Programm zwar vorhanden ist, aber eine benötigte Bibliothek fehlt oder der Shebang-Pfad im Skript ungültig ist (z. B. Skript beginnt mit #!/bin/python statt /usr/bin/python). Dann muss man den Pfad anpassen oder die fehlende Komponente installieren.",
                commands: ["ls"],
              },
              {
                question:
                  "Mein Terminal zeigt sonderbare Zeichen an oder reagiert nicht richtig – was kann ich tun?",
                answer:
                  'Manchmal gerät das Terminal durch Binärausgaben oder versehentliche stty-Änderungen durcheinander. Mit dem Befehl reset kann man das Terminal in einen definierten Zustand zurücksetzen. Falls nur Eingaben unsichtbar sind (passiert z. B. nach cat /dev/urandom), hilft oft auch echo -e "\\033c". Ein einfacher Trick ist zudem, einen neuen Prompt zu erzwingen: Drücke Ctrl+J gefolgt von reset und wieder Enter (falls Enter alleine nicht mehr erkannt wird).',
                commands: ["reset"],
              },
              {
                question:
                  "Ein Befehl läuft endlos und reagiert nicht – was soll ich machen?",
                answer:
                  "Mit Strg + C (Control-C) bricht man den laufenden Prozess ab. Sollte auch das nicht gehen (sehr selten), kann man in einem anderen Terminal sudo killall <prozessname> oder sudo kill <PID> ausführen, um den Prozess zu beenden. In grafischen Desktop-Sitzungen gibt es auch den System Monitor oder htop, um Prozesse abzuschießen. In der Regel reicht jedoch Strg+C, um einen hängenden Prozess zu stoppen.",
                commands: ["kill", "killall"],
              },
              {
                question:
                  "Nach der Anmeldung sehe ich nur $ anstelle von kali@...$ und Befehle wie ls funktionieren nicht. Was ist passiert?",
                answer:
                  'Ein Prompt, der nur $ anzeigt, deutet darauf hin, dass man möglicherweise in der sh-Shell (oder Dash) statt in Bash gelandet ist, oder dass die Shell-Initialisierung nicht vollständig lief. Wenn dann gängige Befehle wie ls "command not found" ergeben, kann es sein, dass die PATH-Variable nicht gesetzt ist. Lösung: Versuchen, mit exec bash oder bash --login in eine Bash zu wechseln. Prüfen, ob Konfigurationsdateien wie ~/.bashrc oder ~/.profile versehentlich verändert wurden. Ggf. temporär export PATH=/usr/bin:/bin setzen, damit wichtigste Befehle wieder gefunden werden, dann die Shell-Startdateien reparieren.',
                commands: ["bash"],
              },
            ],
          },
          {
            category: "Systeminformationen und -überwachung",
            questions: [
              {
                question:
                  "Wie finde ich heraus, welche Linux-Version und Kernel-Version ich benutze?",
                answer:
                  "Mit uname -a erhält man einen Überblick über Systemname, Kernel-Version, Architektur usw. Beispielausgabe: Linux kali 6.5.0-kali1-amd64 #1 SMP Debian 6.5.5-1kali1 (2023-10-10) x86_64 GNU/Linux. Für die Distribution kann man auch lsb_release -a verwenden, das z. B. Kali-Version und Codename anzeigt.",
                commands: ["uname", "lsb_release"],
              },
              {
                question:
                  "Wie kann ich die Hardware-Informationen meines Systems anzeigen?",
                answer:
                  "Einige nützliche Befehle: lscpu zeigt CPU-Details (Anzahl Kerne, Modell, Flags), lsusb listet USB-Geräte auf, lspci PCI-Geräte. Für den Arbeitsspeicher grep MemTotal /proc/meminfo. Kali bringt auch neofetch mit, das eine kompakte Systemübersicht mit ASCII-Logo ausgeben kann (inkl. OS, Kernel, CPU, RAM etc.).",
                commands: ["lscpu", "lsusb", "lspci"],
              },
              {
                question:
                  "Wie überwache ich die aktuelle Auslastung der CPU und des RAM?",
                answer:
                  "Mit top erhält man eine dynamische Live-Ansicht der laufenden Prozesse und ihrer CPU-/Speicherauslastung. Oben zeigt top außerdem Gesamtwerte für CPU (in %), RAM und Swap an. Ein besser lesbares, alternatives Tool ist htop (falls installiert). Wenn es nur um einen Schnappschuss geht: uptime zeigt die Load Average an (Durchschnittslast) und free -h den aktuellen belegten/freien Speicher.",
                commands: ["top", "htop", "uptime", "free"],
              },
              {
                question: "Wie sehe ich, wie lange mein System schon läuft?",
                answer:
                  "Der Befehl uptime gibt die aktuelle Uhrzeit, die Systemlaufzeit (seit dem letzten Start), die Anzahl eingeloggter Benutzer und die durchschnittliche Last an. Beispiel: 17:30:45 up 2:15, 1 user, load average: 0.05, 0.10, 0.09 bedeutet das System läuft seit 2 Stunden 15 Minuten.",
                commands: ["uptime"],
              },
              {
                question:
                  "Wie prüfe ich, wie viel Festplattenplatz belegt bzw. frei ist?",
                answer:
                  "Dafür verwendet man df -h. df (disk free) listet alle eingehängten Dateisysteme mit genutztem und freiem Speicherplatz; die Option -h zeigt die Werte in menschenlesbarer Form (KiB/ MiB/ GiB). Man sieht z. B., wie voll die Root-Partition ist. Möchte man den Speicherverbrauch eines bestimmten Verzeichnisses wissen, benutzt man du -sh <verzeichnis> (disk usage, -s summarisch für das Verzeichnis, -h human-readable).",
                commands: ["df", "du"],
              },
              {
                question:
                  "Wie kann ich bestimmte Prozessinformationen abrufen?",
                answer:
                  'Mit ps aux lassen sich alle laufenden Prozesse auflisten (mit User, PID, CPU/RAM-Verbrauch etc.). Möchte man nach einem bestimmten Prozess filtern, kann man ps aux | grep name nutzen. Detaillierte Infos zu einem Prozess liefert ps -p <PID> -o alles, wobei man anstelle von "alles" spezifische Felder angeben kann (siehe man ps). Für einen Echtzeit-Überblick siehe top oder htop (vorher genannt).',
                commands: ["ps"],
              },
              {
                question: "Wie kann ich System-Logs einsehen?",
                answer:
                  "Log-Dateien liegen meist unter /var/log/. Wichtige Logs sind z. B. /var/log/syslog (Systemmeldungen), /var/log/auth.log (Anmeldungen und sudo), dmesg (Kernel-Meldungen, auslesbar mit dem Befehl dmesg). Man kann diese Dateien mit tail -f <logdatei> live mitlesen oder mit grep durchsuchen. Kali nutzt systemd, daher ist auch journalctl -xe nützlich, um aktuelle Fehlermeldungen im System-Log zu sehen.",
                commands: ["tail", "dmesg", "journalctl"],
              },
            ],
          },
          {
            category: "Nützliche Tools und Befehle",
            questions: [
              {
                question: "Wie verwende ich Nmap, um mein Netzwerk zu scannen?",
                answer:
                  "Nmap ist ein Netzwerkscanner. Einige Beispiele: – Ping-Scan: nmap -sn 192.168.1.0/24 pingt ein ganzes Netz (hier 192.168.1.0 bis 192.168.1.255) an und listet aktive Hosts. – Port-Scan: nmap 192.168.1.100 scannt die häufigsten 1000 TCP-Ports auf Host .100. Mit -p 1-65535 kann man alle Ports scannen, mit -sU UDP-Ports. – Service-/OS-Scan: nmap -sV -O 192.168.1.100 versucht, Dienste-Versionen und das Betriebssystem des Ziels zu erkennen. Nmap bietet sehr umfangreiche Möglichkeiten, einschließlich Skripte (-sC) und aggressivere Scans (-A). Für den Einstieg liefert jedoch ein einfacher Portscan schon viel Information über offene Ports und Dienste.",
                commands: ["nmap"],
              },
              {
                question:
                  "Wofür wird Netcat (nc) verwendet und wie funktioniert es?",
                answer:
                  'Netcat ist ein vielseitiges Tool für die Netzwerkkommunikation – oft bezeichnet als "Schweizer Taschenmesser" der TCP/UDP-Tools. Beispiele: – Port-Check/Portscan: nc -zv <host> <port> prüft, ob ein bestimmter Port auf einem Host offen ist (z. B. nc -zv 192.168.1.1 80 prüft Port 80). – Listener aufsetzen: nc -l -p 4444 lauscht auf Port 4444 auf eingehende Verbindungen (ein rudimentärer Server). – Client verbinden: nc <ip> 4444 verbindet zu einem solchen Listener. Alles was eine Seite tippt, wird zur anderen übertragen – so kann man z. B. einen einfachen Chat oder Datentransfer realisieren. – Dateitransfer: Auf Empfängerseite: nc -l -p 5555 > received.file und auf Senderseite: nc <ip> 5555 < file.to.send – so wird file.to.send per Netcat übertragen. Netcat kann noch mehr, inkl. Port-Weiterleitungen und Banner-Grabbing. Da Netcat keine Verschlüsselung bietet, sollte es in sicheren Netzwerken oder zu Testzwecken verwendet werden.',
                commands: ["nc", "netcat"],
              },
              {
                question:
                  "Wie kann ich Dateien von einem Webserver herunterladen (Wget)?",
                answer:
                  "wget ist ein einfaches Download-Tool. Beispiel: wget https://downloads.kali.org/tool.deb lädt die Datei tool.deb herunter. Standardmäßig speichert wget im aktuellen Verzeichnis und zeigt einen Fortschritt an. Es unterstützt viele Parameter, z. B. -c zum Fortsetzen abgebrochener Downloads oder -r für rekursives Herunterladen von Websites.",
                commands: ["wget"],
              },
              {
                question:
                  "Wie kann ich HTTP-Anfragen stellen oder APIs testen (cURL)?",
                answer:
                  'cURL ist sehr mächtig für Webanfragen: – Eine einfache GET-Anfrage: curl http://api.icndb.com/jokes/1 ruft z. B. eine Joke-API auf und gibt JSON aus. – Datei herunterladen: curl -O http://example.com/file.txt funktioniert ähnlich wie wget (speichert unter gleichem Namen). – POST-Anfrage senden: curl -d "user=test&pass=123" -X POST http://example.com/login sendet Formulardaten via POST. – Header anzeigen: curl -I http://example.com zeigt nur die HTTP-Header an (Kopfzeilen der Antwort). cURL eignet sich somit, um Web-APIs zu testen, Dateien zu laden oder generell mit Webservices zu interagieren. (Tipp: Mit Option -v sieht man detaillierte Request/Response, mit -H kann man Header setzen usw.)',
                commands: ["curl"],
              },
              {
                question:
                  "Wie öffne ich eine sichere Shell-Verbindung zu einem anderen Rechner (SSH)?",
                answer:
                  "Mit dem ssh-Befehl. Syntax: ssh <benutzer>@<hostname>. Beispiel: ssh root@192.168.0.10 stellt eine SSH-Verbindung zum Host 192.168.0.10 als Benutzer root her (es wird nach dem Passwort gefragt, sofern kein Key genutzt wird). Über SSH kann man Befehle auf dem entfernten System ausführen und hat eine verschlüsselte Terminalsession. Für Key-basierten Login verwendet man die Option -i /Pfad/zum/Schlüssel. Standard läuft SSH auf Port 22; falls der Server einen anderen Port nutzt, kann man mit -p <Port> einen abweichenden Port angeben.",
                commands: ["ssh"],
              },
              {
                question:
                  "Welche weiteren nützlichen Hacking-Tools bringt Kali Linux mit?",
                answer:
                  "Kali ist vollgepackt mit Security-Tools. Einige Beispiele: – sqlmap: Automatisches SQL-Injection-Tool zum Auffinden und Exploitieren von SQL-Injection-Schwachstellen. – hydra: Passwort-Cracking-Tool für Online-Dienste (Brute-Force auf Login z. B. FTP, HTTP, SSH). – aircrack-ng: Suite zum Knacken von WLAN-Verschlüsselungen (WEP/WPA Handshakes). – burpsuite: Plattform zum Testen von Webanwendungen (Proxy zum Manipulieren von HTTP(S)-Traffic, Scanner etc.). – metasploit-framework: Umfangreiches Exploit-Framework zum Durchführen von Penetrationstests. – Wireshark: Grafischer Netzwerk-Sniffer/Protokoll-Analyzer zum Mitschneiden und Analysieren von Netzwerkverkehr. Diese Tools sind meist für fortgeschrittene Anwender – Anfänger sollten sich zunächst mit den Grundlagen der Linux-CLI vertraut machen, bevor sie diese einsetzen. Dennoch gehört es zum Kali-Einstieg dazu, zumindest zu wissen, dass diese Tools existieren und wofür sie da sind.",
                commands: ["sqlmap", "hydra", "aircrack-ng"],
              },
              {
                question:
                  "Wie kann ich herausfinden, wo ein bestimmtes Programm liegt?",
                answer:
                  'Mit which <befehl> zeigt die Shell den Pfad zur auszuführenden Datei an, die dem Befehl entspricht. Beispiel: which nmap gibt z. B. /usr/bin/nmap aus. Existiert der Befehl nicht (oder ist kein externer Befehl sondern Shell-intern), gibt which nichts aus. Für Shell-Builtins kann type <name> weiterhelfen (z. B. type cd sagt "cd is a shell builtin").',
                commands: ["which", "type"],
              },
              {
                question: "Wie bekomme ich Hilfe zu Befehlen (Man-Pages)?",
                answer:
                  "Linux bietet zu den meisten Befehlen Handbuchseiten. Mit man <befehl> öffnet man die Manual-Page zum jeweiligen Befehl. Diese enthalten Beschreibung, Aufrufsyntax, Optionen und oft Beispiele. Beispiel: man ls erklärt alle Optionen von ls. Mit Q verlässt man die man-Page wieder. Alternativ zeigen viele Befehle mit --help eine Kurzinfo an, z. B. ls --help.",
                commands: ["man"],
              },
            ],
          },
        ];

        // Konvertiere in finale Struktur
        const categories = [];
        const commandToFaqMap = {};

        faqRawData.forEach((categoryData) => {
          const categoryInfo = categoryMap[categoryData.category];
          if (!categoryInfo) return;

          const questions = categoryData.questions.map((q, index) => {
            const questionId = `${categoryInfo.id}-${String(index + 1).padStart(
              3,
              "0"
            )}`;
            const relatedCommands = q.commands || [];

            // Erstelle Tags aus Commands und Frage-Text
            const tags = [
              ...relatedCommands,
              ...q.question
                .toLowerCase()
                .split(/\s+/)
                .filter((word) => word.length > 3),
            ].slice(0, 5);

            // Füge zu commandToFaqMap hinzu
            relatedCommands.forEach((cmd) => {
              const normalizedCmd = cmd.toLowerCase().replace(/\s+/g, "_");
              if (!commandToFaqMap[normalizedCmd]) {
                commandToFaqMap[normalizedCmd] = [];
              }
              if (!commandToFaqMap[normalizedCmd].includes(questionId)) {
                commandToFaqMap[normalizedCmd].push(questionId);
              }
            });

            return {
              id: questionId,
              question: q.question,
              answer: q.answer,
              relatedCommands: relatedCommands,
              tags: tags,
            };
          });

          categories.push({
            id: categoryInfo.id,
            name: categoryInfo.name,
            icon: categoryInfo.icon,
            questions: questions,
          });
        });

        return {
          categories: categories,
          commandToFaqMap: commandToFaqMap,
        };
      }

      // Initialisiere FAQ-Daten
      const faqData = parseFaqData();

      // Parse Kali Tools Content
      function parseKaliToolsContent() {
        return [
          {
            title: "Grund-Setup nach Installation",
            items: [
              {
                name: "System aktualisieren",
                command: "sudo apt update && sudo apt full-upgrade -y",
                description:
                  "Aktualisiert alle Pakete und das System auf den neuesten Stand.",
                benefit:
                  "Stellt sicher, dass alle Tools aktuell und sicherheitsrelevante Updates installiert sind.",
                example:
                  "Nach der Installation von Kali Linux sollte dies dein erster Befehl sein. Führt eine vollständige Systemaktualisierung durch und installiert alle verfügbaren Updates für maximalen Schutz und Kompatibilität.",
                badgeRequired: null,
                difficulty: "easy",
              },
              {
                name: "Kali-Tweaks",
                command: "sudo kali-tweaks",
                description:
                  "Interaktives Konfigurationstool für Shell, Mirrors, VM-Optimierungen und Hardening.",
                benefit:
                  "Ermöglicht schnelle Systemoptimierung ohne manuelle Konfiguration mehrerer Dateien.",
                example:
                  "Öffnet ein interaktives Menü, in dem du Shell-Einstellungen (z.B. Zsh), Repository-Mirrors, VM-Optimierungen und Sicherheits-Hardening-Optionen konfigurieren kannst. Perfekt für eine schnelle Erstkonfiguration.",
                badgeRequired: null,
                difficulty: "easy",
              },
              {
                name: "Firewall einrichten (UFW)",
                command:
                  "sudo apt install ufw\nsudo ufw default deny incoming\nsudo ufw default allow outgoing\nsudo ufw enable",
                description:
                  "Konfiguriert eine einfache Firewall: blockiert eingehende, erlaubt ausgehende Verbindungen.",
                benefit:
                  "Grundlegender Schutz vor unerwünschten Netzwerkzugriffen während Pentesting-Aktivitäten.",
                example:
                  "Installiert und konfiguriert UFW (Uncomplicated Firewall): Blockiert standardmäßig alle eingehenden Verbindungen, erlaubt aber alle ausgehenden. Überprüfe den Status mit 'sudo ufw status'.",
                badgeRequired: null,
                difficulty: "easy",
              },
            ],
          },
          {
            title: "Wichtige Metapackages",
            items: [
              {
                name: "kali-linux-top10",
                command: "sudo apt install kali-linux-top10",
                description:
                  "Installiert die 10 wichtigsten Standardtools von Kali Linux in einem Paket.",
                benefit:
                  "Perfekt für Einsteiger – installiert automatisch die essentiellen Tools, die du am häufigsten brauchst.",
                example:
                  "Installiert in einem Schritt: Nmap, Wireshark, Metasploit, Aircrack-ng, Burp Suite, John the Ripper, Hydra, sqlmap, OWASP ZAP und Social Engineering Toolkit. Perfekt für den Start!",
                badgeRequired: "segment1",
                difficulty: "medium",
              },
              {
                name: "kali-linux-default",
                command: "sudo apt install kali-linux-default",
                description:
                  "Vollständige Desktop-Grundausstattung mit allen Standardtools.",
                benefit:
                  "Ideal für eine komplette Kali-Installation mit allen wichtigen Tools auf einmal.",
                example:
                  "Installiert alle Standard-Pentesting-Tools die in Kali Linux enthalten sind. Ideal für eine vollständige Installation, benötigt aber mehr Speicherplatz und Zeit.",
                badgeRequired: "segment1",
                difficulty: "medium",
              },
              {
                name: "kali-tools-web",
                command: "sudo apt install kali-tools-web",
                description:
                  "Tool-Sammlung speziell für Web-Pentesting und Web-Anwendungs-Tests.",
                benefit:
                  "Konzentriert alle Web-Testing-Tools an einem Ort – effizient für Web-Sicherheitstests.",
                example:
                  "Installiert Tools wie Burp Suite, OWASP ZAP, sqlmap, Nikto, dirb, wpscan und viele weitere Web-Pentesting-Tools. Ideal wenn du dich auf Web-Anwendungstests spezialisierst.",
                badgeRequired: "segment3",
                difficulty: "advanced",
              },
              {
                name: "kali-tools-802-11",
                command: "sudo apt install kali-tools-802-11",
                description:
                  "Tools für WLAN-Sicherheitstests und Wireless-Netzwerk-Analyse.",
                benefit:
                  "Unverzichtbar für Wireless-Pentesting – alles was du für WLAN-Tests brauchst.",
                example:
                  "Installiert Aircrack-ng Suite, Reaver, Wifite, Fern WiFi Cracker und weitere WLAN-Testing-Tools. Erfordert eine kompatible WLAN-Karte mit Monitor-Mode-Unterstützung.",
                badgeRequired: "segment5",
                difficulty: "expert",
              },
              {
                name: "kali-tools-reverse-engineering",
                command: "sudo apt install kali-tools-reverse-engineering",
                description:
                  "Umfangreiche Toolsammlung für Reverse Engineering und Exploit-Entwicklung.",
                benefit:
                  "Für fortgeschrittene Sicherheitsforschung und Malware-Analyse essentiell.",
                example:
                  "Installiert Tools wie Ghidra, Radare2, IDA Free, Binary Ninja, APKTool, JD-GUI und weitere Reverse-Engineering-Tools. Für Malware-Analyse und Exploit-Entwicklung.",
                badgeRequired: "segment5",
                difficulty: "expert",
              },
            ],
          },
          {
            title: "Netzwerk & Reconnaissance",
            items: [
              {
                name: "Nmap",
                command: "sudo apt install nmap",
                description:
                  "Der Standard-Portscanner zum Erkunden von Netzwerken und offenen Ports.",
                benefit:
                  "Das wichtigste Tool für Netzwerk-Reconnaissance – zeigt dir alle erreichbaren Dienste auf.",
                example:
                  "Beispiel: 'nmap -sV -p 80,443 192.168.1.1' scannt die Ports 80 und 443 auf einem Host und versucht die Dienstversionen zu identifizieren. 'nmap -sn 192.168.1.0/24' führt einen Ping-Scan eines ganzen Netzwerks durch.",
                badgeRequired: "segment1",
                difficulty: "medium",
              },
              {
                name: "Wireshark",
                command: "sudo apt install wireshark",
                description:
                  "GUI-basierter Netzwerk-Protokoll-Analysator für tiefgreifende Traffic-Analyse.",
                benefit:
                  "Unverzichtbar zum Verstehen von Netzwerk-Kommunikation und zum Identifizieren von Anomalien.",
                example:
                  "Starte Wireshark mit 'wireshark' (GUI) oder verwende 'tshark' (CLI). Fange Traffic auf einer Netzwerkschnittstelle ab, filtere nach Protokollen (z.B. 'http' oder 'tcp.port == 80') und analysiere Pakete im Detail.",
                badgeRequired: "segment1",
                difficulty: "medium",
              },
            ],
          },
          {
            title: "Web & Dienste",
            items: [
              {
                name: "Burp Suite Community",
                command: "sudo apt install burpsuite",
                description:
                  "HTTP/HTTPS-Proxy zum Abfangen und Manipulieren von Web-Anfragen.",
                benefit:
                  "Das Standard-Tool für Web-Pentesting – ermöglicht detaillierte Analyse und Exploitation von Web-Apps.",
                example:
                  "Starte Burp Suite mit 'burpsuite'. Konfiguriere deinen Browser auf localhost:8080 als Proxy. Alle HTTP/HTTPS-Requests werden abgefangen. Verwende den Repeater um Anfragen zu manipulieren, den Intruder für Bruteforce-Angriffe oder den Scanner für automatische Schwachstellensuche.",
                badgeRequired: "segment3",
                difficulty: "advanced",
              },
              {
                name: "sqlmap",
                command: "sudo apt install sqlmap",
                description:
                  "Automatisiertes Tool zum Testen und Exploitieren von SQL-Injection-Schwachstellen.",
                benefit:
                  "Spart enorm Zeit bei SQL-Injection-Tests und zeigt dir direkt verwertbare Exploits.",
                example:
                  "Beispiel: 'sqlmap -u \"http://example.com/page?id=1\" --dbs' testet auf SQL-Injection und listet Datenbanken auf. Mit '--dump -D database_name -T table_name' kannst du Tabellen auslesen. '--os-shell' versucht eine interaktive Shell zu erhalten.",
                badgeRequired: "segment3",
                difficulty: "advanced",
              },
            ],
          },
          {
            title: "Exploitation",
            items: [
              {
                name: "Metasploit Framework",
                command: "sudo apt install metasploit-framework",
                description:
                  "Umfassendes Framework für Exploit-Entwicklung, -Testing und Post-Exploitation.",
                benefit:
                  "Das mächtigste Exploitation-Tool – bietet tausende vorgefertigte Exploits und Payloads.",
                example:
                  "Starte msfconsole mit 'msfconsole'. Suche nach Exploits mit 'search [dienst]', z.B. 'search apache'. Nutze einen Exploit mit 'use exploit/...', setze Parameter mit 'set RHOSTS 192.168.1.1', und führe aus mit 'exploit'. Mit 'show payloads' siehst du verfügbare Payloads.",
                badgeRequired: "segment5",
                difficulty: "expert",
              },
            ],
          },
          {
            title: "Passwörter & Credentials",
            items: [
              {
                name: "Hydra",
                command: "sudo apt install hydra",
                description:
                  "Bruteforce-Tool für Passwörter und verschiedene Netzwerkdienste (SSH, FTP, HTTP, etc.).",
                benefit:
                  "Ermöglicht schnelles Testen von Login-Credentials gegen verschiedene Dienste.",
                example:
                  "Beispiel SSH: 'hydra -l admin -P passwords.txt ssh://192.168.1.1' testet das Passwort 'admin' mit einer Passwortliste. Für HTTP-Basic-Auth: 'hydra -l admin -P passwords.txt http-get://192.168.1.1/login'. Verwende 'hydra -h' für alle Optionen.",
                badgeRequired: "segment3",
                difficulty: "advanced",
              },
              {
                name: "John the Ripper",
                command: "sudo apt install john",
                description:
                  "Schneller Passwort-Cracker für offline Hash-Cracking und Passwort-Analyse.",
                benefit:
                  "Effizient beim Knacken gehashter Passwörter – unterstützt viele Hash-Algorithmen.",
                example:
                  "Speichere Hashes in einer Datei (z.B. hashes.txt). Verwende 'john hashes.txt' für Standard-Cracking. Mit 'john --wordlist=passwords.txt hashes.txt' verwendest du eine Passwortliste. 'john --show hashes.txt' zeigt geknackte Passwörter an.",
                badgeRequired: "segment4",
                difficulty: "advanced",
              },
            ],
          },
          {
            title: "WLAN (optional)",
            items: [
              {
                name: "Aircrack-ng Suite",
                command: "sudo apt install aircrack-ng",
                description:
                  "Komplett-Suite für WLAN-Sicherheitstests: Sniffing, Cracking, Angriffe auf WLAN-Netzwerke.",
                benefit:
                  "Das Standard-Tool für Wireless-Pentesting – von Netzwerk-Analyse bis Passwort-Cracking.",
                example:
                  "Workflow: 1) 'airmon-ng start wlan0' aktiviert Monitor-Mode, 2) 'airodump-ng wlan0mon' listet WLAN-Netzwerke, 3) 'airodump-ng -c [Kanal] --bssid [MAC] -w capture wlan0mon' fängt Handshakes ab, 4) 'aircrack-ng -w wordlist.txt capture.cap' crackt das Passwort. Benötigt kompatible WLAN-Karte.",
                badgeRequired: "segment5",
                difficulty: "expert",
              },
            ],
          },
          {
            title: "Shell & Workflow",
            items: [
              {
                name: "Zsh",
                command: "sudo apt install zsh",
                description:
                  "Erweiterte Shell mit besserer Autovervollständigung, Plugins und Themes.",
                benefit:
                  "Verbessert deine Produktivität drastisch – besonders mit Oh My Zsh für Customization.",
                example:
                  "Nach Installation: 'chsh -s $(which zsh)' setzt Zsh als Standard-Shell. Installiere Oh My Zsh mit: 'sh -c \"$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"'. Konfiguriere Plugins und Themes in ~/.zshrc.",
                badgeRequired: "segment1",
                difficulty: "medium",
              },
              {
                name: "tmux",
                command: "sudo apt install tmux",
                description:
                  "Terminal-Multiplexer zum Splitten von Terminal-Fenstern und Session-Management.",
                benefit:
                  "Ermöglicht paralleles Arbeiten mit mehreren Terminal-Sessions – essentiell für komplexe Pentests.",
                example:
                  "Starte tmux mit 'tmux'. Tastenkombinationen (Standard-Präfix: Ctrl+b): Split horizontal 'C-b %', split vertikal 'C-b \"', wechsle zwischen Panes mit 'C-b Pfeiltasten', erstelle neues Fenster 'C-b c', liste Sessions 'tmux ls', attach Session 'tmux attach -t [name]'.",
                badgeRequired: "segment2",
                difficulty: "medium",
              },
            ],
          },
          {
            title: "Entwicklungsumgebung",
            items: [
              {
                name: "Git",
                command: "sudo apt install git",
                description:
                  "Versionskontroll-System für Code- und Script-Verwaltung.",
                benefit:
                  "Unverzichtbar für Organisierung deiner Exploits, Scripts und Pentesting-Tools.",
                example:
                  "Konfiguriere Git: 'git config --global user.name \"Dein Name\"' und 'git config --global user.email \"email@example.com\"'. Erstelle Repo: 'git init', füge Dateien hinzu: 'git add .', committe: 'git commit -m \"Message\"', klone Repos: 'git clone https://github.com/user/repo.git'.",
                badgeRequired: "segment1",
                difficulty: "medium",
              },
              {
                name: "curl",
                command: "sudo apt install curl",
                description:
                  "Kommandozeilen-Tool für HTTP/HTTPS-Anfragen und API-Testing.",
                benefit:
                  "Schnelle Möglichkeit Web-Requests zu testen und API-Endpunkte zu analysieren.",
                example:
                  "Einfacher GET-Request: 'curl http://example.com'. POST mit Daten: 'curl -X POST -d \"key=value\" http://example.com/api'. Mit Headers: 'curl -H \"Authorization: Bearer token\" http://example.com/api'. Output speichern: 'curl -o file.html http://example.com'.",
                badgeRequired: "segment2",
                difficulty: "medium",
              },
              {
                name: "build-essential",
                command: "sudo apt install build-essential",
                description:
                  "Grundlegende Compiler und Build-Tools (gcc, make, etc.) für Software-Kompilierung.",
                benefit:
                  "Benötigt um viele Exploits und Tools aus Source-Code zu kompilieren.",
                example:
                  "Enthält gcc (C-Compiler), g++ (C++-Compiler), make (Build-Automation) und weitere Entwickler-Tools. Nach Installation kannst du Source-Code kompilieren: 'gcc program.c -o program' oder 'make' in einem Projekt-Verzeichnis ausführen.",
                badgeRequired: "segment2",
                difficulty: "medium",
              },
              {
                name: "Neovim",
                command: "sudo apt install neovim",
                description:
                  "Moderner Vim-Editor mit verbesserter Plugin-Unterstützung und Konfiguration.",
                benefit:
                  "Ermöglicht effizientes Scripting und Code-Editieren direkt im Terminal.",
                example:
                  "Starte Neovim mit 'nvim datei.txt'. Basis-Befehle: Insert-Mode 'i', Normal-Mode ESC, speichern und beenden ':wq', speichern ':w', beenden ohne speichern ':q!'. Erweitere mit Plugins über Plugin-Manager wie vim-plug in ~/.config/nvim/init.vim.",
                badgeRequired: "segment2",
                difficulty: "medium",
              },
              {
                name: "kali-system-gui",
                command: "sudo apt install kali-system-gui",
                description:
                  "GUI-Werkzeuge und Desktop-Umgebungskomponenten für Kali Linux.",
                benefit:
                  "Stellt sicher, dass alle grafischen Tools und Desktop-Funktionen verfügbar sind.",
                example:
                  "Installiert alle GUI-Komponenten und Desktop-Umgebungstools für Kali Linux. Erforderlich wenn du grafische Tools wie Wireshark GUI, Burp Suite oder andere GUI-basierte Pentesting-Tools verwenden möchtest.",
                badgeRequired: "segment1",
                difficulty: "medium",
              },
            ],
          },
          {
            title: "Netzwerk, VPN & Remote",
            items: [
              {
                name: "OpenVPN / Wireguard",
                command: "sudo apt install openvpn wireguard",
                description:
                  "VPN-Lösungen für sichere, verschlüsselte Verbindungen zu Remote-Netzwerken.",
                benefit:
                  "Essentiell für sicheres Pentesting über das Internet und Zugriff auf isolierte Netzwerke.",
                example:
                  "OpenVPN: Verbinde dich mit 'sudo openvpn --config client.ovpn'. Wireguard: Konfiguriere in /etc/wireguard/wg0.conf, starte mit 'sudo wg-quick up wg0', stoppe mit 'sudo wg-quick down wg0'. Status prüfen: 'sudo wg show'.",
                badgeRequired: "segment2",
                difficulty: "medium",
              },
              {
                name: "SSH Server",
                command: "sudo apt install openssh-server",
                description:
                  "Ermöglicht Remote-Zugriff auf dein Kali-System via Secure Shell.",
                benefit:
                  "Ermöglicht Remote-Zugriff auf dein System – nützlich für Pentests von verschiedenen Standorten.",
                example:
                  "Nach Installation startet der SSH-Service automatisch. Verbinde dich von einem anderen System: 'ssh benutzer@kali-ip'. Mit SSH-Key-Authentifizierung: 'ssh-keygen -t rsa' erstellt Keys, 'ssh-copy-id benutzer@kali-ip' kopiert öffentlichen Key. SSH-Konfiguration in /etc/ssh/sshd_config.",
                badgeRequired: "segment1",
                difficulty: "medium",
              },
            ],
          },
        ];
      }

      // Open Hotkeys Modal
      function openHotkeysModal() {
        const modal = document.getElementById("hotkeys-root");
        const bodyEl = document.getElementById("hotkeys-body");

        if (!modal || !bodyEl) return;

        bodyEl.innerHTML = "";
        const sections = parseHotkeysContent();

        sections.forEach((section) => {
          const sectionDiv = document.createElement("div");
          sectionDiv.className = "hotkeys-section";

          const title = document.createElement("div");
          title.className = "hotkeys-section-title";
          title.textContent = section.title;
          sectionDiv.appendChild(title);

          section.items.forEach((item) => {
            const itemDiv = document.createElement("div");
            itemDiv.className = "hotkeys-item";
            itemDiv.innerHTML = `
              <span class="hotkeys-shortcut">${item.shortcut}</span>
              <span class="hotkeys-description">– ${item.description}</span>
            `;
            sectionDiv.appendChild(itemDiv);
          });

          bodyEl.appendChild(sectionDiv);
        });

        modal.classList.remove("hidden");
        modal.setAttribute("aria-hidden", "false");
      }

      // Close Hotkeys Modal
      function closeHotkeysModal() {
        const modal = document.getElementById("hotkeys-root");
        if (modal) {
          modal.classList.add("hidden");
          modal.setAttribute("aria-hidden", "true");
        }
      }

      // Open Kali Tools Modal
      function openKaliToolsModal() {
        const modal = document.getElementById("kali-tools-root");
        const bodyEl = document.getElementById("kali-tools-body");

        if (!modal || !bodyEl) return;

        bodyEl.innerHTML = "";
        const sections = parseKaliToolsContent();

        sections.forEach((section) => {
          const sectionDiv = document.createElement("div");
          sectionDiv.className = "kali-tools-section";

          const title = document.createElement("div");
          title.className = "kali-tools-section-title";
          title.textContent = section.title;
          sectionDiv.appendChild(title);

          section.items.forEach((item) => {
            const itemDiv = document.createElement("div");
            itemDiv.className = "kali-tools-item";

            // Check if item is locked
            const isUnlocked = checkBadgeUnlocked(item.badgeRequired);

            // Get badge info if required
            let badgeHtml = "";
            if (item.badgeRequired) {
              const segment = badgeSegments.find(
                (s) => s.id === item.badgeRequired
              );
              if (segment) {
                const progress = getSegmentProgress(item.badgeRequired);
                const totalQuizzes = segment.quizIds.length;
                badgeHtml = `<div class="kali-tools-item-badge" style="display: inline-flex; align-items: center; gap: 0.3rem; margin-bottom: 0.4rem; padding: 0.2rem 0.5rem; border-radius: 0.4rem; background: ${
                  isUnlocked
                    ? "rgba(34, 197, 94, 0.15)"
                    : "rgba(239, 68, 68, 0.15)"
                }; border: 1px solid ${
                  isUnlocked
                    ? "rgba(34, 197, 94, 0.4)"
                    : "rgba(239, 68, 68, 0.4)"
                }; font-size: 0.8rem;">
                  <span>${segment.icon}</span>
                  <span style="color: ${
                    isUnlocked ? "#86efac" : "#fca5a5"
                  }; font-weight: 500;">${segment.name}</span>
                  <span style="color: ${
                    isUnlocked ? "#86efac" : "#fca5a5"
                  }; opacity: 0.8; font-size: 0.75rem;">${progress}/${totalQuizzes}</span>
                </div>`;
              }
            }

            let html = badgeHtml;
            html += `<span class="kali-tools-name">${item.name}</span>`;
            html += `<div class="kali-tools-description">${item.description}</div>`;

            if (item.benefit) {
              html += `<div class="kali-tools-benefit">💡 ${item.benefit}</div>`;
            }

            if (item.command) {
              // Format multi-line commands
              const formattedCommand = item.command
                .split("\n")
                .map((line) => line.trim())
                .filter((line) => line.length > 0)
                .join("\n");

              // Add chicken button for command if locked
              let commandHtml = `<div class="kali-tools-command">${formattedCommand.replace(
                /\n/g,
                "<br>"
              )}</div>`;

              // Add unlock button for command section if locked
              if (!isUnlocked && item.badgeRequired) {
                commandHtml += `<div style="margin-top: 0.5rem;">
                  <button type="button" class="kali-tools-chicken-btn" data-tool-name="${item.name.replace(
                    /"/g,
                    "&quot;"
                  )}" data-segment-id="${
                  item.badgeRequired
                }" data-unlock-type="command" title="Klicken um Inhalt ohne Quiz freizuschalten">🐔 Freischalten</button>
                </div>`;
              }

              html += commandHtml;
            }

            // Add example with blur logic
            if (item.example) {
              const blurredClass = isUnlocked
                ? ""
                : "kali-tools-example-blurred";

              html += `<div class="kali-tools-example ${blurredClass}">`;
              html += `<div class="kali-tools-example-title">`;
              html += `📝 Anwendungsbeispiel`;
              if (!isUnlocked && item.badgeRequired) {
                html += `<button type="button" class="kali-tools-chicken-btn" data-tool-name="${item.name.replace(
                  /"/g,
                  "&quot;"
                )}" data-segment-id="${
                  item.badgeRequired
                }" data-unlock-type="example" title="Klicken um Inhalt ohne Quiz freizuschalten">🐔 Freischalten</button>`;
              }
              html += `</div>`;
              html += `<div class="kali-tools-example-content">${item.example}</div>`;
              html += `</div>`;
            }

            itemDiv.innerHTML = html;

            // Add data attribute for badge requirement
            if (item.badgeRequired) {
              itemDiv.setAttribute("data-badge-required", item.badgeRequired);
            }

            // Attach chicken button event handlers for all chicken buttons
            if (!isUnlocked && item.badgeRequired) {
              const chickenBtns = itemDiv.querySelectorAll(
                ".kali-tools-chicken-btn"
              );
              chickenBtns.forEach((chickenBtn) => {
                chickenBtn.addEventListener("click", (e) => {
                  e.stopPropagation();

                  // Unlock via chicken button
                  unlockBadgeViaChicken(item.badgeRequired);

                  // Remove blur from example if present
                  const exampleDiv = itemDiv.querySelector(
                    ".kali-tools-example"
                  );
                  if (exampleDiv) {
                    exampleDiv.classList.remove("kali-tools-example-blurred");
                  }

                  // Remove all chicken buttons from this item
                  const allChickenBtns = itemDiv.querySelectorAll(
                    ".kali-tools-chicken-btn"
                  );
                  allChickenBtns.forEach((btn) => {
                    const btnParent = btn.parentElement;
                    if (btnParent && btnParent.tagName === "DIV") {
                      btn.remove();
                    } else {
                      btn.remove();
                    }
                  });

                  // Update badge display in item
                  const segment = badgeSegments.find(
                    (s) => s.id === item.badgeRequired
                  );
                  if (segment) {
                    const progress = getSegmentProgress(item.badgeRequired);
                    const totalQuizzes = segment.quizIds.length;
                    const badgeDiv = itemDiv.querySelector(
                      ".kali-tools-item-badge"
                    );
                    if (badgeDiv) {
                      badgeDiv.style.background = "rgba(34, 197, 94, 0.15)";
                      badgeDiv.style.borderColor = "rgba(34, 197, 94, 0.4)";
                      const spans = badgeDiv.querySelectorAll("span");
                      spans.forEach((span) => {
                        if (!span.textContent.match(/[\u{1F300}-\u{1F9FF}]/u)) {
                          span.style.color = "#86efac";
                        }
                      });
                    }
                  }

                  // Update badges display in header
                  updateKaliToolsBadges();

                  // Re-render the entire modal to update all items
                  setTimeout(() => {
                    openKaliToolsModal();
                  }, 100);

                  // Show feedback
                  const feedback = document.createElement("div");
                  feedback.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: rgba(34, 197, 94, 0.9);
                    color: white;
                    padding: 1rem 1.5rem;
                    border-radius: 0.5rem;
                    z-index: 100;
                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                    animation: slideIn 0.3s ease-out;
                  `;
                  feedback.textContent = `🐔 Inhalt freigeschaltet!`;
                  document.body.appendChild(feedback);
                  setTimeout(() => {
                    feedback.style.animation = "slideOut 0.3s ease-out";
                    setTimeout(() => feedback.remove(), 300);
                  }, 2000);

                  // Open overlay for example if it was an example button
                  const unlockType =
                    chickenBtn.getAttribute("data-unlock-type");
                  if (unlockType === "example" && item.example) {
                    openExampleOverlay(item);
                  }
                });
              });
            }

            sectionDiv.appendChild(itemDiv);
          });

          bodyEl.appendChild(sectionDiv);
        });

        // Update badges display AFTER rendering content
        setTimeout(() => {
          updateKaliToolsBadges();
        }, 0);

        modal.classList.remove("hidden");
        modal.setAttribute("aria-hidden", "false");
      }

      // Close Kali Tools Modal
      function closeKaliToolsModal() {
        const modal = document.getElementById("kali-tools-root");
        if (modal) {
          modal.classList.add("hidden");
          modal.setAttribute("aria-hidden", "true");
        }
      }

      // Check if badge is unlocked (including chicken button unlocks)
      function checkBadgeUnlocked(segmentId) {
        if (!segmentId) return true; // No badge required = always unlocked

        // Check if unlocked via chicken button
        const chickenUnlocks = localStorage.getItem("kaliToolsChickenUnlocks");
        if (chickenUnlocks) {
          try {
            const unlocks = JSON.parse(chickenUnlocks);
            if (unlocks[segmentId]) return true;
          } catch (e) {
            // Ignore parse errors
          }
        }

        const stored = localStorage.getItem("badgeProgress");
        if (!stored) return false;

        try {
          const badgeProgress = JSON.parse(stored);
          const progress = badgeProgress[segmentId] || 0;

          // Find segment
          const segment = badgeSegments.find((s) => s.id === segmentId);
          if (!segment) return false;

          // Check if segment is complete (all quizzes done)
          const isComplete = progress >= segment.quizIds.length;

          // Check if master quiz is completed
          const masterStored = localStorage.getItem("masterQuizResults");
          if (masterStored) {
            try {
              const masterResults = JSON.parse(masterStored);
              if (masterResults[segmentId]) return true; // Master quiz completed = unlocked
            } catch (e) {
              // Ignore parse errors
            }
          }

          return isComplete;
        } catch (e) {
          return false;
        }
      }

      // Unlock badge via chicken button
      function unlockBadgeViaChicken(segmentId) {
        if (!segmentId) return;

        let unlocks = {};
        const stored = localStorage.getItem("kaliToolsChickenUnlocks");
        if (stored) {
          try {
            unlocks = JSON.parse(stored);
          } catch (e) {
            unlocks = {};
          }
        }

        unlocks[segmentId] = true;
        localStorage.setItem(
          "kaliToolsChickenUnlocks",
          JSON.stringify(unlocks)
        );
      }

      // Update badges display in Kali Tools Modal
      function updateKaliToolsBadges() {
        const container = document.getElementById(
          "kali-tools-badges-container"
        );
        if (!container) return;

        container.innerHTML = "";

        // Get all unique badge requirements from Kali Tools items
        const sections = parseKaliToolsContent();
        const requiredSegments = new Set();

        sections.forEach((section) => {
          section.items.forEach((item) => {
            if (item.badgeRequired) {
              requiredSegments.add(item.badgeRequired);
            }
          });
        });

        // Display badges for required segments
        Array.from(requiredSegments).forEach((segmentId) => {
          const segment = badgeSegments.find((s) => s.id === segmentId);
          if (!segment) return;

          const isUnlocked = checkBadgeUnlocked(segmentId);
          const progress = getSegmentProgress(segmentId);
          const totalQuizzes = segment.quizIds.length;
          const progressPercentage =
            totalQuizzes > 0 ? Math.round((progress / totalQuizzes) * 100) : 0;

          const badge = document.createElement("div");
          badge.className = `kali-tools-badge ${
            isUnlocked ? "unlocked" : "locked"
          }`;

          badge.innerHTML = `
            <span class="kali-tools-badge-icon">${segment.icon}</span>
            <span class="kali-tools-badge-name">${segment.name}</span>
            <span class="kali-tools-badge-progress">${progress}/${totalQuizzes}</span>
          `;

          badge.title = isUnlocked
            ? `${segment.name} freigeschaltet (${progressPercentage}%)`
            : `${segment.name} benötigt: ${progress}/${totalQuizzes} Quiz abgeschlossen (${progressPercentage}%)`;

          // Click handler: scroll to relevant section or show info
          badge.addEventListener("click", () => {
            // Find first item with this badge requirement and scroll to it
            const firstItem = document.querySelector(
              `.kali-tools-item[data-badge-required="${segmentId}"]`
            );
            if (firstItem) {
              firstItem.scrollIntoView({ behavior: "smooth", block: "center" });
              // Highlight briefly
              firstItem.style.background = "rgba(239, 68, 68, 0.2)";
              setTimeout(() => {
                firstItem.style.background = "";
              }, 2000);
            }
          });

          container.appendChild(badge);
        });
      }

      // Open example overlay
      function openExampleOverlay(tool) {
        const overlay = document.getElementById("kali-tools-example-overlay");
        const overlayInner = document.getElementById(
          "kali-tools-example-overlay-inner"
        );
        const overlayTitle = document.getElementById(
          "kali-tools-example-overlay-title"
        );
        const overlayContent = document.getElementById(
          "kali-tools-example-overlay-content"
        );

        if (!overlay || !overlayInner || !overlayTitle || !overlayContent)
          return;

        overlayTitle.textContent = tool.name;

        let contentHTML = `<div class="kali-tools-name">${tool.name}</div>`;
        contentHTML += `<div class="kali-tools-description">${tool.description}</div>`;

        if (tool.benefit) {
          contentHTML += `<div class="kali-tools-benefit">💡 ${tool.benefit}</div>`;
        }

        if (tool.command) {
          const formattedCommand = tool.command
            .split("\n")
            .map((line) => line.trim())
            .filter((line) => line.length > 0)
            .join("\n");
          contentHTML += `<div class="kali-tools-command">${formattedCommand.replace(
            /\n/g,
            "<br>"
          )}</div>`;
        }

        if (tool.example) {
          contentHTML += `<div class="kali-tools-example" style="margin-top: 1rem;">
            <div class="kali-tools-example-title">📝 Anwendungsbeispiel</div>
            <div class="kali-tools-example-content">${tool.example}</div>
          </div>`;
        }

        overlayContent.innerHTML = contentHTML;
        overlay.classList.remove("hidden");
        overlay.setAttribute("aria-hidden", "false");
      }

      // Close example overlay
      function closeExampleOverlay() {
        const overlay = document.getElementById("kali-tools-example-overlay");
        if (overlay) {
          overlay.classList.add("hidden");
          overlay.setAttribute("aria-hidden", "true");
        }
      }

      let currentMasterQuizSegment = null;

      // Initial load achievements and badges
      migrateToBadgeProgress();
      buildCheatSheetMap(); // Initialisiere Cheat-Sheet-Map für Badge-System
      updateAchievements();
      updateBadgeDisplay();
      assignBadgeToCards();

      function renderCommandModalContent(meta) {
        if (commandModalTitle) {
          commandModalTitle.textContent = meta.title || "Befehl";
        }
        if (commandModalSubtitle) {
          commandModalSubtitle.textContent =
            meta.subtitle || "Kompaktüberblick";
        }
        if (commandModalSummary) {
          commandModalSummary.textContent = meta.summary || "";
        }

        if (commandModalFlags) {
          commandModalFlags.innerHTML = "";
          if (meta.flags && meta.flags.length) {
            meta.flags.forEach((flag) => {
              const pill = document.createElement("div");
              pill.className = "flag-pill";
              pill.innerHTML = `<span>${flag.flag}</span><small>${flag.description}</small>`;
              commandModalFlags.appendChild(pill);
            });
          } else {
            commandModalFlags.textContent = "Keine besonderen Flags";
          }
        }

        if (commandModalPitfalls) {
          commandModalPitfalls.innerHTML = "";
          if (meta.pitfalls && meta.pitfalls.length) {
            meta.pitfalls.forEach((pit) => {
              const li = document.createElement("li");
              li.textContent = pit;
              commandModalPitfalls.appendChild(li);
            });
          } else {
            const li = document.createElement("li");
            li.textContent = "Keine bekannten Stolpersteine";
            commandModalPitfalls.appendChild(li);
          }
        }

        if (commandModalExamples) {
          commandModalExamples.innerHTML = "";
          if (meta.examples && meta.examples.length) {
            meta.examples.forEach((example) => {
              const item = document.createElement("div");
              item.className = "example-item";
              const cmd = document.createElement("code");
              cmd.textContent = example.command;
              const note = document.createElement("div");
              note.style.marginTop = "0.35rem";
              note.textContent = example.note || "";
              item.appendChild(cmd);
              item.appendChild(note);
              commandModalExamples.appendChild(item);
            });
          } else {
            const item = document.createElement("div");
            item.textContent = "Noch keine Beispiele hinterlegt.";
            commandModalExamples.appendChild(item);
          }
        }
      }

      function openCommandModal(commandKey, quizId) {
        if (!commandModalRoot) return;
        const meta = commandMeta[commandKey] || commandMeta[quizId];
        if (!meta) {
          console.warn("Keine Metadaten für", commandKey || quizId);
          if (typeof openQuiz === "function" && quizId) {
            openQuiz(quizId);
          }
          return;
        }

        renderCommandModalContent(meta);

        if (commandModalFeedback) {
          commandModalFeedback.textContent =
            "ESC oder Klick auf den Hintergrund schließen das Modal.";
        }

        if (commandModalQuizBtn) {
          if (quizId) {
            commandModalQuizBtn.disabled = false;
            commandModalQuizBtn.onclick = () => {
              closeCommandModal();
              openQuiz(quizId);
            };
          } else {
            commandModalQuizBtn.disabled = true;
          }
        }

        commandModalRoot.classList.remove("hidden");
        commandModalRoot.setAttribute("aria-hidden", "false");
        activateFocusTrap(commandModalRoot);
      }

      function closeCommandModal() {
        if (!commandModalRoot) return;
        commandModalRoot.classList.add("hidden");
        commandModalRoot.setAttribute("aria-hidden", "true");
        releaseFocusTrap();
      }

      commandCards.forEach((card) => {
        const quizId = card.dataset.quizId;
        if (!quizId) return;
        card.addEventListener("click", () => {
          openCommandModal(card.dataset.command || quizId, quizId);
        });
      });

      // Helper function to search in quiz data
      function searchInQuizData(quizId, query) {
        if (!query || !quizId) return false;

        const quiz = quizData[quizId];
        if (!quiz) return false;

        const queryLower = query.toLowerCase();

        // Search in all text fields of the quiz
        const searchFields = [
          quiz.title,
          quiz.description,
          quiz.explanation,
          quiz.detail,
          quiz.simpleExample,
          quiz.complexExample,
          quiz.additionalExamples,
        ];

        // Search in questions
        if (quiz.questions && Array.isArray(quiz.questions)) {
          quiz.questions.forEach((q) => {
            if (q.prompt) searchFields.push(q.prompt);
            if (q.explanation) searchFields.push(q.explanation);
            if (q.options && Array.isArray(q.options)) {
              q.options.forEach((opt) => searchFields.push(opt));
            }
          });
        }

        // Search in complex example explanations
        if (
          quiz.complexExampleExplanation &&
          Array.isArray(quiz.complexExampleExplanation)
        ) {
          quiz.complexExampleExplanation.forEach((exp) => {
            if (exp.line) searchFields.push(exp.line);
            if (exp.explanation) searchFields.push(exp.explanation);
          });
        }

        // Check if query matches any field
        return searchFields.some((field) => {
          if (!field) return false;
          // Remove HTML tags for searching
          const text =
            typeof field === "string"
              ? field.replace(/<[^>]*>/g, "").toLowerCase()
              : String(field).toLowerCase();
          return text.includes(queryLower);
        });
      }

      // Search functionality
      const searchInput = document.getElementById("search-input");
      if (searchInput) {
        searchInput.addEventListener("input", (e) => {
          const query = e.target.value.toLowerCase().trim();

          // Finde das aktive Segment (falls vorhanden)
          const segment = activeFilterSegment
            ? badgeSegments.find((s) => s.id === activeFilterSegment)
            : null;

          // Finde Achievement-Quiz-IDs (falls Achievement-Filter aktiv)
          const achievementQuizIds = activeFilterAchievement
            ? getQuizIdsForAchievement(activeFilterAchievement)
            : null;

          commandCards.forEach((card) => {
            const quizId = card.dataset.quizId;

            // Prüfe zuerst, ob die Karte zum aktiven Segment gehört
            let belongsToSegment = true;
            if (segment) {
              belongsToSegment = segment.quizIds.includes(quizId);
            }

            // Prüfe ob Karte zum Achievement-Filter gehört
            let belongsToAchievement = true;
            if (achievementQuizIds) {
              belongsToAchievement = achievementQuizIds.includes(quizId);
            }

            // Wenn Filter aktiv und Karte gehört nicht dazu, verstecken
            if (
              (segment && !belongsToSegment) ||
              (achievementQuizIds && !belongsToAchievement)
            ) {
              card.classList.add("hidden");
              return;
            }

            // Dann prüfe Suchanfrage
            const command = card.dataset.command?.toLowerCase() || "";
            const tag =
              card.querySelector(".command-tag")?.textContent.toLowerCase() ||
              "";
            const body =
              card.querySelector(".command-body")?.textContent.toLowerCase() ||
              "";

            // Search in card content
            const matchesCardContent =
              !query ||
              command.includes(query) ||
              tag.includes(query) ||
              body.includes(query);

            // Search in quiz data (explanations, examples, questions)
            const matchesQuizData = !query || searchInQuizData(quizId, query);

            const matches = matchesCardContent || matchesQuizData;

            // Karte verstecken, wenn sie nicht zur Suche passt
            if (!matches) {
              card.classList.add("hidden");
            } else if (!segment && !achievementQuizIds) {
              // Wenn kein Filter aktiv ist, Karte anzeigen
              card.classList.remove("hidden");
            } else if (
              (segment && belongsToSegment) ||
              (achievementQuizIds && belongsToAchievement)
            ) {
              // Wenn Filter aktiv und Karte gehört dazu, anzeigen
              card.classList.remove("hidden");
            }
          });
        });
      }

      function openQuiz(quizId) {
        const quiz = quizData[quizId];
        if (!quiz) {
          console.warn("Kein Quiz definiert für:", quizId);
          return;
        }
        currentQuizId = quizId;
        quizTitleEl.textContent = "Quiz zu " + quiz.title;
        quizSubtitleEl.textContent = "3 Fragen: leicht · mittel · schwer";
        quizFeedbackEl.textContent = "";

        quizBodyEl.innerHTML = "";
        // Render command info (explanation + simple example) and a collapsible details block
        const infoWrapper = document.createElement("div");
        infoWrapper.className = "quiz-command-info";
        const titleRow = document.createElement("div");
        titleRow.className = "cmd-title";
        const titleCode = document.createElement("code");
        titleCode.textContent = quiz.title;
        titleRow.appendChild(titleCode);
        infoWrapper.appendChild(titleRow);

        const expl = document.createElement("div");
        expl.className = "cmd-expl";
        expl.textContent = quiz.explanation || quiz.description || "";
        infoWrapper.appendChild(expl);

        if (quiz.simpleExample) {
          const ex = document.createElement("div");
          ex.className = "cmd-example";
          ex.textContent = "Einfaches Beispiel: " + quiz.simpleExample;
          infoWrapper.appendChild(ex);
        }

        // details toggle + content
        const detailsToggle = document.createElement("button");
        detailsToggle.className = "quiz-details-toggle";
        detailsToggle.type = "button";
        detailsToggle.textContent = "Weitere Details anzeigen";
        const details = document.createElement("div");
        details.className = "quiz-details";
        if (quiz.detail) {
          const det = document.createElement("div");
          det.innerHTML = "<strong>Detail:</strong>\n" + quiz.detail;
          details.appendChild(det);
        }
        if (quiz.complexExample) {
          const comp = document.createElement("div");
          comp.style.marginTop = "0.5rem";
          comp.innerHTML =
            "<strong>Komplexeres Beispiel:</strong>\n" + quiz.complexExample;
          details.appendChild(comp);

          // Zeile-für-Zeile Erklärung hinzufügen
          if (
            quiz.complexExampleExplanation &&
            quiz.complexExampleExplanation.length > 0
          ) {
            const explanationToggle = document.createElement("button");
            explanationToggle.className = "quiz-details-toggle";
            explanationToggle.type = "button";
            explanationToggle.style.marginTop = "0.5rem";
            explanationToggle.textContent =
              "Zeile-für-Zeile Erklärung anzeigen";

            const explanationDiv = document.createElement("div");
            explanationDiv.className = "quiz-details complex-explanation";
            explanationDiv.style.display = "none";

            quiz.complexExampleExplanation.forEach((item, idx) => {
              const lineWrapper = document.createElement("div");
              lineWrapper.style.marginBottom = "0.8rem";

              const lineCode = document.createElement("div");
              lineCode.style.fontFamily =
                '"JetBrains Mono", "Fira Code", "Source Code Pro", ui-monospace, SFMono-Regular, Menlo, Monaco, monospace';
              lineCode.style.fontFeatureSettings = '"zero", "onum"';
              lineCode.style.fontVariantNumeric = "tabular-nums";
              lineCode.style.letterSpacing = "0.01em";
              lineCode.style.fontSize = "0.85rem";
              lineCode.style.color = "#93c5fd";
              lineCode.style.marginBottom = "0.3rem";
              lineCode.style.padding = "0.3rem 0.5rem";
              lineCode.style.background = "rgba(59, 130, 246, 0.1)";
              lineCode.style.borderRadius = "0.4rem";
              lineCode.style.borderLeft = "3px solid #3b82f6";
              lineCode.textContent = item.line;

              const explanationText = document.createElement("div");
              explanationText.style.fontSize = "0.85rem";
              explanationText.style.color = "#cbd5e1";
              explanationText.style.paddingLeft = "0.5rem";
              explanationText.textContent = item.explanation;

              lineWrapper.appendChild(lineCode);
              lineWrapper.appendChild(explanationText);
              explanationDiv.appendChild(lineWrapper);
            });

            explanationToggle.addEventListener("click", () => {
              const isShown = explanationDiv.style.display === "block";
              explanationDiv.style.display = isShown ? "none" : "block";
              explanationToggle.textContent = isShown
                ? "Zeile-für-Zeile Erklärung anzeigen"
                : "Erklärung verbergen";
            });

            details.appendChild(explanationToggle);
            details.appendChild(explanationDiv);
          }
        }

        // Additional examples (e.g., for find command)
        if (quiz.additionalExamples) {
          const addEx = document.createElement("div");
          addEx.style.marginTop = "1rem";
          addEx.style.padding = "1rem";
          addEx.style.background = "rgba(59, 130, 246, 0.05)";
          addEx.style.borderRadius = "0.5rem";
          addEx.style.border = "1px solid rgba(59, 130, 246, 0.2)";
          addEx.innerHTML =
            "<strong style='color: #93c5fd; display: block; margin-bottom: 0.8rem;'>📚 Weitere praktische Beispiele:</strong>" +
            quiz.additionalExamples;
          details.appendChild(addEx);
        }

        detailsToggle.addEventListener("click", () => {
          const isShown = details.style.display === "block";
          details.style.display = isShown ? "none" : "block";
          detailsToggle.textContent = isShown
            ? "Weitere Details anzeigen"
            : "Details verbergen";
        });
        infoWrapper.appendChild(detailsToggle);
        infoWrapper.appendChild(details);
        quizBodyEl.appendChild(infoWrapper);
        quiz.questions.forEach((q, idx) => {
          const questionId = "q_" + idx;
          const wrapper = document.createElement("div");
          wrapper.className = "quiz-question";
          const title = document.createElement("div");
          title.className = "quiz-question-title";
          title.textContent = q.prompt;
          const meta = document.createElement("div");
          meta.className = "quiz-question-meta";
          meta.textContent = "Frage " + (idx + 1) + " · Level: " + q.level;
          const options = document.createElement("div");
          options.className = "quiz-options";
          q.options.forEach((opt, optIdx) => {
            const label = document.createElement("label");
            label.className = "quiz-option";
            label.dataset.optionIndex = optIdx;
            const radio = document.createElement("input");
            radio.type = "radio";
            radio.name = questionId;
            radio.value = optIdx;
            const text = document.createElement("span");
            text.textContent = opt;
            label.appendChild(radio);
            label.appendChild(text);
            options.appendChild(label);
          });
          // Chicken-Button hinzufügen
          const chickenBtn = document.createElement("button");
          chickenBtn.type = "button";
          chickenBtn.className = "quiz-chicken-btn";
          chickenBtn.textContent = "🐔 Lösung zeigen";
          chickenBtn.dataset.questionIndex = idx;
          chickenBtn.dataset.correctIndex = q.correctIndex;
          chickenBtn.addEventListener("click", function () {
            const correctIdx = parseInt(this.dataset.correctIndex);
            const allLabels = options.querySelectorAll("label");
            allLabels.forEach((label, labelIdx) => {
              if (labelIdx === correctIdx) {
                label.classList.add("highlight-correct");
                const radio = label.querySelector("input[type=radio]");
                if (radio) radio.checked = true;
              } else {
                label.classList.remove("highlight-correct");
              }
            });
            this.disabled = true;
            this.style.opacity = "0.5";
            this.style.cursor = "not-allowed";
          });
          wrapper.dataset.quizQuestionIndex = idx;
          wrapper.appendChild(title);
          wrapper.appendChild(meta);
          wrapper.appendChild(options);
          wrapper.appendChild(chickenBtn);
          quizBodyEl.appendChild(wrapper);
        });

        quizRoot.classList.remove("hidden");
        quizRoot.setAttribute("aria-hidden", "false");
      }

      quizSubmitBtn.addEventListener("click", () => {
        if (!currentQuizId) return;
        const quiz = quizData[currentQuizId];
        const questionEls = Array.from(
          quizBodyEl.querySelectorAll(".quiz-question")
        );
        let correct = 0;
        let answered = 0;

        questionEls.forEach((qEl, idx) => {
          const radios = qEl.querySelectorAll("input[type=radio]");
          let selectedIndex = null;
          radios.forEach((r, rIdx) => {
            if (r.checked) selectedIndex = rIdx;
          });
          if (selectedIndex !== null) {
            answered++;
            if (selectedIndex === quiz.questions[idx].correctIndex) correct++;
          }
        });

        if (answered < quiz.questions.length) {
          quizFeedbackEl.textContent = "Bitte alle 3 Fragen beantworten.";
          quizFeedbackEl.style.color = "#facc15";
          return;
        }
        if (correct === quiz.questions.length) {
          // Get total before saving
          const previousTotal = getTotalCorrectAnswers();

          // Save result (only if all correct and not already completed)
          const isNewCompletion = saveQuizResult(currentQuizId, correct);

          quizFeedbackEl.textContent = "Stark! Alle Fragen korrekt. 🎉";
          quizFeedbackEl.style.color = "#22c55e";
          markCardAsCompleted(currentQuizId);

          // Celebration Animation
          triggerCelebrationAnimation(quizRoot);

          // Check for new achievements only if this was a new completion
          if (isNewCompletion) {
            const newTotal = getTotalCorrectAnswers();
            const newAchievement = achievements.find(
              (a) => newTotal >= a.threshold && previousTotal < a.threshold
            );

            if (newAchievement) {
              setTimeout(() => {
                alert(
                  `🎉 Achievement freigeschaltet: ${newAchievement.icon} ${newAchievement.name}!`
                );
              }, 500);
            }

            // Update achievements display
            updateAchievements();
            updateBadgeDisplay();

            // Check if segment is complete and trigger master quiz
            badgeSegments.forEach((segment) => {
              if (segment.quizIds.includes(currentQuizId)) {
                const progress = getSegmentProgress(segment.id);
                if (
                  progress >= segment.quizIds.length &&
                  !isMasterQuizCompleted(segment.id)
                ) {
                  // Segment complete, badge should be ready
                  updateBadgeDisplay();
                }
              }
            });
          }

          // Schließe Modal nach Animation
          setTimeout(() => {
            closeQuiz();
          }, 1200);
        } else {
          quizFeedbackEl.textContent =
            "Du hast " +
            correct +
            "/" +
            quiz.questions.length +
            " richtig. Schau dir die Erklärungen noch einmal an.";
          quizFeedbackEl.style.color = "#f97316";

          // Fehler-Feedback: Roter Flash + Shake
          triggerErrorFeedback(quizRoot);
        }
      });

      function markCardAsCompleted(quizId) {
        const card = commandCards.find((c) => c.dataset.quizId === quizId);
        if (!card) return;
        card.classList.add("quiz-done", "flash-once");
        setTimeout(() => {
          card.classList.remove("flash-once");
        }, 1000);
      }

      // Celebration Animation: Partikel brechen aus dem Modal heraus
      function triggerCelebrationAnimation(modalElement) {
        if (!modalElement) return;

        const modalInner =
          modalElement.querySelector(".quiz-modal-inner") ||
          modalElement.querySelector(".master-quiz-modal-inner");
        if (!modalInner) return;

        // Füge Celebration-Klasse hinzu
        modalElement.classList.add("celebration");

        // Erstelle Partikel
        const rect = modalInner.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        const particleCount = 20;

        for (let i = 0; i < particleCount; i++) {
          const particle = document.createElement("div");
          particle.className = "celebration-particle";

          // Zufällige Richtung und Entfernung
          const angle = (Math.PI * 2 * i) / particleCount + Math.random() * 0.5;
          const distance = 100 + Math.random() * 150;
          const tx = Math.cos(angle) * distance;
          const ty = Math.sin(angle) * distance;

          particle.style.left = centerX + "px";
          particle.style.top = centerY + "px";
          particle.style.setProperty("--tx", tx + "px");
          particle.style.setProperty("--ty", ty + "px");

          // Zufällige Größe und Farbe
          const size = 6 + Math.random() * 6;
          particle.style.width = size + "px";
          particle.style.height = size + "px";

          // Zufällige Farbvariation
          const colors = [
            "radial-gradient(circle, #fbbf24, #f59e0b)",
            "radial-gradient(circle, #fcd34d, #fbbf24)",
            "radial-gradient(circle, #fde68a, #fcd34d)",
            "radial-gradient(circle, #34d399, #10b981)",
            "radial-gradient(circle, #60a5fa, #3b82f6)",
          ];
          particle.style.background =
            colors[Math.floor(Math.random() * colors.length)];

          document.body.appendChild(particle);

          // Entferne Partikel nach Animation
          setTimeout(() => {
            particle.remove();
          }, 1500);
        }
      }

      // Fehler-Feedback: Roter Flash + Shake
      function triggerErrorFeedback(modalElement) {
        if (!modalElement) return;

        const modalInner =
          modalElement.querySelector(".quiz-modal-inner") ||
          modalElement.querySelector(".master-quiz-modal-inner");
        if (!modalInner) return;

        // Füge Shake-Klasse hinzu
        modalElement.classList.add("error-feedback");
        modalInner.classList.add("error-flash");

        // Entferne Klassen nach Animation
        setTimeout(() => {
          modalElement.classList.remove("error-feedback");
          modalInner.classList.remove("error-flash");
        }, 500);
      }

      function closeQuiz() {
        quizRoot.classList.add("hidden");
        quizRoot.setAttribute("aria-hidden", "true");
        quizFeedbackEl.textContent = "";
        currentQuizId = null;
      }

      quizCloseBtn.addEventListener("click", closeQuiz);
      quizRoot.addEventListener("click", (event) => {
        if (event.target.classList.contains("quiz-backdrop")) {
          closeQuiz();
        }
      });
      document.addEventListener("keydown", (event) => {
        if (event.key === "Escape" && !quizRoot.classList.contains("hidden")) {
          closeQuiz();
        }
        if (
          event.key === "Escape" &&
          document.getElementById("master-quiz-root") &&
          !document
            .getElementById("master-quiz-root")
            .classList.contains("hidden")
        ) {
          closeMasterQuiz();
        }
        if (
          event.key === "Escape" &&
          document.getElementById("hotkeys-root") &&
          !document.getElementById("hotkeys-root").classList.contains("hidden")
        ) {
          closeHotkeysModal();
        }
        if (
          event.key === "Escape" &&
          document.getElementById("kali-tools-root") &&
          !document
            .getElementById("kali-tools-root")
            .classList.contains("hidden")
        ) {
          closeKaliToolsModal();
        }
        if (
          event.key === "Escape" &&
          document.getElementById("kali-tools-example-overlay") &&
          !document
            .getElementById("kali-tools-example-overlay")
            .classList.contains("hidden")
        ) {
          closeExampleOverlay();
        }
        if (
          event.key === "Escape" &&
          document.getElementById("mistakes-root") &&
          !document.getElementById("mistakes-root").classList.contains("hidden")
        ) {
          closeMistakesModal();
        }
      });

      // Master Quiz Submit Handler
      const masterQuizSubmitBtn = document.getElementById(
        "master-quiz-submit-btn"
      );
      const masterQuizCloseBtn = document.getElementById(
        "master-quiz-close-btn"
      );
      const masterQuizFeedbackEl = document.getElementById(
        "master-quiz-feedback"
      );

      if (masterQuizSubmitBtn) {
        masterQuizSubmitBtn.addEventListener("click", () => {
          if (!currentMasterQuizSegment) return;

          const masterQuiz = masterQuizData[currentMasterQuizSegment];
          if (!masterQuiz) return;

          const selectedOption = document.querySelector(
            'input[name="master-quiz-option"]:checked'
          );
          if (!selectedOption) {
            masterQuizFeedbackEl.textContent = "Bitte eine Antwort auswählen.";
            masterQuizFeedbackEl.style.color = "#facc15";
            return;
          }

          const selectedIndex = parseInt(selectedOption.value);

          if (selectedIndex === masterQuiz.correctIndex) {
            setMasterQuizCompleted(currentMasterQuizSegment);

            // Prüfe ob dieses Segment einem Achievement entspricht
            const achievementThreshold = getAchievementThresholdFromSegment(
              currentMasterQuizSegment
            );
            if (achievementThreshold) {
              setAchievementMasterCompleted(achievementThreshold);
            }

            masterQuizFeedbackEl.innerHTML = `<div style="color: #22c55e; font-weight: 600;">🎉 Perfekt! Masterquiz bestanden!${
              achievementThreshold ? " Badge vergoldet! 🏆" : ""
            }</div><div style="margin-top: 0.5rem; font-size: 0.85rem; color: #d1d5db;">${
              masterQuiz.explanation
            }</div>`;

            // Celebration Animation
            const masterQuizRoot = document.getElementById("master-quiz-root");
            if (masterQuizRoot) {
              triggerCelebrationAnimation(masterQuizRoot);
            }

            // Update badge display
            updateBadgeDisplay();
            updateAchievements();

            setTimeout(() => {
              closeMasterQuiz();
            }, 1200);
          } else {
            masterQuizFeedbackEl.innerHTML = `<div style="color: #f97316;">Falsch. Versuche es erneut.</div><div style="margin-top: 0.5rem; font-size: 0.85rem; color: #d1d5db;">${masterQuiz.explanation}</div>`;

            // Fehler-Feedback: Roter Flash + Shake
            const masterQuizRoot = document.getElementById("master-quiz-root");
            if (masterQuizRoot) {
              triggerErrorFeedback(masterQuizRoot);
            }
          }
        });
      }

      if (masterQuizCloseBtn) {
        masterQuizCloseBtn.addEventListener("click", closeMasterQuiz);
      }

      const masterQuizRoot = document.getElementById("master-quiz-root");
      if (masterQuizRoot) {
        masterQuizRoot.addEventListener("click", (event) => {
          if (event.target.classList.contains("quiz-backdrop")) {
            closeMasterQuiz();
          }
        });
      }

      if (commandModalCloseBtn) {
        commandModalCloseBtn.addEventListener("click", closeCommandModal);
      }

      if (commandModalRoot) {
        commandModalRoot.addEventListener("click", (event) => {
          if (event.target.classList.contains("quiz-backdrop")) {
            closeCommandModal();
          }
        });
      }

      document.addEventListener("keydown", (event) => {
        if (
          event.key === "Escape" &&
          commandModalRoot &&
          !commandModalRoot.classList.contains("hidden")
        ) {
          closeCommandModal();
        }
      });

      // Hotkeys Modal Event Handlers
      const hotkeysCloseBtn = document.getElementById("hotkeys-close-btn");
      if (hotkeysCloseBtn) {
        hotkeysCloseBtn.addEventListener("click", closeHotkeysModal);
      }

      const hotkeysRoot = document.getElementById("hotkeys-root");
      if (hotkeysRoot) {
        hotkeysRoot.addEventListener("click", (event) => {
          if (event.target.classList.contains("quiz-backdrop")) {
            closeHotkeysModal();
          }
        });
      }

      // Hotkeys Card Click Handler
      const hotkeysCard = document.getElementById("hotkeys-card");
      if (hotkeysCard) {
        hotkeysCard.addEventListener("click", openHotkeysModal);
      }

      function openMistakesModal() {
        const modal = document.getElementById("mistakes-root");
        const bodyEl = document.getElementById("mistakes-body");

        if (!modal || !bodyEl) return;

        bodyEl.innerHTML = "";

        const list = document.createElement("div");
        list.className = "mistakes-list";

        beginnerMistakes.forEach((item, index) => {
          const row = document.createElement("button");
          row.type = "button";
          row.className = "mistake-row";
          row.setAttribute("data-quiz-id", item.quizId);

          const header = document.createElement("div");
          header.className = "mistake-row-header";

          const idxEl = document.createElement("span");
          idxEl.className = "mistake-index";
          idxEl.textContent = String(index + 1).padStart(2, "0");
          header.appendChild(idxEl);

          const titleEl = document.createElement("span");
          titleEl.className = "mistake-title";
          titleEl.textContent = item.title;
          header.appendChild(titleEl);

          if (isQuizCompleted(item.quizId)) {
            const badge = document.createElement("span");
            badge.className = `badge-mini ${item.segmentClass || "segment-1"}`;
            badge.textContent = "✔";
            badge.title = "Thema abgeschlossen (3/3 Fragen)";
            header.appendChild(badge);
          }

          row.appendChild(header);

          const desc = document.createElement("p");
          desc.className = "mistake-description";
          desc.textContent = item.description;
          row.appendChild(desc);

          if (item.example) {
            const example = document.createElement("div");
            example.className = "mistake-example";
            example.innerHTML = `✅ Korrekt: <code>${item.example}</code>`;
            row.appendChild(example);
          }

          if (item.tip) {
            const meta = document.createElement("div");
            meta.className = "mistake-meta";
            meta.innerHTML = `💡 ${item.tip} · 🔗 Quiz-ID: <code>${item.quizId}</code>`;
            row.appendChild(meta);
          }

          row.addEventListener("click", () => {
            closeMistakesModal();
            openQuiz(item.quizId);
          });

          list.appendChild(row);
        });

        bodyEl.appendChild(list);

        modal.classList.remove("hidden");
        modal.setAttribute("aria-hidden", "false");
      }

      function closeMistakesModal() {
        const modal = document.getElementById("mistakes-root");
        if (modal) {
          modal.classList.add("hidden");
          modal.setAttribute("aria-hidden", "true");
        }
      }

      // Kali Tools Modal Event Handlers
      const kaliToolsCloseBtn = document.getElementById("kali-tools-close-btn");
      if (kaliToolsCloseBtn) {
        kaliToolsCloseBtn.addEventListener("click", closeKaliToolsModal);
      }

      const kaliToolsRoot = document.getElementById("kali-tools-root");
      if (kaliToolsRoot) {
        kaliToolsRoot.addEventListener("click", (event) => {
          if (event.target.classList.contains("quiz-backdrop")) {
            closeKaliToolsModal();
          }
        });
      }

      // Kali Tools Card Click Handler
      const kaliToolsCard = document.getElementById("kali-tools-card");
      if (kaliToolsCard) {
        kaliToolsCard.addEventListener("click", openKaliToolsModal);
      }

      // Beginner Mistakes Card Click Handler
      const mistakesCard = document.getElementById("mistakes-card");
      if (mistakesCard) {
        mistakesCard.addEventListener("click", openMistakesModal);
      }

      // Beginner Mistakes Modal Event Handlers
      const mistakesCloseBtn = document.getElementById("mistakes-close-btn");
      if (mistakesCloseBtn) {
        mistakesCloseBtn.addEventListener("click", closeMistakesModal);
      }

      const mistakesRoot = document.getElementById("mistakes-root");
      if (mistakesRoot) {
        mistakesRoot.addEventListener("click", (event) => {
          if (event.target.classList.contains("quiz-backdrop")) {
            closeMistakesModal();
          }
        });
      }

      // Kali Tools Example Overlay Event Handlers
      const exampleOverlayCloseBtn = document.getElementById(
        "kali-tools-example-overlay-close"
      );
      if (exampleOverlayCloseBtn) {
        exampleOverlayCloseBtn.addEventListener("click", closeExampleOverlay);
      }

      const exampleOverlay = document.getElementById(
        "kali-tools-example-overlay"
      );
      if (exampleOverlay) {
        exampleOverlay.addEventListener("click", (event) => {
          if (event.target.classList.contains("quiz-backdrop")) {
            closeExampleOverlay();
          }
        });
      }
    </script>
  </body>
</html>
